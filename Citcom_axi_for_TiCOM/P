Advection_diffusion.c:51:    E->advection.temp_iterations = 2; /* petrov-galerkin iterations: minimum value. */
Advection_diffusion.c:52:    E->advection.total_timesteps = 1; 
Advection_diffusion.c:53:    E->advection.sub_iterations = 1;
Advection_diffusion.c:54:    E->advection.last_sub_iterations = 1;
Advection_diffusion.c:55:    E->advection.gamma = 0.5;
Advection_diffusion.c:56:    E->advection.dt_reduced = 1.0;         
Advection_diffusion.c:58:    E->monitor.T_maxvaried = 1.02;
Advection_diffusion.c:60:    input_boolean("ADV",&(E->advection.ADVECTION),"on");
Advection_diffusion.c:61:    E->advection.ADVECTION=1;
Advection_diffusion.c:63:    input_int("visc_heating",&(E->control.visc_heating),"1");
Advection_diffusion.c:64:    input_int("adi_heating",&(E->control.adi_heating),"1");
Advection_diffusion.c:65:    input_int("latent_heating",&(E->control.latent_heating),"1");
Advection_diffusion.c:67:    input_int("minstep",&(E->advection.min_timesteps),"1");
Advection_diffusion.c:68:    input_int("maxstep",&(E->advection.max_timesteps),"1000");
Advection_diffusion.c:69:    input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000");
Advection_diffusion.c:70:    input_float("finetunedt",&(E->advection.fine_tune_dt),"0.9");
Advection_diffusion.c:71:    input_float("fixed_timestep",&(E->advection.fixed_timestep),"0.0");
Advection_diffusion.c:72:    input_int("adv_sub_iterations",&(E->advection.temp_iterations),"2,2,nomax");
Advection_diffusion.c:73:    input_float("maxadvtime",&(E->advection.max_dimensionless_time),"10.0");
Advection_diffusion.c:75:    input_float("sub_tolerance",&(E->advection.vel_substep_aggression),"0.005");  
Advection_diffusion.c:76:    input_int("maxsub",&(E->advection.max_substeps),"25");
Advection_diffusion.c:78:    input_float("liddefvel",&(E->advection.lid_defining_velocity),"0.01");
Advection_diffusion.c:79:    input_float("sublayerfrac",&(E->advection.sub_layer_sample_level),"0.5");            
Advection_diffusion.c:80:        input_float("Q0_enriched",&(E->control.Q0ER),"0.0");
Advection_diffusion.c:81:    input_int("markers_per_ele",&(E->advection.markers_per_ele),"0");
Advection_diffusion.c:93:  E->Tdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:94:  for(i=1;i<=E->mesh.nno;i++) 
Advection_diffusion.c:95:    E->Tdot[i]=0.0;
Advection_diffusion.c:97:  if (E->control.composition)   {
Advection_diffusion.c:98:    E->Cdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:99:    for(i=1;i<=E->mesh.nno;i++)
Advection_diffusion.c:100:      E->Cdot[i]=0.0;
Advection_diffusion.c:101:    if (!(strcmp(E->control.comp_adv_method,"field")==0)) {
Advection_diffusion.c:102:      E->advection.markers = E->advection.markers_per_ele*E->mesh.nel;
Advection_diffusion.c:103:      for(i=1;i<=E->mesh.nsd;i++)   {
Advection_diffusion.c:104:        E->VO[i] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:105:        E->XMC[i] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:106:        E->XMCpred[i] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:108:      E->C12 = (int *) malloc ((E->advection.markers+1)*sizeof(int));
Advection_diffusion.c:109:      E->C12f = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Advection_diffusion.c:110:      E->CElement = (int *) malloc ((E->advection.markers+1)*sizeof(int));
Advection_diffusion.c:150:		const int nel=E->mesh.nel;
Advection_diffusion.c:158:      DTdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:162:      E->advection.timesteps++;
Advection_diffusion.c:164:      E->advection.total_timesteps++;
Advection_diffusion.c:172:        Runge_Kutta(E,E->XMC,E->XMCpred,E->C,E->V,E->VO);
Advection_diffusion.c:182:				for(i=1;i<=E->mesh.nno;i++){
Advection_diffusion.c:184:						E->C[i] *= ( E->Total.bulk_comp/C);
Advection_diffusion.c:187:        for(e=1;e<=E->mesh.nel;e++){
Advection_diffusion.c:189:						E->CE[e] *= ( E->Total.bulk_comp/C);
Advection_diffusion.c:194:			  //p_to_centres(E,E->C,E->CE,E->mesh.levmax);
Advection_diffusion.c:195:			  E->Total.bulk_comp_prev = 0.0;
Advection_diffusion.c:196:			  for(e=1;e<=E->mesh.nel;e++) {
Advection_diffusion.c:197:			   	E->Total.bulk_comp_prev += E->CE[e] * E->eco[e].area;
Advection_diffusion.c:198:				  E->CE_prev[e] = E->CE[e];
Advection_diffusion.c:201:			  E->Total.bulk_comp_prev /= E->Total.vol;
Advection_diffusion.c:208:			for(i=1;i<=E->mesh.nno;i++)
Advection_diffusion.c:209:				E->C_prev[i] = E->C[i];
Advection_diffusion.c:211:			for(e=1;e<=E->mesh.nel;e++) {
Advection_diffusion.c:212:					E->CE_prev[e] = E->CE[e];
Advection_diffusion.c:213:					E->advection.element_prev[0][e] = E->advection.element[0][e];
Advection_diffusion.c:214:					E->advection.element_prev[1][e] = E->advection.element[1][e];
Advection_diffusion.c:218:      Euler(E,E->XMC,E->XMCpred,E->C,E->V,E->VO);
Advection_diffusion.c:222:      predictor(E,E->T,E->Tdot,1);
Advection_diffusion.c:223:      for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Advection_diffusion.c:224:          pg_solver(E,E->T,E->Tdot,DTdot,E->V,1.0,E->TB,E->node);
Advection_diffusion.c:225:          corrector(E,E->T,E->Tdot,DTdot,1);
Advection_diffusion.c:228:      temperatures_conform_bcs(E,E->T);
Advection_diffusion.c:236:			if (E->control.melting) {
Advection_diffusion.c:238:				p_to_centres(E,E->T,E->TE,E->mesh.levmax);
Advection_diffusion.c:241:				for(i=1;i<=E->mesh.nel;i++) {
Advection_diffusion.c:242:					k = ((i-1) % E->mesh.elz) + 1;
Advection_diffusion.c:243:					E->FmE[i] = melting(E,0.0,i,k);
Advection_diffusion.c:247:				for(i=1;i<=E->mesh.nno;i++) {
Advection_diffusion.c:248:					k = ((i-1) % E->mesh.noz) + 1;
Advection_diffusion.c:249:					E->Fm[i] = melting_by_node(E,0.0,i,k);
Advection_diffusion.c:256:        p_to_centres(E,E->C,E->CE,E->mesh.levmax);
Advection_diffusion.c:257:				p_to_centres(E,E->Fm,E->FmE,E->mesh.levmax);
Advection_diffusion.c:262:				E->Total.bulk_comp_prev = E->Total.bulk_comp;
Advection_diffusion.c:263:				E->Total.bulk_comp = 0.0;
Advection_diffusion.c:265:				for(j=1;j<=E->mesh.esf;j++){ 
Advection_diffusion.c:266:					E->slice.new_melt[j] = 0.0;
Advection_diffusion.c:268:					for(k=1;k<=E->mesh.elz;k++) {
Advection_diffusion.c:269:						e = (j-1)*E->mesh.elz + k;
Advection_diffusion.c:270:						E->slice.melt[j] += E->FmE[e]*E->eco[e].area/E->Total.vol;
Advection_diffusion.c:271:						E->slice.new_melt[j] += E->FmE[e]*E->eco[e].area;
Advection_diffusion.c:272:						E->Total.melt_prod += E->FmE[e]*E->eco[e].area/E->Total.vol;
Advection_diffusion.c:273:						E->Total.bulk_comp += E->CE[e] * E->eco[e].area;
Advection_diffusion.c:274:/*						if (E->advection.timesteps == 470)
Advection_diffusion.c:275:							fprintf(E->fpdebug,"a %d %g %g\n",e,E->CE[e],E->Total.bulk_comp);*/
Advection_diffusion.c:278:					E->slice.new_melt[j] /= E->Total.vol;
Advection_diffusion.c:281:        E->Total.bulk_comp /= E->Total.vol;
Advection_diffusion.c:287:			if (E->impacts.number >= 1)  
Advection_diffusion.c:288:				for(i=0;i<E->impacts.number;i++) {
Advection_diffusion.c:289:					if ((E->monitor.elapsed_time >= E->impacts.t[i]) && (E->impacts.flag[i] == 0)) {
Advection_diffusion.c:290:						fprintf(E->fp,"Time for impact %d: %e\n",i,E->monitor.elapsed_time);  
Advection_diffusion.c:291:						fprintf(stderr,"Time for impact %d: %e\n",i,E->monitor.elapsed_time);  
Advection_diffusion.c:292:            fprintf(E->fp,"read heat from file? %d\n",E->impacts.heat_from_file);
Advection_diffusion.c:293:            fprintf(stderr,"read heat from file? %d\n",E->impacts.heat_from_file);
Advection_diffusion.c:295:            return_horiz_ave(E,E->T,E->Have.Tprev);
Advection_diffusion.c:298:						E->impacts.flag[i]++; // Only impose heating once for each impact 
Advection_diffusion.c:306:    if( E->advection.timesteps < E->advection.max_timesteps)
Advection_diffusion.c:307:        E->control.keep_going = 1;
Advection_diffusion.c:309:        E->control.keep_going = 0;
Advection_diffusion.c:343:    DTdot= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:344:    T1= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:345:    Tdot1= (float *)malloc((E->mesh.nno+1)*sizeof(float));
Advection_diffusion.c:348:	  E->advection.timesteps=0;
Advection_diffusion.c:351:    E->advection.timesteps++;
Advection_diffusion.c:357:       predictor(E,E->T,E->Tdot,1);
Advection_diffusion.c:358:       for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Advection_diffusion.c:359:         pg_solver(E,E->T,E->Tdot,DTdot,E->V,1.0,E->TB,E->node);
Advection_diffusion.c:360:         corrector(E,E->T,E->Tdot,DTdot,1);
Advection_diffusion.c:363:   if (E->control.composition)         {
Advection_diffusion.c:364:	     predictor(E,E->C,E->Cdot,0);
Advection_diffusion.c:365:	     for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++) {
Advection_diffusion.c:366:	 	   pg_solver(E,E->C,E->Cdot,DTdot,E->V,E->control.comp_diff,E->CB,E->node);
Advection_diffusion.c:367:		   corrector(E,E->C,E->Cdot,DTdot,0);
Advection_diffusion.c:373:    E->advection.total_timesteps++;
Advection_diffusion.c:375:    temperatures_conform_bcs(E,E->T); 
Advection_diffusion.c:378:  	if (E->impacts.number >= 1) 
Advection_diffusion.c:379:    	for(i=0;i<E->impacts.number;i++) {
Advection_diffusion.c:380:      	if ((E->monitor.elapsed_time >= E->impacts.t[i]) && (E->impacts.flag[i] == 0)) {
Advection_diffusion.c:381:          fprintf(E->fp,"Time for impact %d: %e\n",i,E->monitor.elapsed_time);  
Advection_diffusion.c:382:          fprintf(stderr,"Time for impact %d: %e\n",i,E->monitor.elapsed_time); 
Advection_diffusion.c:383:          fprintf(E->fp,"read heat from file? %d\n",E->impacts.heat_from_file);
Advection_diffusion.c:384:          fprintf(stderr,"read heat from file? %d\n",E->impacts.heat_from_file);
Advection_diffusion.c:387:          return_horiz_ave(E,E->T,E->Have.Tprev);
Advection_diffusion.c:389:  	      E->impacts.flag[i]++; // Only impose heating once for each impact 
Advection_diffusion.c:397:    if( E->advection.timesteps < E->advection.max_timesteps)
Advection_diffusion.c:398:        E->control.keep_going = 1;
Advection_diffusion.c:400: 	    E->control.keep_going = 0;
Advection_diffusion.c:423:   multiplier = (1.0-E->advection.gamma) * E->advection.timestep;
Advection_diffusion.c:426:    for(node=1;node<=E->mesh.nno;node++)  {
Advection_diffusion.c:427:	if(!(E->node[node] & (OFFSIDE | TBX | TBZ | TBY))) 
Advection_diffusion.c:432:    for(node=1;node<=E->mesh.nno;node++)  {
Advection_diffusion.c:433:	if(!(E->node[node] & OFFSIDE )) 
Advection_diffusion.c:448:   multiplier = E->advection.gamma * E->advection.timestep;
Advection_diffusion.c:451:   for(node=1;node<=E->mesh.nno;node++) {
Advection_diffusion.c:452:       if(!(E->node[node] & (OFFSIDE | TBX | TBZ | TBY)))
Advection_diffusion.c:457:   for(node=1;node<=E->mesh.nno;node++) {
Advection_diffusion.c:458:       if(!(E->node[node] & OFFSIDE ))
Advection_diffusion.c:494:    const int dims=E->mesh.nsd;
Advection_diffusion.c:495:    const int dofs=E->mesh.dof;
Advection_diffusion.c:499:    for(i=1;i<=E->mesh.nno;i++)
Advection_diffusion.c:502:    for(el=1;el<=E->mesh.nel;el++)    {
Advection_diffusion.c:504:	  i = (el-1)%E->mesh.elz+1;
Advection_diffusion.c:505:	  /*diff =(E->diffusivity[i]+E->diffusivity[i+1])*0.5;*/
Advection_diffusion.c:507:	  get_global_shape_fn(E,el,&GN,&GNx,&dOmega,xk,0,E->mesh.levmax);
Advection_diffusion.c:512:	    a1 = E->ien[el].node[a];
Advection_diffusion.c:518:    for(i=1;i<=E->mesh.nno;i++) {
Advection_diffusion.c:519: 	  if(E->node[i] & OFFSIDE) continue;
Advection_diffusion.c:520:	  DTdot[i] *= E->Mass[i];         /* lumped mass matrix */
Advection_diffusion.c:550:    const int dims=E->mesh.nsd;
Advection_diffusion.c:551:    const int dofs=E->mesh.dof;
Advection_diffusion.c:552:    const int lev=E->mesh.levmax;
Advection_diffusion.c:553:    const int nno=E->mesh.nno;
Advection_diffusion.c:554:    const int ends=enodes[E->mesh.nsd];
Advection_diffusion.c:555:    const int vpts=vpoints[E->mesh.nsd];
Advection_diffusion.c:557:    ienmatrix=E->ien[el].node;
Advection_diffusion.c:570:      uc1 +=  E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:571:      uc2 +=  E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:573:    dx1 = 0.5*(E->X[1][ienmatrix[3]]+E->X[1][ienmatrix[4]]
Advection_diffusion.c:574:              -E->X[1][ienmatrix[1]]-E->X[1][ienmatrix[2]]);
Advection_diffusion.c:575:    dx2 = 0.5*(E->X[2][ienmatrix[3]]+E->X[2][ienmatrix[4]]
Advection_diffusion.c:576:              -E->X[2][ienmatrix[1]]-E->X[2][ienmatrix[2]]);
Advection_diffusion.c:577:    uxse = fabs(uc1*dx1*E->eco[el].centre[2]+uc2*dx2); 
Advection_diffusion.c:580:    dx1 = 0.5*(E->X[1][ienmatrix[2]]+E->X[1][ienmatrix[3]]
Advection_diffusion.c:581:              -E->X[1][ienmatrix[1]]-E->X[1][ienmatrix[4]]);
Advection_diffusion.c:582:    dx2 = 0.5*(E->X[2][ienmatrix[2]]+E->X[2][ienmatrix[3]]
Advection_diffusion.c:583:              -E->X[2][ienmatrix[1]]-E->X[2][ienmatrix[4]]);
Advection_diffusion.c:584:    ueta = fabs(uc1*dx1*E->eco[el].centre[2]+uc2*dx2); 
Advection_diffusion.c:596:            u1 += VV[1][j] * E->N.vpt[GNVINDEX(j,i)]; 
Advection_diffusion.c:597:            u2 += VV[2][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:603:             PG->vpt[GNVINDEX(j,i)] = E->N.vpt[GNVINDEX(j,i)] + adiff * prod1;
Advection_diffusion.c:645:    const int dims=E->mesh.nsd;
Advection_diffusion.c:646:    const int dofs=E->mesh.dof;
Advection_diffusion.c:647:    const int nno=E->mesh.nno;
Advection_diffusion.c:648:    const int lev=E->mesh.levmax;
Advection_diffusion.c:660:      node = E->ien[el].node[i];
Advection_diffusion.c:667:      node = E->ien[el].node[j];
Advection_diffusion.c:669:	  if(E->node[node] & (TBX | TBY | TBZ))
Advection_diffusion.c:675:	 	  dT[i] += DT * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:678:		  sfn = E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:690:       Q += E->C[E->ien[i].node[j]]; 
Advection_diffusion.c:692:     Q = Q*E->control.Q0;
Advection_diffusion.c:697:   if (E->eco[el].centre[2] <= E->viscosity.zlm)
Advection_diffusion.c:698:     Q = E->rad_heat.total;
Advection_diffusion.c:703:// Q = E->rad_heat.total;
Advection_diffusion.c:706:   if (E->control.composition)
Advection_diffusion.c:707:	    Q = (1-E->CE[el])*E->rad_heat.total+E->CE[el]*E->control.Q0ER;
Advection_diffusion.c:709:   if(E->control.tidal_heating==0) {
Advection_diffusion.c:710:     Q = (Q + E->heating_visc[el] - E->heating_adi[el])/E->heating_latent[el];
Advection_diffusion.c:714:     Q = (Q + E->heating_visc[el] - E->heating_adi[el] + E->heating_tidal[el]*E->tidal_visc[el])
Advection_diffusion.c:715:	/ E->heating_latent[el];
Advection_diffusion.c:718:   if(E->control.shear_heating)
Advection_diffusion.c:719:		Q += E->heating_shear[el] / E->heating_latent[el];
Advection_diffusion.c:721:   if(E->control.despin && !(E->control.despun))
Advection_diffusion.c:722:		Q += E->heating_despin[el]*E->tidal_visc[el] / E->heating_latent[el];
Advection_diffusion.c:733:                     diff/E->heating_latent[el]*dOmega.vpt[i] 
Advection_diffusion.c:756:	    if (FLAGS[E->ien[el].node[a]] & FBZ) {
Advection_diffusion.c:764:		for(aid=0,j=1;j<=onedvpoints[E->mesh.nsd];j++)
Advection_diffusion.c:777:			    E->M.vpt[GMVINDEX(aid,j)] * g_1d[j].weight[dims-1] *
Advection_diffusion.c:778:			    BC[2][E->ien[el].node[a]] * E->M.vpt[GMVINDEX(k,j)];
Advection_diffusion.c:805:    const int dims=E->mesh.nsd;
Advection_diffusion.c:806:    const int dofs=E->mesh.dof;
Advection_diffusion.c:807:    const int nno=E->mesh.nno;
Advection_diffusion.c:808:    const int lev=E->mesh.levmax;
Advection_diffusion.c:811:	nel=E->mesh.nel;
Advection_diffusion.c:813:    if(E->advection.fixed_timestep != 0.0) {
Advection_diffusion.c:814:      E->advection.timestep = E->advection.fixed_timestep;
Advection_diffusion.c:821:	      ts = E->eco[el].size[1]*E->eco[el].size[1]*E->eco[el].centre[2]*E->eco[el].centre[2];
Advection_diffusion.c:823:	      ts = E->eco[el].size[2]*E->eco[el].size[2];
Advection_diffusion.c:835:      node = E->ien[el].node[i];
Advection_diffusion.c:836:        VV[1][i] = E->V[1][node];
Advection_diffusion.c:837:        VV[2][i] = E->V[2][node];
Advection_diffusion.c:838:        if(dims==3) VV[3][i] = E->V[3][node];
Advection_diffusion.c:844:        uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:845:        uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:846:        uc3 += E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:848:      uc = fabs(uc1)/E->eco[el].size[1] + fabs(uc2)/E->eco[el].size[2] + fabs(uc3)/E->eco[el].size[3];
Advection_diffusion.c:855:        uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:856:        uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:858:      uc = fabs(uc1)/(E->eco[el].size[1]*E->eco[el].centre[2]) + fabs(uc2)/E->eco[el].size[2];
Advection_diffusion.c:865:    adv_timestep = E->advection.dt_reduced * adv_timestep;         
Advection_diffusion.c:867:    adv_timestep =  1.0e-32+min(E->advection.fine_tune_dt*adv_timestep,diff_timestep);
Advection_diffusion.c:869:    E->advection.timestep = adv_timestep;
Advection_diffusion.c:890:    const int dims = E->mesh.nsd;
Advection_diffusion.c:892:    const int lev = E->mesh.levmax;
Advection_diffusion.c:893:    const int nno = E->mesh.nno;
Advection_diffusion.c:900:  viscr = (double *) malloc((E->mesh.nel+1)*sizeof(double));
Advection_diffusion.c:903:    para1 = E->sphere.ro_dim*E->sphere.ro_dim/(E->data.density*E->data.Cp*E->data.ref_temperature*E->data.therm_diff);
Advection_diffusion.c:904://    E->data.disptn_number = E->data.therm_exp*E->data.grav_acc*E->sphere.ro_dim/E->data.Cp;
Advection_diffusion.c:908:  return_horiz_ave(E,E->T,E->Have.T);
Advection_diffusion.c:910:  if (E->rad_heat.num==0)  {
Advection_diffusion.c:911:     E->rad_heat.total = E->control.Q0; 
Advection_diffusion.c:913:  else if (E->rad_heat.num==1)  {
Advection_diffusion.c:914:     E->rad_heat.total = para1*E->control.Q0; 
Advection_diffusion.c:916:  else if (E->rad_heat.num==2) {
Advection_diffusion.c:917:     temp1 = 4.6e9-E->monitor.time_scale*E->monitor.elapsed_time;
Advection_diffusion.c:918:     temp2 = E->rad_heat.percent[0]*E->rad_heat.concen[0]*E->rad_heat.heat_g[0]
Advection_diffusion.c:919:	         *exp(temp1*log(two)/E->rad_heat.decay_t[0])
Advection_diffusion.c:920:           + E->rad_heat.percent[1]*E->rad_heat.concen[1]*E->rad_heat.heat_g[1]
Advection_diffusion.c:921:	         *exp(temp1*log(two)/E->rad_heat.decay_t[1])
Advection_diffusion.c:922:           + E->rad_heat.percent[2]*E->rad_heat.concen[2]*E->rad_heat.heat_g[2]
Advection_diffusion.c:923:	         *exp(temp1*log(two)/E->rad_heat.decay_t[2])
Advection_diffusion.c:924:           + E->rad_heat.percent[3]*E->rad_heat.concen[3]*E->rad_heat.heat_g[3]
Advection_diffusion.c:925:	         *exp(temp1*log(two)/E->rad_heat.decay_t[3]);
Advection_diffusion.c:926:     E->rad_heat.total = para1*E->data.density*temp2; 
Advection_diffusion.c:929:  temp1 = E->data.disptn_number/E->control.Ra_temp;
Advection_diffusion.c:931:  for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:932:    E->heating_latent[e] = 1.0;
Advection_diffusion.c:935: if (E->control.visc_heating)  {
Advection_diffusion.c:936:   strain_rate_2_inv(E,E->heating_visc,0);
Advection_diffusion.c:938:   for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:941:       temp2 += E->EVi[(e-1)*vpts+i];
Advection_diffusion.c:944:     E->heating_visc[e] = temp1*temp2*E->heating_visc[e];
Advection_diffusion.c:948: if (E->control.adi_heating)  {
Advection_diffusion.c:949:   for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:950:    ee = (e-1)%E->mesh.elz+1;
Advection_diffusion.c:954:      j = E->ien[e].node[i];
Advection_diffusion.c:955:      temp2 = temp2 + E->V[2][j]*(E->T[j]+E->data.surf_temp )*E->data.disptn_number;  
Advection_diffusion.c:958:    E->heating_adi[e] = temp2*(E->expansivity[ee]+E->expansivity[ee+1])*0.5;
Advection_diffusion.c:975:  if (E->control.tidal_heating || E->control.despin) {
Advection_diffusion.c:977:    for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:978:      ee = (e-1)%E->mesh.elz+1;
Advection_diffusion.c:979://      relem = 0.5*(E->X[2][ee] + E->X[2][ee+1]);
Advection_diffusion.c:980:      relem = E->eco[e].centre[2];
Advection_diffusion.c:986:      viscr[ee] = exp( 0.5*( log(E->Have.Vi[ee]) + log(E->Have.Vi[ee+1]) ) );
Advection_diffusion.c:988:      E->tidal_visc[e] = 1.0;
Advection_diffusion.c:989:      temp3 = E->data.frequency * E->data.ref_viscosity / E->data.rigidity;
Advection_diffusion.c:994:        temp2 += E->EVi[(e-1)*vpts+i];
Advection_diffusion.c:999:      if (relem > E->viscosity.zlith) /* Modify for lithosphere */
Advection_diffusion.c:1000:	temp1 = E->viscosity.max_value;
Advection_diffusion.c:1004:        E->tidal_visc[e] = 1.0; /* Use this only if convection is weak */
Advection_diffusion.c:1005:      E->tidal_visc[e] = temp2 * (1 + temp3*temp3) / (1 + temp2*temp2*temp3*temp3);
Advection_diffusion.c:1007:/*      E->tidal_visc[e] = (temp2/temp1) * (1 + temp1*temp1*temp3*temp3) 
Advection_diffusion.c:1011://      fprintf(stderr,"tidal visc: %d %g %g %g %g\n",e,E->data.frequency,E->data.ref_viscosity,E->data.rigidity,E->tidal_visc[e]);
Advection_diffusion.c:1012://      fprintf(stderr,"tidal visc: %d %d %g %g %g\n",e,ee,temp2,temp3,E->tidal_visc[e]);
Advection_diffusion.c:1017:  if(E->control.despin && !(E->control.despun))
Advection_diffusion.c:1021:  if (E->control.Ra_670!=0.0)   {
Advection_diffusion.c:1022:    temp1 = 2.0*E->control.clapeyron670*E->control.Ra_670/(E->control.Ra_temp/E->control.width670);
Advection_diffusion.c:1023:    for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:1027:        j = E->ien[e].node[i];
Advection_diffusion.c:1028:        temp2 = temp2 + temp1*(1.0-E->Fas670[j])*E->Fas670[j]
Advection_diffusion.c:1029:                   *E->V[2][j]*(E->T[j]+E->data.surf_temp)*E->data.disptn_number;
Advection_diffusion.c:1030:        temp3 = temp3 + temp1*E->control.clapeyron670
Advection_diffusion.c:1031:                        *(1.0-E->Fas670[j])*E->Fas670[j]
Advection_diffusion.c:1032:                        *(E->T[j]+E->data.surf_temp)*E->data.disptn_number;
Advection_diffusion.c:1036:      E->heating_adi[e] += temp2;
Advection_diffusion.c:1037:      E->heating_latent[e] += temp3;
Advection_diffusion.c:1041:  if (E->control.Ra_410!=0.0)   {
Advection_diffusion.c:1042:    temp1 = 2.0*E->control.clapeyron410*E->control.Ra_410/(E->control.Ra_temp/E->control.width410);
Advection_diffusion.c:1043:    for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:1047:        j = E->ien[e].node[i];
Advection_diffusion.c:1048:        temp2 = temp2 + temp1*(1.0-E->Fas410[j])*E->Fas410[j]
Advection_diffusion.c:1049:                   *E->V[2][j]*(E->T[j]+E->data.surf_temp)*E->data.disptn_number;
Advection_diffusion.c:1050:        temp3 = temp3 + temp1*E->control.clapeyron410
Advection_diffusion.c:1051:                       *(1.0-E->Fas410[j])*E->Fas410[j]
Advection_diffusion.c:1052:                       *(E->T[j]+E->data.surf_temp)*E->data.disptn_number;
Advection_diffusion.c:1056:      E->heating_adi[e] += temp2;
Advection_diffusion.c:1057:      E->heating_latent[e] += temp3;
Advection_diffusion.c:1061:  fprintf(E->fp,"QQ %g %g %g\n",E->rad_heat.total,E->data.crust_rad*E->rad_heat.total,E->data.mantle_rad*E->rad_heat.total);
Advection_diffusion.c:1063:if((E->monitor.solution_cycles%E->control.record_every)==0)  {
Advection_diffusion.c:1064:  sprintf(filename,"%s/heating.%d",E->control.data_file,E->monitor.solution_cycles);  
Advection_diffusion.c:1066:  fprintf(fp,"QQ %g %g %g\n",E->control.Ra_temp,E->data.disptn_number,E->rad_heat.total);
Advection_diffusion.c:1067:  for (e=1;e<=E->mesh.nel;e++){
Advection_diffusion.c:1068:    ee = (e-1)%E->mesh.elz+1;
Advection_diffusion.c:1069:    fprintf(fp,"%d %g %g %g %g %g %g %d %g\n",e,E->EVi[(e-1)*vpts+1],viscr[ee],E->heating_visc[e],E->heating_adi[e],E->heating_tidal[e]*E->tidal_visc[e],E->tidal_visc[e],(E->eco[e].centre[2] <= E->viscosity.zlith),E->heating_tidal[e]);
Advection_diffusion.c:1070:/*    fprintf(fp,"%d %g %g %g %g %g %g\n",e,E->EVi[(e-1)*vpts+1],
Advection_diffusion.c:1071:			E->heating_visc[e],E->heating_adi[e],
Advection_diffusion.c:1072:			(E->heating_tidal[e]*E->tidal_visc[e]),
Advection_diffusion.c:1073:			(E->heating_despin[e]*E->tidal_visc[e]),E->tidal_visc[e]);*/
Advection_diffusion.c:1130:  log_c_Ri = (complex double *) malloc((E->mesh.nno+1)*sizeof(complex double));
Advection_diffusion.c:1131:  work = (double *) malloc((E->mesh.nel+1)*sizeof(double));
Advection_diffusion.c:1141:	density_ratio = E->data.density / E->data.density_core;
Advection_diffusion.c:1145:	omega = E->data.rotation;
Advection_diffusion.c:1146:	mu = E->data.rigidity;
Advection_diffusion.c:1147:  for (n=1;n<=E->mesh.nno;n++)  {	/* By Node */
Advection_diffusion.c:1148:		eta = E->Vi[n]*E->data.ref_viscosity;
Advection_diffusion.c:1151:		E->c_Ri[n] = c_rigidity;
Advection_diffusion.c:1153:  for (e=1;e<=E->mesh.nel;e++)  {	/* By Element */
Advection_diffusion.c:1154:		eta = E->EVi[e]*E->data.ref_viscosity;
Advection_diffusion.c:1157:		E->c_ERi[e] = c_rigidity;
Advection_diffusion.c:1162:  for (n=1;n<=E->mesh.nno;n++){
Advection_diffusion.c:1163:    log_c_Ri[n] = clog(E->c_Ri[n]);
Advection_diffusion.c:1170:  return_horiz_ave(E,log_r_Ri,E->Have.r_Ri);
Advection_diffusion.c:1171:  return_horiz_ave(E,log_i_Ri,E->Have.i_Ri);
Advection_diffusion.c:1172:  for (k=1;k<=E->mesh.noz;k++) {
Advection_diffusion.c:1173:		E->Have.r_Ri[k] = exp(E->Have.r_Ri[k]);
Advection_diffusion.c:1174:		E->Have.i_Ri[k] = exp(E->Have.i_Ri[k]);
Advection_diffusion.c:1180:/*	(void)fprintf(E->fp,"n %d, volume %g\n",n,volume);*/
Advection_diffusion.c:1182:	for (n=1;n<=E->mesh.nno;n++) {
Advection_diffusion.c:1183:		ave_c_Ri += log_c_Ri[n] / E->Mass[n]; /* Really Ri * dVol. */
Advection_diffusion.c:1184:		volume += 1.0/E->Mass[n];
Advection_diffusion.c:1185:	/*	(void)fprintf(E->fp,"n %d, Mass %g, volume %g, log_c_Ri %g + %g i, ave_c_Ri %g + %gi\n",
Advection_diffusion.c:1186:				n,E->Mass[n],volume,creal(log_c_Ri[n]),cimag(log_c_Ri[n]),
Advection_diffusion.c:1193:											/ (2*E->data.grav_acc*E->data.density*E->sphere.ro_dim));
Advection_diffusion.c:1194:  drotdt = (3.0 * -cimag(c_k2) * E->data.grav_const * E->data.mass_primary 
Advection_diffusion.c:1195:							* E->data.mass_primary * pow((E->sphere.ro_dim),5)) 
Advection_diffusion.c:1196:							/ (E->data.moi * pow(E->data.semimajor_axis,6));
Advection_diffusion.c:1198:	(void)fprintf(E->fp,"ave_c_Ri %g + %g i\n rig %g + %g i, k2 %g + %g i\n drotdt %g\n",	
Advection_diffusion.c:1204:	rot_prev = E->data.rotation;
Advection_diffusion.c:1205:	dt = E->advection.timestep 
Advection_diffusion.c:1206:				* (E->sphere.ro_dim * E->sphere.ro_dim / E->data.therm_diff);
Advection_diffusion.c:1207:	rot = rot_prev - E->data.despin_rate * dt;
Advection_diffusion.c:1209:  if(rot <= E->data.rot_final) {
Advection_diffusion.c:1210:		rot = E->data.rot_final;
Advection_diffusion.c:1211:		E->control.despun = 1;
Advection_diffusion.c:1212:		E->control.despin_timescale = E->monitor.elapsed_time
Advection_diffusion.c:1213:									* (E->sphere.ro_dim * E->sphere.ro_dim / E->data.therm_diff);
Advection_diffusion.c:1216:	E->data.rotation = rot;
Advection_diffusion.c:1218:	(void)fprintf(E->fp,"rot_prev %.15e -> rot %.15e, drot = %.9e, despin =%e, dt=%e -> %.10e\n",
Advection_diffusion.c:1219:			rot_prev,rot,rot-rot_prev,E->data.despin_rate,E->advection.timestep,dt);
Advection_diffusion.c:1229:	semimajor_prev = E->data.semimajor_axis;
Advection_diffusion.c:1231:	Ls1 = E->data.moi*rot_prev;
Advection_diffusion.c:1232:  Ls2 = E->data.moi*rot;
Advection_diffusion.c:1233:	Lo1 = E->data.mass*E->data.mean_motion*semimajor_prev*semimajor_prev;
Advection_diffusion.c:1239:	fprintf(stderr,"Mass %g rot_prev %g a_prev %Lg\n",E->data.mass,rot_prev,semimajor_prev);
Advection_diffusion.c:1241:	if(E->advection.timestep == 0.0)
Advection_diffusion.c:1244:	  semimajor = powl((Lo2/E->data.mass),2) 
Advection_diffusion.c:1245:		 											/ (E->data.grav_const * E->data.mass_primary);
Advection_diffusion.c:1247:	E->data.semimajor_axis = semimajor;
Advection_diffusion.c:1248:  E->data.mean_motion = sqrt((E->data.grav_const * E->data.mass_primary) / 
Advection_diffusion.c:1255: 	mean_motion = sqrt((E->data.grav_const * E->data.mass_primary) / 
Advection_diffusion.c:1259:	Es1 =  E->data.moi*rot_prev*rot_prev / 2.0;
Advection_diffusion.c:1260:	Es2 =  E->data.moi*rot*rot / 2.0;
Advection_diffusion.c:1261:	Eo1 = - E->data.grav_const*E->data.mass_primary*E->data.mass 
Advection_diffusion.c:1263:	Eo2 = - E->data.grav_const*E->data.mass_primary*E->data.mass 
Advection_diffusion.c:1268:	Ediss = ( E->data.moi*(rot_prev*rot_prev - rot*rot) 
Advection_diffusion.c:1269:			  				- E->data.grav_const*E->data.mass_primary*E->data.mass 
Advection_diffusion.c:1272:	E->data.Ediss += Ediss;  /* Keep track of dissipated energy */	
Advection_diffusion.c:1273:  fprintf(stderr,"Ediss = %g, Total = %g, dt=%e\n",Ediss,E->data.Ediss,dt);
Advection_diffusion.c:1274:  fprintf(E->fp,"Ediss = %g, Total = %g, dt=%e\n",Ediss,E->data.Ediss,dt);
Advection_diffusion.c:1277:  m1 = (rot_prev*rot_prev*E->sphere.ro_dim / E->data.grav_acc);
Advection_diffusion.c:1278:  m2 = (rot*rot*E->sphere.ro_dim / E->data.grav_acc);
Advection_diffusion.c:1279:  f1 = E->data.flattening;
Advection_diffusion.c:1280:  f2 = f1 - (1.25*(m1-m2)) / (1.0 + (19.0*E->data.rigidity) 
Advection_diffusion.c:1281:						/(2.0*E->data.grav_acc*E->data.density*E->sphere.ro_dim));
Advection_diffusion.c:1282:  fprintf(E->fp,"m = %g -> %g\n",m1,m2);
Advection_diffusion.c:1285:	kappa_grav = (4.0*M_PI/3.0) * E->data.grav_const * E->sphere.ro_dim 
Advection_diffusion.c:1286:		* E->sphere.ro_dim * E->data.density * E->data.density / c_rigidity;
Advection_diffusion.c:1288:  fprintf(E->fp,"kappa_grav = %.16g + %.16g\n",
Advection_diffusion.c:1307:		fprintf(E->fp,"n %d beta %g K %g + %g i\n",nn[i],coeff_beta[i],
Advection_diffusion.c:1311:	A1 = (0.1 - (1.0 + (density_ratio - 1.0) * pow(E->sphere.ri,3.0)) / 6.0) 
Advection_diffusion.c:1316:	A2 = 0.1 * (1.0 - density_ratio) * pow(E->sphere.ri,2.0) * kappa_grav;
Advection_diffusion.c:1321:	fprintf(E->fp,"A1 %g + %g i A2 %g + %g i\n",
Advection_diffusion.c:1323:	fprintf(E->fp,"B1 %g + %g i B2 %g + %g i\n",
Advection_diffusion.c:1325:	fprintf(E->fp,"D1 %g + %g i D2 %g + %g i\n",
Advection_diffusion.c:1327:	fprintf(E->fp,"E1 %g + %g i E2 %g + %g i\n",
Advection_diffusion.c:1330:	M_mat[1][1] = -2.0 + 6.0*(A1 + B1*pow(E->sphere.ri,5.0));
Advection_diffusion.c:1331:	M_mat[1][2] = 1.0 + 6.0*(A1 + B1*pow(E->sphere.ri,7.0));
Advection_diffusion.c:1332:	M_mat[1][3] = 6.0 + 6.0*(A1 + B1*pow(E->sphere.ri,2.0));
Advection_diffusion.c:1335:	M_mat[2][1] = -2.0 + 6.0*(A2 + B2*pow(E->sphere.ri,2.0));
Advection_diffusion.c:1336:	M_mat[2][2] = pow(E->sphere.ri,2.0) + 6.0*(A2 + B2*pow(E->sphere.ri,4.0));
Advection_diffusion.c:1337:	M_mat[2][3] = 6.0*pow(E->sphere.ri,-3.0) + 6.0*(A2 + B2/E->sphere.ri);
Advection_diffusion.c:1338:  M_mat[2][4] = 8.0*pow(E->sphere.ri,-5.0) 
Advection_diffusion.c:1339:									+ 6.0*(A2 + B2*pow(E->sphere.ri,-3.0));
Advection_diffusion.c:1341:	M_mat[3][1] = 6.0 + 6.0*(D1 + E1*pow(E->sphere.ri,5.0));
Advection_diffusion.c:1342:	M_mat[3][2] = 16.0 + 6.0*(D1 + E1*pow(E->sphere.ri,7.0));
Advection_diffusion.c:1343:	M_mat[3][3] = 6.0 + 6.0*(D1 + E1*pow(E->sphere.ri,2.0));
Advection_diffusion.c:1346:	M_mat[4][1] = 6.0 + 6.0*(D2 + E2*pow(E->sphere.ri,2.0));
Advection_diffusion.c:1347:	M_mat[4][2] = 16.0*pow(E->sphere.ri,2.0) 
Advection_diffusion.c:1348:									+ 6.0*(D2 + E2*pow(E->sphere.ri,4.0));
Advection_diffusion.c:1349:	M_mat[4][3] = 6.0*pow(E->sphere.ri,-3.0) + 6.0*(D2 + E2/E->sphere.ri);
Advection_diffusion.c:1350:  M_mat[4][4] = 16.0*pow(E->sphere.ri,-5.0) 
Advection_diffusion.c:1351:									+ 6.0*(D2 + E2*pow(E->sphere.ri,-3.0));
Advection_diffusion.c:1355:			fprintf(E->fp,"M %g + %g i\n",creal(M_mat[i][j]),cimag(M_mat[i][j]));
Advection_diffusion.c:1359:	/*weight[2] = -((E->data.density*E->data.grav_acc)
Advection_diffusion.c:1360:				/(95.0 * c_rigidity * E->sphere.ro_dim)) * (f2 - 1.25*m2);
Advection_diffusion.c:1361:  weight[1] = -(8.0/3.0) * weight[2] * pow(E->sphere.ro_dim,2);
Advection_diffusion.c:1363:  fprintf(E->fp,"weight = %g + %g i, %g + %g i\n",
Advection_diffusion.c:1389:	fprintf(E->fp,"M =\n");
Advection_diffusion.c:1392:			fprintf(E->fp,"%g+%gi \t",creal(M_inv[i][j]),cimag(M_inv[i][j]));
Advection_diffusion.c:1394:		fprintf(E->fp,"%g+%gi\n",creal(weight[i]),cimag(weight[i]));
Advection_diffusion.c:1399:	fprintf(E->fp,"inv(M) =\n");
Advection_diffusion.c:1402:			fprintf(E->fp,"%g+%gi \t",creal(M_inv[i][j]),cimag(M_inv[i][j]));
Advection_diffusion.c:1404:		fprintf(E->fp,"%g+%gi\n",creal(weight[i]),cimag(weight[i]));
Advection_diffusion.c:1412:		weight[i] *= pow(E->sphere.ro_dim,(1-nn[i]));	
Advection_diffusion.c:1413:	/*	fprintf(E->fp,"%g+%gi\n",creal(weight[i]),cimag(weight[i]));*/
Advection_diffusion.c:1415:  fprintf(E->fp,"f = %g+%gi -> %g+%gi, df = %g+%gi\n",creal(f1),cimag(f1),
Advection_diffusion.c:1420:  sprintf(output_file,"%s/despin.%d",E->control.data_file,
Advection_diffusion.c:1421:			E->monitor.solution_cycles);
Advection_diffusion.c:1426:  for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:1428:		/* E->heating_despin[e] = E->power_despin_ave; */ /* Average Value */
Advection_diffusion.c:1431:    relem = E->eco[e].centre[2]*E->sphere.ro_dim;
Advection_diffusion.c:1432:		thelem =  E->eco[e].centre[1];
Advection_diffusion.c:1460:		if((E->eco[e].centre[1] == 0.0) || (E->eco[e].centre[1] == M_PI))
Advection_diffusion.c:1529:		global_diss += 2.0*M_PI*work[e]*E->eco[e].area*pow(E->sphere.ro_dim,3)
Advection_diffusion.c:1530:											*E->tidal_visc[e];
Advection_diffusion.c:1531:		e_volume += 2.0*M_PI*E->eco[e].area;
Advection_diffusion.c:1534:		if(E->advection.timestep > 0.0)
Advection_diffusion.c:1550:		work[e] *= E->sphere.ro_dim*E->sphere.ro_dim
Advection_diffusion.c:1551:						    /(E->data.density*E->data.Cp*E->data.DeltaT*E->data.therm_diff);
Advection_diffusion.c:1560:  for (e=1;e<=E->mesh.nel;e++)  {
Advection_diffusion.c:1561:    if ((E->control.despun == 0)  && (global_diss != 0.0))
Advection_diffusion.c:1562:			E->heating_despin[e] = work[e] * (Ediss/global_diss);
Advection_diffusion.c:1564:			E->heating_despin[e] = 0.0;
Advection_diffusion.c:1565:/*		fprintf(E->fp,"e %d work %g heating %g\n",e,work[e],E->heating_despin[e]);*/
Advection_diffusion.c:1566:	/*	E->heating_despin[e] = 0.0;*/
Advection_diffusion.c:1569:  global_diss *= 1.0/(E->data.density*E->data.Cp*E->data.DeltaT
Advection_diffusion.c:1570:																			*E->data.therm_diff*E->sphere.ro_dim);
Advection_diffusion.c:1652:  E->impacts.now = i;
Advection_diffusion.c:1657:  /*D_at = 0.87 * pow(simp_comp,0.115) *  pow(E->impacts.size[i]*1.0e3,0.885);*/ /* McKinnon & Schenk, 1985 */
Advection_diffusion.c:1658:  D_at = 0.98 * pow(simp_comp,0.079) *  pow(E->impacts.size[i]*1.0e3,0.92); /* Holsapple, 1993 */
Advection_diffusion.c:1665:  D_imp = 0.69 * pow(D_at,1.27) * pow(E->data.grav_acc,0.28) 
Advection_diffusion.c:1666:                * pow(E->impacts.v,-0.56);
Advection_diffusion.c:1669:  r_ic = 0.5*D_imp * pow(10.0,a1) * pow(1.0e-3*E->impacts.v,b1);
Advection_diffusion.c:1670:  depth = 0.5*D_imp * pow(10.0,a2) * pow(1.0e-3*E->impacts.v,b2);
Advection_diffusion.c:1673:  depth *= 1.0/(E->sphere.ro_dim);
Advection_diffusion.c:1674:  r_ic *= 1.0/(E->sphere.ro_dim);
Advection_diffusion.c:1675:  r_m *= 1.0/(E->sphere.ro_dim);
Advection_diffusion.c:1687:  V_m = 0.14 * E->impacts.v*E->impacts.v / latent;
Advection_diffusion.c:1692:  KE = 0.5*E->data.density*V_imp*E->impacts.v*E->impacts.v;
Advection_diffusion.c:1694:  KE -= latent*V_m*E->data.density;
Advection_diffusion.c:1696:  sprintf(output_file,"%s/impact.%d",E->control.data_file,i);
Advection_diffusion.c:1704:	/*xi = (1.0-depth)*sin(E->impacts.th[i])*cos(E->impacts.f[i]);
Advection_diffusion.c:1705:  yi = (1.0-depth)*sin(E->impacts.th[i])*sin(E->impacts.f[i]);*/
Advection_diffusion.c:1709:  xi = (1.0-depth)*sin(E->impacts.th[i]);
Advection_diffusion.c:1711:  zi = (1.0-depth)*cos(E->impacts.th[i]);
Advection_diffusion.c:1714:  (void)fprintf(fp1,"%f %f %f %f %f %f %e %e\n",E->impacts.th[i],depth,xi,zi,
Advection_diffusion.c:1715:			E->impacts.size[i],r_ic,D_at,H_at);
Advection_diffusion.c:1718:  if(E->impacts.heat_from_file)
Advection_diffusion.c:1731:    mvelo = a + b*log10(1.0e-3*E->impacts.v);     /* Velocity decay exponent */
Advection_diffusion.c:1735:    beta = 0.5*C*C*E->data.density / S;
Advection_diffusion.c:1736:    uc = 0.5*E->impacts.v;
Advection_diffusion.c:1737:    nP = -1.84 + 2.61*log10(1.0e-3*E->impacts.v);
Advection_diffusion.c:1742:	  for(n=1;n<=E->mesh.nno;n++) {
Advection_diffusion.c:1744:      /*xn = E->X[2][n]*sin(E->X[1][n])*cos(E->X[3][n]);
Advection_diffusion.c:1745:        yn = E->X[2][n]*sin(E->X[1][n])*sin(E->X[3][n]);*/
Advection_diffusion.c:1746:		  xn = E->X[2][n]*sin(E->X[1][n]);
Advection_diffusion.c:1747:      zn = E->X[2][n]*cos(E->X[1][n]);
Advection_diffusion.c:1752:      i = ((n-1) / E->mesh.noz) + 1;
Advection_diffusion.c:1753:      k = ((n-1) % E->mesh.noz) + 1;
Advection_diffusion.c:1755:      P_lith = E->data.density * E->data.grav_acc * (1.0-E->X[2][n]) 
Advection_diffusion.c:1756:              * E->sphere.ro_dim; /* lithostatic pressure */
Advection_diffusion.c:1759:		  if(k == E->mesh.noz){
Advection_diffusion.c:1760:			  rtheta = E->sphere.ro_dim * E->X[1][n]; /* dist. from impact */
Advection_diffusion.c:1763:				  E->impacts.H_t[i] = crater_sph_rad*(1.0 - cos(slope_at - slope_atc));
Advection_diffusion.c:1766:				  E->impacts.H_t[i] = 0.0;
Advection_diffusion.c:1769:			  fprintf(E->fpdebug,"i %d sl %f Ht %f\n",i,slope_at,E->impacts.H_t[i]);
Advection_diffusion.c:1779:      P_delta = E->data.density * (C + S*uc) * uc * rcr;
Advection_diffusion.c:1780:      /* P_delta = E->data.density * (C + S*uc*rcr) * uc*rcr; */
Advection_diffusion.c:1785:      dT = ( (P_delta/(2.0*E->data.density*S)) * (1 - 1.0/fP)
Advection_diffusion.c:1787:							               / (E->data.Cp * E->data.ref_temperature);
Advection_diffusion.c:1792:	  if (E->control.melting) {
Advection_diffusion.c:1794:			E->Fm[n] = F; */
Advection_diffusion.c:1795:			(void)fprintf(fp1,"%f %f %f %f %e %e %.3f %.3f\n",E->X[1][n],
Advection_diffusion.c:1796:											E->X[2][n],delta,rcr,P_delta,dT,F,E->C[n]);
Advection_diffusion.c:1798:      E->T[n] += dT;  /* We'll reduce this in a bit due to latent heat */
Advection_diffusion.c:1805://		(void)fprintf(stderr,"ifs %d %f\n",k,(E->T[n] + dT));
Advection_diffusion.c:1806:			if((E->T[n] + dT) > E->solidus[k]) {
Advection_diffusion.c:1807:				dT1 = max((E->solidus[k] - E->T[n]), 0.0);
Advection_diffusion.c:1811:			E->T[n] += dT1;
Advection_diffusion.c:1812:			(void)fprintf(fp1,"%f %f %f %f %e %e %e %d\n",E->X[1][n],E->X[2][n],
Advection_diffusion.c:1819:	if (E->control.composition && E->control.melting) {
Advection_diffusion.c:1823:		p_to_centres(E,E->T,E->TE,E->mesh.levmax);
Advection_diffusion.c:1826:		for(e=1;e<=E->mesh.nel;e++) {
Advection_diffusion.c:1827:			k = ((e-1) % E->mesh.elz) + 1;
Advection_diffusion.c:1828:			E->FmE[i] = melting(E,0,0,e,k);
Advection_diffusion.c:1832:		for(n=1;n<=E->mesh.nno;n++) {
Advection_diffusion.c:1833:			k = ((n-1) % E->mesh.noz) + 1;
Advection_diffusion.c:1834:			E->Fm[i] = melting_by_node(E,0,0,i,n);
Advection_diffusion.c:1839:		/* p_to_centres(E,E->C,E->CE,E->mesh.levmax);
Advection_diffusion.c:1840:		 *  p_to_centres(E,E->Fm,E->FmE,E->mesh.levmax);
Advection_diffusion.c:1844:		E->Total.bulk_comp = 0.0;
Advection_diffusion.c:1846:		for(j=1;j<=E->mesh.esf;j++) { 
Advection_diffusion.c:1847:			E->slice.impact_melt[j] = 0.0;
Advection_diffusion.c:1849:			for(k=1;k<=E->mesh.elz;k++) {
Advection_diffusion.c:1850:				e = j*E->mesh.elz + k;
Advection_diffusion.c:1851:			//	E->slice.melt[j] += E->FmE[e]*E->eco[e].area/E->Total.vol;
Advection_diffusion.c:1852:			//	E->slice.new_melt[j] += E->FmE[e]*E->eco[e].area/E->Total.vol;
Advection_diffusion.c:1853:				E->slice.impact_melt[j] += E->FmE[e]*E->eco[e].area;
Advection_diffusion.c:1854:				E->Total.bulk_comp += E->CE[e] * E->eco[e].area;
Advection_diffusion.c:1857:			E->slice.impact_melt[j] /= E->Total.vol;
Advection_diffusion.c:1858:			E->slice.melt[j] +=	E->slice.impact_melt[j];
Advection_diffusion.c:1859:			E->slice.new_melt[j] +=	E->slice.impact_melt[j];
Advection_diffusion.c:1862:		E->Total.bulk_comp /= E->Total.vol;
Advection_diffusion.c:1915:  fprintf(stderr,">>> %s\n",E->impacts.heating_file);
Advection_diffusion.c:1916:  sprintf(input_file,"%s/%s",E->control.data_file,E->impacts.heating_file);
Advection_diffusion.c:1926:  dr_in = (E->sphere.ro - E->sphere.ri) / (float)(num_r-1);
Advection_diffusion.c:1937:    r_in[k] = E->sphere.ri + dr_in*(k-1);
Advection_diffusion.c:1952:    fprintf(E->fp,"n %d theta %f r %f dTin %f\n",n,theta_in[j],r_in[k],dT_in[n]);
Advection_diffusion.c:1964:  for(n=1;n<=E->mesh.nno;n++) {
Advection_diffusion.c:1966:      rnode = (n-1) % E->mesh.noz + 1; /* Radial position of each node */
Advection_diffusion.c:1967:      //fprintf(E->fp,"n %d rnode %d\n",n,rnode);
Advection_diffusion.c:1970:      /* For a north polar impact, dist = E->X[1][n]; */
Advection_diffusion.c:1971:      dist = E->X[1][n] - E->impacts.th[i];
Advection_diffusion.c:1990:          fprintf(E->fp_out,"k %d %g %g %g\n",k,r_in[k],E->X[2][n],r_in[k+1]);
Advection_diffusion.c:1991:          fprintf(E->fp_out,"k %d %g\n",k,r_in[k]-E->X[2][n]);
Advection_diffusion.c:1993:        if((r_in[k] <= E->X[2][n]) && (r_in[k+1] >= E->X[2][n])) {
Advection_diffusion.c:2010:      A_ll = (theta_in[left] - dist) * (r_in[lower] - E->X[2][n]);
Advection_diffusion.c:2011:      A_ul = (theta_in[left] - dist) * -(r_in[upper] - E->X[2][n]);
Advection_diffusion.c:2012:      A_lr = -(theta_in[right] - dist) * (r_in[lower] - E->X[2][n]);
Advection_diffusion.c:2013:      A_ur = -(theta_in[right] - dist) * -(r_in[upper] - E->X[2][n]);
Advection_diffusion.c:2022:      dT /= E->data.ref_temperature;  /* Nondimensionalize */
Advection_diffusion.c:2024:      if (E->control.melting) {
Advection_diffusion.c:2025:         (void)fprintf(fp1,"%f %f %e %.3f %.3f\n",E->X[1][n],E->X[2][n],dist,
Advection_diffusion.c:2026:                        dT,E->C[n]);
Advection_diffusion.c:2027:         E->T[n] += dT;  /* We'll reduce this in a bit due to latent heat */
Advection_diffusion.c:2034:        if((E->T[n] + dT) > E->solidus[rnode]) {
Advection_diffusion.c:2035:          dT1 = max((E->solidus[rnode] - E->T[n]), 0.0);
Advection_diffusion.c:2037:        (void)fprintf(stderr,"ifs %d %f %f\n",rnode,(E->T[n] + dT),E->solidus[rnode]);
Advection_diffusion.c:2040:        E->T[n] += dT1;
Advection_diffusion.c:2041:        (void)fprintf(fp1,"%f %f %f %e %e %d\n",E->X[1][n],E->X[2][n],dist,dT,
Advection_diffusion.c:2072://	p_to_centres(E,E->C,E->CE_temp,E->mesh.levmax);
Advection_diffusion.c:2076:	for(e=1;e<=E->mesh.nel;e++){
Advection_diffusion.c:2077:		//comp += E->CE_temp[e] * E->eco[e].area;
Advection_diffusion.c:2078:		comp += E->CE[e] * E->eco[e].area;
Advection_diffusion.c:2079:		if (E->advection.timesteps <= 25  && e == 9216) {
Advection_diffusion.c:2080:			fprintf(E->fpdebug,"e %d %g %g\n",e,E->CE[e],comp);
Advection_diffusion.c:2081:	    fprintf(E->fpdebug,"> Cn = %g %g %g %g\n",
Advection_diffusion.c:2082:              E->C[9407],E->C[9408],E->C[9456],E->C[9457]);
Advection_diffusion.c:2086:	comp /= E->Total.vol;
Advection_diffusion.c:2087:	fprintf(E->fpdebug,"> %d bulk comp = %g %g \n",i,comp,E->Total.bulk_comp);
Advection_diffusion.c:2088://	fprintf(E->fpdebug,"> tracer = %g\n",E->C12f[1806336]);
Boundary_conditions.c:18:  for(lv=E->mesh.levmax;lv>=E->mesh.levmin;lv--)  {
Boundary_conditions.c:19:    if(E->mesh.botvbc != 1) {
Boundary_conditions.c:20:	  horizontal_bc(E,E->VB,1,1,0.0,VBX,0,lv);	 
Boundary_conditions.c:21:	  horizontal_bc(E,E->VB,1,2,0.0,VBZ,1,lv);
Boundary_conditions.c:22:	  horizontal_bc(E,E->VB,1,1,E->control.VBXbotval,SBX,1,lv);	 
Boundary_conditions.c:23:	  horizontal_bc(E,E->VB,1,2,0.0,SBZ,0,lv);
Boundary_conditions.c:24:	  if(E->mesh.nsd==3)     {
Boundary_conditions.c:25:	    horizontal_bc(E,E->VB,1,3,E->control.VBYbotval,SBY,1,lv);	
Boundary_conditions.c:26:	    horizontal_bc(E,E->VB,1,3,0.0,VBY,0,lv);	 
Boundary_conditions.c:29:    if(E->mesh.topvbc != 1) {
Boundary_conditions.c:30:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,0.0,VBX,0,lv);	 
Boundary_conditions.c:31:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,VBZ,1,lv);
Boundary_conditions.c:32:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,E->control.VBXtopval,SBX,1,lv); 
Boundary_conditions.c:33:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,SBZ,0,lv);  
Boundary_conditions.c:34:	  if(E->mesh.nsd==3)     {
Boundary_conditions.c:35:	    horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,E->control.VBYtopval,SBY,1,lv); 
Boundary_conditions.c:36:	    horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,0.0,VBY,0,lv);	 
Boundary_conditions.c:43: if(E->mesh.periodic_x || E->mesh.periodic_y)
Boundary_conditions.c:46: for(lv=E->mesh.levmax;lv>=E->mesh.levmin;lv--) {
Boundary_conditions.c:47:     if(E->mesh.botvbc == 1) {
Boundary_conditions.c:48:	 horizontal_bc(E,E->VB,1,1,E->control.VBXbotval,VBX,1,lv);	 
Boundary_conditions.c:49:	 horizontal_bc(E,E->VB,1,2,0.0,VBZ,1,lv);
Boundary_conditions.c:50:	 horizontal_bc(E,E->VB,1,1,0.0,SBX,0,lv);	 
Boundary_conditions.c:51:	 horizontal_bc(E,E->VB,1,2,0.0,SBZ,0,lv);
Boundary_conditions.c:52:	 if(E->mesh.nsd==3) {
Boundary_conditions.c:53:	     horizontal_bc(E,E->VB,1,3,E->control.VBYbotval,VBY,1,lv);	 
Boundary_conditions.c:54:	     horizontal_bc(E,E->VB,1,3,0.0,SBY,0,lv);	 
Boundary_conditions.c:57:      if(E->mesh.topvbc == 1) {
Boundary_conditions.c:58:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,E->control.VBXtopval,VBX,1,lv);
Boundary_conditions.c:59:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,VBZ,1,lv);
Boundary_conditions.c:60:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],1,0.0,SBX,0,lv);	 
Boundary_conditions.c:61:	  horizontal_bc(E,E->VB,E->mesh.NOZ[lv],2,0.0,SBZ,0,lv); 
Boundary_conditions.c:62:	  if(E->mesh.nsd==3) {
Boundary_conditions.c:63:	      horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,E->control.VBYtopval,VBY,1,lv);
Boundary_conditions.c:64:	      horizontal_bc(E,E->VB,E->mesh.NOZ[lv],3,0.0,SBY,0,lv);	 
Boundary_conditions.c:70:if (E->control.verbose)     {
Boundary_conditions.c:71:  if(E->mesh.nsd==3)
Boundary_conditions.c:72:    for (node=1;node<=E->mesh.nnov;node++)
Boundary_conditions.c:73:      fprintf(E->fp,"VB== %d %g %g %g\n",node,E->VB[1][node],E->VB[2][node],E->VB[3][node]);
Boundary_conditions.c:75:    for (node=1;node<=E->mesh.nnov;node++)
Boundary_conditions.c:76:      fprintf(E->fp,"VB== %d %g %g \n",node,E->VB[1][node],E->VB[2][node]);
Boundary_conditions.c:78:  for(lv=E->mesh.levmax;lv>=E->mesh.levmin;lv--)    {
Boundary_conditions.c:79:    fprintf(E->fp,"VBB level=%d %d\n",lv,E->mesh.NNO[lv]);
Boundary_conditions.c:80:    for (node=1;node<=E->mesh.NNO[lv];node++)
Boundary_conditions.c:81:      fprintf(E->fp,"VB== %d %u %u %u\n",node,E->NODE[lv][node]&VBX,E->NODE[lv][node]&VBZ,E->NODE[lv][node]&VBY);
Boundary_conditions.c:96:  if(E->mesh.botcbc == 1)
Boundary_conditions.c:97:    { horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,CBZ,1,E->mesh.levmax);	
Boundary_conditions.c:98:      horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,HBZ,0,E->mesh.levmax); }
Boundary_conditions.c:100:    { horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,CBZ,0,E->mesh.levmax);	
Boundary_conditions.c:101:      horizontal_bc(E,E->CB,1,2,E->control.CBCbotval,HBZ,1,E->mesh.levmax); }
Boundary_conditions.c:103:  if(E->mesh.topcbc == 1)
Boundary_conditions.c:104:    { horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,CBZ,1,E->mesh.levmax);	
Boundary_conditions.c:105:      horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,HBZ,0,E->mesh.levmax); }
Boundary_conditions.c:107:    { horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,CBZ,0,E->mesh.levmax);	
Boundary_conditions.c:108:      horizontal_bc(E,E->CB,E->mesh.noz,2,E->control.CBCtopval,HBZ,1,E->mesh.levmax); }
Boundary_conditions.c:133:  if(E->mesh.bottbc == 1)
Boundary_conditions.c:134:    { horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,TBZ,1,E->mesh.levmax);	
Boundary_conditions.c:135:      horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,FBZ,0,E->mesh.levmax); }
Boundary_conditions.c:137:    { horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,TBZ,0,E->mesh.levmax);	
Boundary_conditions.c:138:      horizontal_bc(E,E->TB,1,2,E->control.TBCbotval,FBZ,1,E->mesh.levmax); }
Boundary_conditions.c:140:  if(E->mesh.toptbc == 1)
Boundary_conditions.c:141:    { horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,TBZ,1,E->mesh.levmax);	
Boundary_conditions.c:142:      horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,FBZ,0,E->mesh.levmax); 
Boundary_conditions.c:144:      if (E->control.surf_temp_var)
Boundary_conditions.c:145:	variable_surf_temp(E,E->TB);
Boundary_conditions.c:148:    { horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,TBZ,0,E->mesh.levmax);	
Boundary_conditions.c:149:      horizontal_bc(E,E->TB,E->mesh.noz,2,E->control.TBCtopval,FBZ,1,E->mesh.levmax); }
Boundary_conditions.c:155:  if(E->mesh.periodic_x || E->mesh.periodic_y)
Boundary_conditions.c:170:  const int dims=E->mesh.nsd;
Boundary_conditions.c:174:    for(j=1;j<=E->mesh.noy;j++)
Boundary_conditions.c:175:      for(i=1;i<=E->mesh.noz;i++)  {
Boundary_conditions.c:176:        node1 = i + (j-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:177:        node2 = node1 + (E->mesh.nox-1)*E->mesh.noz;
Boundary_conditions.c:179:           E->VB[1][node1] = 0.0;
Boundary_conditions.c:180:           E->VB[1][node2] = 0.0;
Boundary_conditions.c:181:           if((i != 1) && (i != E->mesh.noz)) {
Boundary_conditions.c:182:              E->VB[2][node1] = 0.0;  
Boundary_conditions.c:183:              E->VB[2][node2] = 0.0;
Boundary_conditions.c:189:  if (E->mesh.nsd == 3) {
Boundary_conditions.c:190:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:191:        for(i=1;i<=E->mesh.noz;i++)       {
Boundary_conditions.c:192:          node1 = i + (j-1)*E->mesh.noz;
Boundary_conditions.c:193:          node2 = node1 +  (E->mesh.noy-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:194:          if (E->mesh.nsd==3) {
Boundary_conditions.c:195:              E->VB[3][node2] = 0.0;
Boundary_conditions.c:196:              E->VB[3][node1] = 0.0;
Boundary_conditions.c:199:          if((i != 1) && (i != E->mesh.noz)){
Boundary_conditions.c:200:              E->VB[2][node2] = 0.0;
Boundary_conditions.c:201:              E->VB[2][node1] = 0.0;
Boundary_conditions.c:210:  for(level=E->mesh.levmax;level>=E->mesh.levmin;level--) {
Boundary_conditions.c:211:    noz = E->mesh.NOZ[level] ;
Boundary_conditions.c:212:    noy = E->mesh.NOY[level] ;
Boundary_conditions.c:213:    nox = E->mesh.NOX[level] ;
Boundary_conditions.c:219:            E->NODE[level][node1] = E->NODE[level][node1] | VBX;
Boundary_conditions.c:220:            E->NODE[level][node1] = E->NODE[level][node1] & (~SBX);
Boundary_conditions.c:222:               E->NODE[level][node1] = E->NODE[level][node1] & (~VBY);
Boundary_conditions.c:223:               E->NODE[level][node1] = E->NODE[level][node1] | SBY;
Boundary_conditions.c:224:               E->NODE[level][node1] = E->NODE[level][node1] & (~ VBZ);
Boundary_conditions.c:225:               E->NODE[level][node1] = E->NODE[level][node1] | SBZ;    
Boundary_conditions.c:227:            E->NODE[level][node2] = E->NODE[level][node2] | VBX;
Boundary_conditions.c:228:            E->NODE[level][node2] = E->NODE[level][node2] & (~SBX);
Boundary_conditions.c:230:              E->NODE[level][node2] = E->NODE[level][node2] & (~VBY);
Boundary_conditions.c:231:              E->NODE[level][node2] = E->NODE[level][node2] | SBY;
Boundary_conditions.c:232:              E->NODE[level][node2] = E->NODE[level][node2] & (~ VBZ);
Boundary_conditions.c:233:              E->NODE[level][node2] = E->NODE[level][node2] | SBZ;
Boundary_conditions.c:238:    if (E->mesh.nsd == 3)  {
Boundary_conditions.c:243:            E->NODE[level][node1] = E->NODE[level][node1] | VBY;
Boundary_conditions.c:244:            E->NODE[level][node1] = E->NODE[level][node1] & (~SBY);
Boundary_conditions.c:246:                E->NODE[level][node1] = E->NODE[level][node1] & (~VBZ);
Boundary_conditions.c:247:                E->NODE[level][node1] = E->NODE[level][node1] | SBZ;
Boundary_conditions.c:250:                E->NODE[level][node1] = E->NODE[level][node1] & (~VBX);
Boundary_conditions.c:251:                E->NODE[level][node1] = E->NODE[level][node1] | SBX;
Boundary_conditions.c:258:            E->NODE[level][node2] = E->NODE[level][node2] | VBY;
Boundary_conditions.c:259:            E->NODE[level][node2] = E->NODE[level][node2] & (~SBY);
Boundary_conditions.c:261:                E->NODE[level][node2] = E->NODE[level][node2] & (~VBZ);
Boundary_conditions.c:262:                E->NODE[level][node2] = E->NODE[level][node2] | SBZ;
Boundary_conditions.c:265:                E->NODE[level][node2] = E->NODE[level][node2] & (~VBX);
Boundary_conditions.c:266:                E->NODE[level][node2] = E->NODE[level][node2] | SBX;
Boundary_conditions.c:282:  const int dims=E->mesh.nsd;
Boundary_conditions.c:286:    for(j=1;j<=E->mesh.noy;j++)
Boundary_conditions.c:287:      for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:288:        node1 = i + (j-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:289:	node2 = node1 + (E->mesh.nox-1)*E->mesh.noz;
Boundary_conditions.c:290:          E->node[node1] = E->node[node1] & (~TBX);
Boundary_conditions.c:291:          E->node[node1] = E->node[node1] | FBX;   
Boundary_conditions.c:292:          E->TB[1][node1] = 0.0;
Boundary_conditions.c:293:          E->node[node2] = E->node[node2] & (~TBX);
Boundary_conditions.c:294:          E->node[node2] = E->node[node2] | FBX;
Boundary_conditions.c:295:          E->TB[1][node2] = 0.0;
Boundary_conditions.c:298:  if (E->mesh.nsd == 3)  {  
Boundary_conditions.c:299:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:300:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:301:          node1 = i + (j-1)*E->mesh.noz;
Boundary_conditions.c:302:          E->node[node1] = E->node[node1] & (~TBY);
Boundary_conditions.c:303:	      E->node[node1] = E->node[node1] | FBY;
Boundary_conditions.c:304:	      E->TB[3][node1] = 0.0;
Boundary_conditions.c:306:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:307:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:308:          node2 = i +(j-1)*E->mesh.noz + (E->mesh.noy-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:309:	  E->node[node2] = E->node[node2] & (~TBY);
Boundary_conditions.c:310:	  E->node[node2] = E->node[node2] | FBY;
Boundary_conditions.c:311:	  E->TB[3][node2] = 0.0;
Boundary_conditions.c:325:  const int dims=E->mesh.nsd;
Boundary_conditions.c:329:    for(j=1;j<=E->mesh.noy;j++)
Boundary_conditions.c:330:      for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:331:        node1 = i + (j-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:332:	node2 = node1 + (E->mesh.nox-1)*E->mesh.noz;
Boundary_conditions.c:333:          E->node[node1] = E->node[node1] & (~CBX);
Boundary_conditions.c:334:          E->node[node1] = E->node[node1] | HBX;   
Boundary_conditions.c:335:          E->CB[1][node1] = 0.0;
Boundary_conditions.c:336:          E->node[node2] = E->node[node2] & (~CBX);
Boundary_conditions.c:337:          E->node[node2] = E->node[node2] | HBX;
Boundary_conditions.c:338:          E->CB[1][node2] = 0.0;
Boundary_conditions.c:341:  if (E->mesh.nsd == 3)  {  
Boundary_conditions.c:342:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:343:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:344:          node1 = i + (j-1)*E->mesh.noz;
Boundary_conditions.c:345:          E->node[node1] = E->node[node1] & (~CBY);
Boundary_conditions.c:346:	      E->node[node1] = E->node[node1] | HBY;
Boundary_conditions.c:347:	      E->CB[3][node1] = 0.0;
Boundary_conditions.c:349:      for(j=1;j<=E->mesh.nox;j++)
Boundary_conditions.c:350:        for(i=1;i<=E->mesh.noz;i++) {
Boundary_conditions.c:351:          node2 = i +(j-1)*E->mesh.noz + (E->mesh.noy-1)*E->mesh.noz*E->mesh.nox;
Boundary_conditions.c:352:	  E->node[node2] = E->node[node2] & (~CBY);
Boundary_conditions.c:353:	  E->node[node2] = E->node[node2] | HBY;
Boundary_conditions.c:354:	  E->CB[3][node2] = 0.0;
Boundary_conditions.c:378:  const int dims=E->mesh.nsd;
Boundary_conditions.c:381:  if(dirn > E->mesh.nsd) 
Boundary_conditions.c:387:      rowl = E->mesh.NOZ[level];
Boundary_conditions.c:390:       ROW==E->mesh.NOZ[level] ) {
Boundary_conditions.c:394:      for(j=1;j<=E->mesh.NOY[level];j++)
Boundary_conditions.c:395:    	for(i=1;i<=E->mesh.NOX[level];i++)     {
Boundary_conditions.c:396:    	  node = rowl+(i-1)*E->mesh.NOZ[level]+(j-1)*E->mesh.NOX[level]*E->mesh.NOZ[level];
Boundary_conditions.c:397:    	  E->NODE[level][node] = E->NODE[level][node] & (~ mask);
Boundary_conditions.c:403:      for(j=1;j<=E->mesh.NOY[level];j++)
Boundary_conditions.c:404:        for(i=1;i<=E->mesh.NOX[level];i++)       {
Boundary_conditions.c:405:    	  node = rowl+(i-1)*E->mesh.NOZ[level]+(j-1)*E->mesh.NOX[level]*E->mesh.NOZ[level];
Boundary_conditions.c:406:    	  E->NODE[level][node] = E->NODE[level][node] | (mask);
Boundary_conditions.c:407:    	  if(level==E->mesh.levmax)   /* NB */
Boundary_conditions.c:423:  const int dims=E->mesh.nsd;
Boundary_conditions.c:425:  fprintf(E->fp,"Periodic boundary conditions\n");
Boundary_conditions.c:435: const int dims=E->mesh.nsd;
Boundary_conditions.c:437: fprintf(E->fp,"Periodic temperature boundary conditions\n");
Boundary_conditions.c:450:    const int dims=E->mesh.nsd;
Boundary_conditions.c:452:    for(i=1;i<=E->mesh.NNO[level];i++) {
Boundary_conditions.c:453:        if(E->NODE[level][i] & OFFSIDE)
Boundary_conditions.c:455:        if ( (E->NODE[level][i] & VBX) != 0 )
Boundary_conditions.c:456:            Res[ E->ID[level][i].doff[1] ] = 0.0;
Boundary_conditions.c:457:        if ( (E->NODE[level][i] & VBZ) != 0 )
Boundary_conditions.c:458:            Res[ E->ID[level][i].doff[2] ] = 0.0;
Boundary_conditions.c:459:        if (3==dims && ((E->NODE[level][i] & VBY) != 0))
Boundary_conditions.c:460:            Res[ E->ID[level][i].doff[3] ] = 0.0;
Boundary_conditions.c:473:    for(node=1;node<=E->mesh.nno;node++)  {
Boundary_conditions.c:474:	if(E->node[node] & OFFSIDE)
Boundary_conditions.c:477:	type = (E->node[node] & (TBX | TBZ | TBY));
Boundary_conditions.c:483:	    E->T[node] = E->TB[1][node];
Boundary_conditions.c:486:	    E->T[node] = E->TB[2][node];
Boundary_conditions.c:489:	    E->T[node] = E->TB[3][node];
Boundary_conditions.c:492:	    E->T[node] = 0.5 * (E->TB[1][node] + E->TB[2][node]);
Boundary_conditions.c:495:	    E->T[node] = 0.5 * (E->TB[1][node] + E->TB[3][node]);
Boundary_conditions.c:498:	    E->T[node] = 0.5 * (E->TB[2][node] + E->TB[3][node]);
Boundary_conditions.c:501:	    E->T[node] = 0.3333333 * (E->TB[1][node] + E->TB[2][node] + E->TB[3][node]);
Boundary_conditions.c:522:    const int addi_dof = additional_dof[E->mesh.nsd];
Boundary_conditions.c:524:    const int dofs = E->mesh.dof;
Boundary_conditions.c:525:    const int nno = E->mesh.nno;
Boundary_conditions.c:528:	if(E->node[node] & OFFSIDE)
Boundary_conditions.c:531:        if (E->node[node] & typex)  
Boundary_conditions.c:532:	      U[E->id[node].doff[1]] = E->VB[1][node]; 
Boundary_conditions.c:533:	if (E->node[node] & typez)  
Boundary_conditions.c:534:	      U[E->id[node].doff[2]] = E->VB[2][node]; 
Boundary_conditions.c:535: 	if (3==dofs && E->node[node] & typey)  
Boundary_conditions.c:536:	      U[E->id[node].doff[3]] = E->VB[3][node]; 
Boundary_conditions.c:564:    T0max = (Tsmax * E->data.ref_temperature) / (1.0 + Tsmax);
Boundary_conditions.c:568:    Tsmin = T0min / (E->data.ref_temperature - T0max);
Boundary_conditions.c:571:    fprintf(E->fp,"T0 %f %f %f %f\n",T0min, T0max, Tsmin, Tsmax);
Boundary_conditions.c:573:    for(i=1;i<=E->mesh.nox;i++)  {
Boundary_conditions.c:575:    	node = i*E->mesh.noz;
Boundary_conditions.c:576:	theta = E->X[1][node];
Boundary_conditions.c:624:  lev = E->mesh.levmax;
Boundary_conditions.c:628:    T_cmb = E->control.TBCbotval;
Boundary_conditions.c:633:    if(E->parallel.me==0)
Boundary_conditions.c:634:      fprintf(E->fp,"T1 = %.6f %.6f\n ",E->T[1][1],E->Have.T[1]);
Boundary_conditions.c:635:    T_cmb = E->Have.T[1]; */
Boundary_conditions.c:636:   /*T_cmb = E->T[1][1];*/
Boundary_conditions.c:639:  delta_T = -3.0 * (E->data.density * E->data.Cp * E->sphere.ro)
Boundary_conditions.c:640:                  / (E->data.density_core * Cpc * E->sphere.ri)
Boundary_conditions.c:641:                  * Fc * E->advection.timestep;
Boundary_conditions.c:643:  fprintf(E->fp,"T_cmb = %.6f + dT_cmb = %.6f => ",T_cmb,delta_T);
Boundary_conditions.c:647:  fprintf(E->fp,"T_cmb = %.6f\n",T_cmb);
Boundary_conditions.c:649:  if(E->mesh.bottbc == 1) {
Boundary_conditions.c:650:    horizontal_bc(E,E->TB,1,2,T_cmb,TBZ,1,E->mesh.levmax);
Composition_adv.c:35:  for(j=1;j<=E->mesh.nsd;j++)   {
Composition_adv.c:36:    Vpred[j] = (float *) malloc ((E->advection.markers+1)*sizeof(float));
Composition_adv.c:40:  velocity_markers(E,Vpred,V,XMCpred,E->CElement);
Composition_adv.c:43:  for (i=1;i<=E->advection.markers;i++)   {
Composition_adv.c:44:    XMC[1][i] = XMC[1][i] + 0.5*E->advection.timestep*(VO[1][i]+Vpred[1][i])/XMC[2][i];
Composition_adv.c:45:    XMC[2][i] = XMC[2][i] + 0.5*E->advection.timestep*(VO[2][i]+Vpred[2][i]);
Composition_adv.c:46:    XMC[1][i] = min(XMC[1][i],E->XP[1][E->mesh.nox]);
Composition_adv.c:47:    XMC[1][i] = max(XMC[1][i],E->XP[1][1]);
Composition_adv.c:48:    XMC[2][i] = min(XMC[2][i],E->XP[2][E->mesh.noz]);
Composition_adv.c:49:    XMC[2][i] = max(XMC[2][i],E->XP[2][1]);
Composition_adv.c:52:  element_markers(E,XMC,E->CElement);
Composition_adv.c:53:  get_C_from_markers(E,C,E->CElement);
Composition_adv.c:55:  for(j=1;j<=E->mesh.nsd;j++)  {  
Composition_adv.c:78:  velocity_markers(E,VO,V,XMC,E->CElement);
Composition_adv.c:81:  for (i=1;i<=E->advection.markers;i++)  {
Composition_adv.c:82:    XMCpred[1][i] = XMC[1][i] + E->advection.timestep*VO[1][i]/XMC[2][i];
Composition_adv.c:83:    XMCpred[2][i] = XMC[2][i] + E->advection.timestep*VO[2][i];
Composition_adv.c:84:    XMCpred[1][i] = min(XMCpred[1][i],E->XP[1][E->mesh.nox]);
Composition_adv.c:85:    XMCpred[1][i] = max(XMCpred[1][i],E->XP[1][1]);
Composition_adv.c:86:    XMCpred[2][i] = min(XMCpred[2][i],E->XP[2][E->mesh.noz]);
Composition_adv.c:87:    XMCpred[2][i] = max(XMCpred[2][i],E->XP[2][1]);
Composition_adv.c:91:  element_markers(E,XMCpred,E->CElement);
Composition_adv.c:93:  get_C_from_markers(E,C,E->CElement);
Composition_adv.c:114:  const int elx=E->mesh.elx;
Composition_adv.c:115:  const int elz=E->mesh.elz;
Composition_adv.c:116:  const int ely=E->mesh.ely;
Composition_adv.c:117:  const int nox=E->mesh.nox;
Composition_adv.c:118:  const int noz=E->mesh.noz;
Composition_adv.c:119:  const int nno=E->mesh.nno;
Composition_adv.c:120:  const int nel=E->mesh.nel;
Composition_adv.c:121:  const int dims=E->mesh.nsd;
Composition_adv.c:123:  const int lev=E->mesh.levmax;
Composition_adv.c:138:	E->advection.marker_type_prev[0] = E->advection.marker_type[0];
Composition_adv.c:139:	E->advection.marker_type_prev[1] = E->advection.marker_type[1];
Composition_adv.c:140:	E->advection.marker_type[0] = 0;
Composition_adv.c:141:	E->advection.marker_type[1] = 0;
Composition_adv.c:148:  for (imark=1;imark<=E->advection.markers;imark++)   {
Composition_adv.c:149:    element[(int)(E->C12[imark])][Element[imark]] ++; 
Composition_adv.c:150:    elementC[Element[imark]] += E->C12f[imark]; 
Composition_adv.c:161:       temp3 = E->CE[el];    /* elemental C */
Composition_adv.c:164:       node = E->ien[el].node[j];
Composition_adv.c:165:       C[node] += E->TWW[lev][el].node[j] * temp3;
Composition_adv.c:168:		E->CE[el] = temp3;
Composition_adv.c:170:		E->advection.element[0][el] = element[0][el];
Composition_adv.c:171:		E->advection.element[1][el] = element[1][el];
Composition_adv.c:172:		E->advection.marker_type[0] += element[0][el];
Composition_adv.c:173:		E->advection.marker_type[1] += element[1][el];
Composition_adv.c:177:     C[node] = C[node]*E->Mass[node];
Composition_adv.c:195:  E->advection.markerIX=1;
Composition_adv.c:196:  E->advection.markerIZ=1;
Composition_adv.c:198:  for (i=1;i<=E->advection.markers;i++)  {
Composition_adv.c:237:    p = pow((double)E->advection.markers_per_ele,(double)(1.0/E->mesh.dof));
Composition_adv.c:239:		for (el=1;el<E->mesh.nel;el++) {
Composition_adv.c:240:	    dx = (E->X[1][E->ien[el].node[3]] - E->X[1][E->ien[el].node[1]])/p;
Composition_adv.c:241:  	  dr = (E->X[2][E->ien[el].node[3]] - E->X[2][E->ien[el].node[1]])/p;
Composition_adv.c:246:    	    E->XMC[1][node] = E->X[1][E->ien[el].node[1]] + dx*(i-0.5);
Composition_adv.c:247:      	  E->XMC[2][node] = E->X[2][E->ien[el].node[1]] + dr*(j-0.5);
Composition_adv.c:248:        	E->CElement[node] = el;
Composition_adv.c:249:					E->C12[node] = 0;		/* Set all markers to 0 */
Composition_adv.c:250:					E->C12f[node] = 0.0;		/* Set all markers to 0 */
Composition_adv.c:284:  const int elx=E->mesh.elx;
Composition_adv.c:285:  const int elz=E->mesh.elz;
Composition_adv.c:286:  const int ely=E->mesh.ely;
Composition_adv.c:287:  const int nox=E->mesh.nox;
Composition_adv.c:288:  const int noz=E->mesh.noz;
Composition_adv.c:289:  const int nno=E->mesh.nno;
Composition_adv.c:290:  const int nel=E->mesh.nel;
Composition_adv.c:291:  const int dims=E->mesh.nsd;
Composition_adv.c:293:  const int lev=E->mesh.levmax;
Composition_adv.c:300:		 p = pow((double)E->advection.markers_per_ele,(double)(1.0/E->mesh.dof));
Composition_adv.c:303:	E->advection.marker_type_prev[0] = E->advection.marker_type[0];
Composition_adv.c:304:	E->advection.marker_type_prev[1] = E->advection.marker_type[1];
Composition_adv.c:305:	E->advection.marker_type[0] = 0;
Composition_adv.c:306:	E->advection.marker_type[1] = 0;
Composition_adv.c:313:		E->advection.element[0][el] = 0;
Composition_adv.c:314:		E->advection.element[1][el] = 0;
Composition_adv.c:319://  for (imark=1;imark<=E->advection.markers;imark++)   {
Composition_adv.c:320://    element[E->C12[imark]][Element[imark]] ++; 
Composition_adv.c:321://		E->advection.marker_type[E->C12[imark]] ++;
Composition_adv.c:342:		  //if (E->advection.timesteps >= 466 && el==1) (void)fprintf(stderr,"4c\n");
Composition_adv.c:347:				while (temp3 > temp1  && imark <= E->advection.markers) {
Composition_adv.c:350:					if ( (Element[imark] == el) && (E->C12[imark] == 0) ){
Composition_adv.c:351:						E->C12[imark] = 1;
Composition_adv.c:361:		E->advection.element[0][el] = temp0;
Composition_adv.c:362:		E->advection.element[1][el] = temp1;
Composition_adv.c:363:		E->advection.marker_type[0] += temp0;
Composition_adv.c:364:		E->advection.marker_type[1] += temp1;
Composition_adv.c:369:  for (imark=1;imark<=E->advection.markers;imark++)   {
Composition_adv.c:371:    E->C12f[imark] = CE[el];
Composition_adv.c:374:		  E->advection.element[0][el] += 1;
Composition_adv.c:375:		  E->advection.marker_type[0] += 1;
Composition_adv.c:377:		  E->advection.element[1][el] += 1;
Composition_adv.c:378:		  E->advection.marker_type[1] += 1;
Composition_adv.c:382:	fflush(E->fpdebug);
Composition_adv.c:402:  sprintf(filename1,"markers%d.%d",E->advection.timesteps,onf);
Composition_adv.c:414:  for (i=1;i<=E->advection.markers;i++)  {
Composition_adv.c:418:    weigh1 = (E->eco[el].size[1]-dX[1])*(E->eco[el].size[2]-dX[2]);
Composition_adv.c:419:    weigh4 = dX[1]*(E->eco[el].size[2]-dX[2]);
Composition_adv.c:421:    weigh2 = (E->eco[el].size[1]-dX[1])*dX[2];
Composition_adv.c:422:    area = E->eco[el].size[1]*E->eco[el].size[2];
Composition_adv.c:424:    V1[1][i] = (weigh1*V[1][E->ien[el].node[1]] + weigh2*V[1][E->ien[el].node[2]] 
Composition_adv.c:425:              + weigh3*V[1][E->ien[el].node[3]] + weigh4*V[1][E->ien[el].node[4]])
Composition_adv.c:427:    V1[2][i] = (weigh1*V[2][E->ien[el].node[1]] + weigh2*V[2][E->ien[el].node[2]] 
Composition_adv.c:428:              + weigh3*V[2][E->ien[el].node[3]] + weigh4*V[2][E->ien[el].node[4]])
Composition_adv.c:434:if (i<1200)fprintf(E->fp,"%d %d %g %g %g %g %g %g %g %g\n",i,el,E->eco[el].size[1],E->eco[el].size[2],dX[1],dX[2],XMC[1][i],XMC[2][i],V1[1][i],V1[2][i]);
Composition_adv.c:435:if (i<1200)fprintf(E->fp,"V1 %d %d %g %g %g %g\n",i,el,V[1][E->ien[el].node[1]],V[1][E->ien[el].node[2]],V[1][E->ien[el].node[3]],V[1][E->ien[el].node[4]]);
Composition_adv.c:436:if (i<1200)fprintf(E->fp,"V2 %d %d %g %g %g %g\n",i,el,V[2][E->ien[el].node[1]],V[2][E->ien[el].node[2]],V[2][E->ien[el].node[3]],V[2][E->ien[el].node[4]]);
Composition_adv.c:451:  const int nox = E->mesh.nox;
Composition_adv.c:452:  const int noz = E->mesh.noz;
Composition_adv.c:453:  const int elx = E->mesh.elx;
Composition_adv.c:454:  const int elz = E->mesh.elz;
Composition_adv.c:459:    dx = E->XP[1][nox]/elx;
Composition_adv.c:461:      fprintf(E->fp,"%g\n",E->XP[2][i]);
Composition_adv.c:463:      fprintf(E->fp,"%g\n",E->XP[1][i]);
Composition_adv.c:467:  E->advection.markerIX = min(XMC1/dx+1,elx);
Composition_adv.c:468:  dX[1] = XMC1-E->XP[1][E->advection.markerIX];
Composition_adv.c:475:    if (XMC2>=E->XP[2][i])  {
Composition_adv.c:476:       if (XMC2<=E->XP[2][i+1])  {
Composition_adv.c:477:          E->advection.markerIZ = i;
Composition_adv.c:478:          dX[2] = XMC2-E->XP[2][i];
Composition_adv.c:492:  el = E->advection.markerIZ + (E->advection.markerIX-1)*elz;
Composition_adv.c:494:       fprintf(E->fp,"!!!overflow %g %g %d\n",XMC1,XMC2,el); fflush(E->fp);
Construct_arrays.c:24:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:27:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:28:    elz = E->mesh.ELZ[lev];
Construct_arrays.c:29:    ely = E->mesh.ELY[lev];
Construct_arrays.c:30:    noz = E->mesh.NOZ[lev];
Construct_arrays.c:31:    noy = E->mesh.NOY[lev];
Construct_arrays.c:32:    nox = E->mesh.NOX[lev];
Construct_arrays.c:33:    elx = E->mesh.ELX[lev];
Construct_arrays.c:34:    nel=E->mesh.NEL[lev];
Construct_arrays.c:35:    nno=E->mesh.NNO[lev];
Construct_arrays.c:43:		         E->IEN[lev][element].node[rr]= start 
Construct_arrays.c:50:      E->NEI[lev].nels[i] = 0;
Construct_arrays.c:54:        node=E->IEN[lev][e].node[a];
Construct_arrays.c:55:	    E->NEI[lev].nels[node]++;
Construct_arrays.c:56:        E->NEI[lev].element[(node-1)*ends+E->NEI[lev].nels[node]-1] = e;
Construct_arrays.c:57:	    E->NEI[lev].lnode[(node-1)*ends+E->NEI[lev].nels[node]-1] = a;
Construct_arrays.c:64:    for(element=1;element<=E->mesh.NEL[E->mesh.levmax];element++)
Construct_arrays.c:65:      if ( (element-1)%E->mesh.elz==0) {
Construct_arrays.c:67:        E->sien[e].node[1] = (E->ien[element].node[1]-1)/E->mesh.noz+1;
Construct_arrays.c:68:        E->sien[e].node[2] = (E->ien[element].node[4]-1)/E->mesh.noz+1;
Construct_arrays.c:70:          E->sien[e].node[3] = (E->ien[element].node[8]-1)/E->mesh.noz+1;
Construct_arrays.c:71:          E->sien[e].node[4] = (E->ien[element].node[5]-1)/E->mesh.noz+1;
Construct_arrays.c:73:        E->surf_element[e] = element;
Construct_arrays.c:75:    E->mesh.snel = e;
Construct_arrays.c:76:    for (i=1;i<=E->mesh.nsf;i++)
Construct_arrays.c:77:      E->surf_node[i] = i*E->mesh.noz;
Construct_arrays.c:80:if (E->control.verbose) 
Construct_arrays.c:81:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:82:     fprintf(E->fp,"output_IEN_arrays %d\n",lev);
Construct_arrays.c:84:        for (i=1;i<=E->mesh.NEL[lev];i++)
Construct_arrays.c:85:           fprintf(E->fp,"%d %d %d %d %d\n",i,E->IEN[lev][i].node[1],E->IEN[lev][i].node[2],E->IEN[lev][i].node[3],E->IEN[lev][i].node[4]);
Construct_arrays.c:87:        for (i=1;i<=E->mesh.NEL[lev];i++)
Construct_arrays.c:88:           fprintf(E->fp,"%d %d %d %d %d %d %d %d %d\n",i,E->IEN[lev][i].node[1],E->IEN[lev][i].node[2],E->IEN[lev][i].node[3],E->IEN[lev][i].node[4],E->IEN[lev][i].node[5],E->IEN[lev][i].node[6],E->IEN[lev][i].node[7],E->IEN[lev][i].node[8]);
Construct_arrays.c:108:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:112:    for(lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:114:      elz = E->mesh.ELZ[lev];
Construct_arrays.c:115:      ely = E->mesh.ELY[lev];
Construct_arrays.c:116:      noz=E->mesh.NOZ[lev];
Construct_arrays.c:117:      noy=E->mesh.NOY[lev];
Construct_arrays.c:119:      for(node=1;node<=E->mesh.NNO[lev];node++)
Construct_arrays.c:121:              E->ID[lev][node].doff[doff] = eqn_count;
Construct_arrays.c:124:      E->mesh.NEQ[lev] = eqn_count;
Construct_arrays.c:129:    E->mesh.neq = E->mesh.NEQ[E->mesh.levmax];  /*  Total NUMBER of independent variables  */
Construct_arrays.c:132:if (E->control.verbose)
Construct_arrays.c:133:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:134:      fprintf(E->fp,"output_ID_arrays %d\n",lev);
Construct_arrays.c:136:        for (i=1;i<=E->mesh.NNO[lev];i++)
Construct_arrays.c:137:          fprintf(E->fp,"%d %d %d \n",i,E->ID[lev][i].doff[1],E->ID[lev][i].doff[2]);
Construct_arrays.c:139:        for (i=1;i<=E->mesh.NNO[lev];i++)
Construct_arrays.c:140:          fprintf(E->fp,"%d %d %d %d\n",i,E->ID[lev][i].doff[1],E->ID[lev][i].doff[2],E->ID[lev][i].doff[3]);
Construct_arrays.c:157:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:162:  for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:163:    nel=E->mesh.NEL[lev];
Construct_arrays.c:166:	           E->LMD[lev][e].node[a].doff[1] = E->ID[lev][E->IEN[lev][e].node[a]].doff[1]; 
Construct_arrays.c:167:	           E->LMD[lev][e].node[a].doff[2] = E->ID[lev][E->IEN[lev][e].node[a]].doff[2]; 
Construct_arrays.c:169:                      E->LMD[lev][e].node[a].doff[3] = E->ID[lev][E->IEN[lev][e].node[a]].doff[3]; 
Construct_arrays.c:173:  if(E->control.verbose) 
Construct_arrays.c:175:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:176:          fprintf(E->fp,"output_LM_arrays %d\n",lev);
Construct_arrays.c:177:          nel=E->mesh.NEL[lev];
Construct_arrays.c:180:	      fprintf(E->fp,"%d %d %d %d %d\n",e,a,E->LMD[lev][e].node[a].doff[1],E->LMD[lev][e].node[a].doff[2],E->LMD[lev][e].node[a].doff[3]); 
Construct_arrays.c:183:     else if(E->mesh.nsd==2)
Construct_arrays.c:184:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:185:          fprintf(E->fp,"output_LM_arrays %d\n",lev);
Construct_arrays.c:186:          nel=E->mesh.NEL[lev];
Construct_arrays.c:189:	      fprintf(E->fp,"%d %d %d %d\n",e,a,E->LMD[lev][e].node[a].doff[1],E->LMD[lev][e].node[a].doff[2]); 
Construct_arrays.c:191:  fflush(E->fp);
Construct_arrays.c:211:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:216:    for(lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)   {
Construct_arrays.c:217:       neq=E->mesh.NEQ[lev];
Construct_arrays.c:218:       nno=E->mesh.NNO[lev];
Construct_arrays.c:219:       E->Node_map[lev]=(int *) malloc ((nno+5)*max_eqn*sizeof(int));
Construct_arrays.c:222:	   E->Node_map[lev][i] = neq+1;  /* DANGER !!! */
Construct_arrays.c:224:	   E->Node_eqn[lev][i] = 0;
Construct_arrays.c:229:	   if(E->NODE[lev][nn] & OFFSIDE)
Construct_arrays.c:231:	   for(el=1;el<=E->NEI[lev].nels[nn];el++)  {
Construct_arrays.c:232:	       element = E->NEI[lev].element[(nn-1)*ends+el-1]; 
Construct_arrays.c:234:		   node1=E->IEN[lev][element].node[n]; /*global node number*/
Construct_arrays.c:236:		       eqn1=E->ID[lev][node1].doff[i];
Construct_arrays.c:240:			   if(E->Node_map[lev][loc1+j] == eqn1) { /* found, index next equation */
Construct_arrays.c:246:			   E->Node_map[lev][loc1+count] = eqn1;
Construct_arrays.c:252:/* fprintf(E->fp,"%d %d %d \n",nn,E->NEI[lev].nels[nn],count); 
Construct_arrays.c:254:           E->Node_eqn[lev][nn] = loc1;
Construct_arrays.c:259:       E->Node_eqn[lev][nno+1] = loc1;       /* mark the end of Node_eqn */
Construct_arrays.c:263:	   if(E->NODE[lev][nn] & OFFSIDE)
Construct_arrays.c:266:	   E->Node_k_id[lev][nn] = loc1;
Construct_arrays.c:267: 	   loc1 += (E->Node_eqn[lev][nn+1]-E->Node_eqn[lev][nn]) * dims;
Construct_arrays.c:270:       E->Eqn_k[lev] = (higher_precision *) malloc ((loc1+5) * sizeof(higher_precision));
Construct_arrays.c:272:       E->mesh.matrix_size[lev] = loc1 + 1;
Construct_arrays.c:295:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:297:    const int lms=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:299:    for(level=E->mesh.levmax;level>=E->mesh.levmin;level--)   {
Construct_arrays.c:300:	neq=E->mesh.NEQ[level];
Construct_arrays.c:301:	nel=E->mesh.NEL[level];
Construct_arrays.c:302:	nno=E->mesh.NNO[level];
Construct_arrays.c:305:	    E->BI[level][i] = 0.0; 
Construct_arrays.c:306:    for(i=0;i<=E->mesh.matrix_size[level];i++) 
Construct_arrays.c:307:        E->Eqn_k[level][i] = 0.0; 
Construct_arrays.c:313:	    if (E->control.augmented_Lagr)
Construct_arrays.c:319:		node=E->IEN[level][element].node[i];
Construct_arrays.c:320:		if(E->NODE[level][node] & OFFSIDE)
Construct_arrays.c:326:		loc0=E->Node_eqn[level][node];
Construct_arrays.c:327:		max_eqn = E->Node_eqn[level][node+1] - E->Node_eqn[level][node];
Construct_arrays.c:328:		loc1=E->Node_k_id[level][node];
Construct_arrays.c:329:		loc2=loc1+(E->LMD[level][element].node[i].doff[2]
Construct_arrays.c:330:			  -E->LMD[level][element].node[i].doff[1])*max_eqn;
Construct_arrays.c:331:		if (3==dims) loc3=loc1+(E->LMD[level][element].node[i].doff[3]
Construct_arrays.c:332:			         -E->LMD[level][element].node[i].doff[1])*max_eqn;
Construct_arrays.c:334:		if(E->NODE[level][node] & VBX) w1=0.0;
Construct_arrays.c:335:		if(E->NODE[level][node] & VBZ) w2=0.0;
Construct_arrays.c:336:		if(E->NODE[level][node] & VBY) w3=0.0;
Construct_arrays.c:341:		    node1=E->IEN[level][element].node[j];
Construct_arrays.c:342:		    eqn1=E->LMD[level][element].node[j].doff[1];
Construct_arrays.c:343:		    eqn2=E->LMD[level][element].node[j].doff[2];
Construct_arrays.c:344:		    if(3==dims) eqn3=E->LMD[level][element].node[j].doff[3];
Construct_arrays.c:346:		    if(E->NODE[level][node1] & VBX) ww1=0.0;
Construct_arrays.c:347:		    if(E->NODE[level][node1] & VBZ) ww2=0.0;
Construct_arrays.c:348:		    if(E->NODE[level][node1] & VBY) ww3=0.0; 
Construct_arrays.c:354:			if(E->Node_map[level][loc0+k] == eqn1) { /* found, index next equation */
Construct_arrays.c:362:		    E->Eqn_k[level][loc1+index] +=  w1*ww1*elt_K[pp*lms+qq]; /* direction 1 */
Construct_arrays.c:363:		    E->Eqn_k[level][loc2+index] +=  w2*ww1*elt_K[(pp+1)*lms+qq]; /* direction 1 */
Construct_arrays.c:364:		    if(3==dims) E->Eqn_k[level][loc3+index] +=  w3*ww1*elt_K[(pp+2)*lms+qq]; /* direction 1 */
Construct_arrays.c:370:			if(E->Node_map[level][loc0+k] == eqn2) { /* found, index next equation */
Construct_arrays.c:378:		    E->Eqn_k[level][loc1+index] += w1*ww2*elt_K[pp*lms+qq+1]; /* direction 1 */
Construct_arrays.c:379:		    E->Eqn_k[level][loc2+index] += w2*ww2*elt_K[(pp+1)*lms+qq+1]; /* direction 2 */
Construct_arrays.c:380:		    if(3==dims) E->Eqn_k[level][loc3+index] += w3*ww2*elt_K[(pp+2)*lms+qq+1]; /* direction 3 */
Construct_arrays.c:387:			    if(E->Node_map[level][loc0+k] == eqn3) { /* found, index next equation */
Construct_arrays.c:396:			E->Eqn_k[level][loc1+index] += w1*ww3*elt_K[pp*lms+qq+2]; /* direction 1 */
Construct_arrays.c:397:			E->Eqn_k[level][loc2+index] += w2*ww3*elt_K[(pp+1)*lms+qq+2]; /* direction 2 */
Construct_arrays.c:398:			E->Eqn_k[level][loc3+index] += w3*ww3*elt_K[(pp+2)*lms+qq+2]; /* direction 3 */
Construct_arrays.c:407:            if(E->BI[level][j] ==0.0)  fprintf(stderr,"level %d, equation %d/%d has zero diagonal term\n",level,j,neq);
Construct_arrays.c:408:	    assert( E->BI[level][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:409:            E->BI[level][j]  = (float) 1.0/E->BI[level][j];   
Construct_arrays.c:412:      if (E->control.verbose)   {
Construct_arrays.c:414:        fprintf(E->fp,"level %d\n",level);
Construct_arrays.c:416:            if(E->NODE[level][j] & OFFSIDE)
Construct_arrays.c:418:            eqn1=E->ID[level][j].doff[1];
Construct_arrays.c:419:            eqn2=E->ID[level][j].doff[2];
Construct_arrays.c:420:            max_eqn = E->Node_eqn[level][j+1]-E->Node_eqn[level][j];
Construct_arrays.c:421:            B1=E->Eqn_k[level]+E->Node_k_id[level][j];
Construct_arrays.c:422:            B2=E->Eqn_k[level]+E->Node_k_id[level][j]+max_eqn;
Construct_arrays.c:424:                fprintf(E->fp,"%d %d %g %g\n",j,i,B1[i],B2[i]);
Construct_arrays.c:450:  for(lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--){
Construct_arrays.c:451:      elz = E->mesh.ELZ[lev];
Construct_arrays.c:452:      ely = E->mesh.ELY[lev];
Construct_arrays.c:453:      elx = E->mesh.ELX[lev];
Construct_arrays.c:454:      noy = E->mesh.NOY[lev];
Construct_arrays.c:455:      noz = E->mesh.NOZ[lev];
Construct_arrays.c:456:      nno = E->mesh.NNO[lev];
Construct_arrays.c:458:      for(i=1;i<=E->mesh.NNO[lev];i++)
Construct_arrays.c:459:          E->TW[lev][i] = 0.0;
Construct_arrays.c:464:                  for(l=1;l<=enodes[E->mesh.nsd];l++) {
Construct_arrays.c:466:                      node = E->IEN[lev][elt].node[l];
Construct_arrays.c:467:                      E->TW[lev][node] += 1.0;
Construct_arrays.c:470:      for(i=1;i<=E->mesh.NNO[lev];i++) {
Construct_arrays.c:471:          if(E->NODE[lev][i] & OFFSIDE)
Construct_arrays.c:473:          assert( E->TW[lev][i] != 0.0  /* setting weightings failed */);
Construct_arrays.c:474:          E->TW[lev][i] = 1.0/(E->TW[lev][i]);
Construct_arrays.c:482:  for(i=1;i<=E->mesh.nox;i++)   /* Horizontal  */
Construct_arrays.c:483:    { for(j=1;j<=E->mesh.noy;j++)
Construct_arrays.c:484:        { node = 1+(i-1)*E->mesh.noz+(j-1)*E->mesh.noz*E->mesh.nox;
Construct_arrays.c:485:          E->node[node] = E->node[node] | TZEDGE;
Construct_arrays.c:486:          E->node[node] = E->node[node] | VZEDGE;
Construct_arrays.c:487:          node += E->mesh.noz-1;;
Construct_arrays.c:488:          E->node[node] = E->node[node] | VZEDGE;
Construct_arrays.c:489:          E->node[node] = E->node[node] | TZEDGE;
Construct_arrays.c:492:  if (E->mesh.nsd == 3) /* not appropriate otherwise */
Construct_arrays.c:493:    for(i=1;i<=E->mesh.noz;i++) /* vertical edge, x normal */
Construct_arrays.c:494:      { for(j=1;j<=E->mesh.noy;j++)
Construct_arrays.c:495:          { node = i + (j-1) * E->mesh.nox * E->mesh.noz;
Construct_arrays.c:496:            E->node[node] = E->node[node] | TXEDGE;
Construct_arrays.c:497:            E->node[node] = E->node[node] | VXEDGE;
Construct_arrays.c:498:            node = i+(E->mesh.nox-1)*E->mesh.noz + (j-1) * E->mesh.nox * E->mesh
Construct_arrays.c:500:            E->node[node] = E->node[node] | TXEDGE;
Construct_arrays.c:501:            E->node[node] = E->node[node] | VXEDGE; } }
Construct_arrays.c:503:  for(i=1;i<=E->mesh.noz;i++)   /* vertical edge, y normal */
Construct_arrays.c:504:    { for(j=1;j<=E->mesh.nox;j++)
Construct_arrays.c:505:        { node = i + (j-1) * E->mesh.noz;
Construct_arrays.c:506:          E->node[node] = E->node[node] | TYEDGE;
Construct_arrays.c:507:          E->node[node] = E->node[node] | VYEDGE;
Construct_arrays.c:508:          node = i+(E->mesh.noy-1)*E->mesh.noz*E->mesh.nox + (j-1) * E->mesh.noz
Construct_arrays.c:510:          E->node[node] = E->node[node] | TYEDGE;
Construct_arrays.c:511:          E->node[node] = E->node[node] | VYEDGE; } }
Construct_arrays.c:529:     for(lev=E->mesh.levmax-1;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:530:      elx = E->mesh.ELX[lev];
Construct_arrays.c:531:	  elz = E->mesh.ELZ[lev];
Construct_arrays.c:532:	  ely = E->mesh.ELY[lev];
Construct_arrays.c:542:		  for(l=1;l<=enodes[E->mesh.nsd];l++)   {
Construct_arrays.c:543:		      E->EL[lev][elt].sub[l] = eltu
Construct_arrays.c:563:    const int dims=E->mesh.nsd;
Construct_arrays.c:564:    const int n=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:566:    if(E->control.verbose )
Construct_arrays.c:569:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Construct_arrays.c:571:	for(el=1;el<=E->mesh.NEL[lev];el++)    {
Construct_arrays.c:573:	    get_elt_k(E,el,E->elt_k[lev][el].k,lev,0);  /* not for penalty */ 
Construct_arrays.c:575:	    if (E->control.augmented_Lagr)
Construct_arrays.c:576:	        get_aug_k(E,el,E->elt_k[lev][el].k,lev,0);
Construct_arrays.c:578:        build_diagonal_of_K(E,el,E->elt_k[lev][el].k,lev);
Construct_arrays.c:583:            for(j=0;j<E->mesh.NEQ[lev];j++) {
Construct_arrays.c:584:	       if(E->BI[lev][j] ==0.0)  fprintf(stderr,"level %d, equation %d/%d has zero diagonal term\n",lev,j,E->mesh.NEQ[lev]);
Construct_arrays.c:585:               assert( E->BI[lev][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:586:               E->BI[lev][j]  = (float) 1.0/E->BI[lev][j];    
Construct_arrays.c:590: if (E->control.verbose) 
Construct_arrays.c:591:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Construct_arrays.c:592:	for(el=1;el<=E->mesh.NEL[lev];el++)
Construct_arrays.c:593:             for(j=1;j<=enodes[E->mesh.nsd];j++)
Construct_arrays.c:594:		 for(k=1;k<=enodes[E->mesh.nsd];k++) {
Construct_arrays.c:596:	/*  fprintf(E->fp,"stiff_for_e %d %d %d %g %g %g %g \n",el,j,k,E->elt_k[lev][el].k[ii],E->elt_k[lev][el].k[ii+1],E->elt_k[lev][el].k[ii+n],E->elt_k[lev][el].k[ii+n+1]);      */
Construct_arrays.c:609:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:612:  if(E->control.verbose)
Construct_arrays.c:615:  for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Construct_arrays.c:616:    for(el=1;el<=E->mesh.NEL[lev];el++)       {
Construct_arrays.c:617:      get_elt_g(E,el,E->elt_del[lev][el].g,lev);  
Construct_arrays.c:631:  const int  dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:635:  for (el=1; el<=E->mesh.nel; el++)  {
Construct_arrays.c:636:    E->mat[el] = 1;
Construct_arrays.c:639:       nodea = E->ien[el].node[a];
Construct_arrays.c:640:       x2 += E->X[2][nodea];
Construct_arrays.c:645:         E->mat[el]=llayer;
Construct_arrays.c:652:  E->data.therm_exp_factor = 1.0/E->data.therm_exp_factor;
Construct_arrays.c:655:  slope1 = (1.0-E->data.therm_exp_factor)/(E->sphere.ro-E->sphere.ri);
Construct_arrays.c:656:  slope2 = (1.0-E->data.therm_diff_factor)/(E->sphere.ro-E->sphere.ri);
Construct_arrays.c:657:  for (i=1;i<=E->mesh.noz;i++)  {
Construct_arrays.c:658:    E->expansivity[i] = (slope1*(E->X[2][i]-E->sphere.ri) + E->data.therm_exp_factor); 
Construct_arrays.c:659:    E->diffusivity[i] = (slope2*(E->X[2][i]-E->sphere.ri) + E->data.therm_diff_factor); 
Construct_arrays.c:662: for (i=1;i<=E->mesh.noz;i++)
Construct_arrays.c:663:   fprintf(E->fp,"%d  %g %g\n",i,E->expansivity[i],E->diffusivity[i]);
Construct_arrays.c:667:  for (el=1; el<=E->mesh.nel; el++)
Construct_arrays.c:668:    fprintf(E->fp,"mat[%d]= %d \n",el,E->mat[el]);
Construct_arrays.c:694:   for (i=E->mesh.levmin;i<=E->mesh.levmax;i++)
Construct_arrays.c:695:    if(!E->control.NMULTIGRID && !E->control.NASSEMBLE)  {
Construct_arrays.c:696:       E->elt_k[i]=(struct EK *)malloc((E->mesh.NEL[i]+1)*sizeof(struct EK));
Construct_arrays.c:698:    else if(E->control.NMULTIGRID || E->control.NASSEMBLE) {
Construct_arrays.c:699:       E->Node_eqn[i]  = (int *) malloc((E->mesh.NNO[i]+5) * sizeof(int));
Construct_arrays.c:700:       E->Node_k_id[i] = (int *) malloc((E->mesh.NNO[i]+5) * sizeof(int));
Construct_arrays.c:704:  if (been_here0 == 0 || E->viscosity.update_allowed)   {
Construct_arrays.c:707:    if (E->control.NMULTIGRID)
Construct_arrays.c:712:    if (E->control.NMULTIGRID || E->control.NASSEMBLE) {
Construct_arrays.c:723:    for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   
Convection.c:28:   input_int("composition",&(E->control.composition),"0");
Convection.c:29:   input_int("melting",&(E->control.melting),"0");
Convection.c:30:   input_float("comp_diffusivity",&(E->control.comp_diff),"0");
Convection.c:31:   input_string("comp_adv_method",E->control.comp_adv_method,NULL);
Convection.c:34:    if (E->control.composition && strcmp(E->control.comp_adv_method,"field")==0)
Convection.c:35:      E->next_buoyancy_field = PG_timestep;
Convection.c:36:    else if (E->control.composition && strcmp(E->control.comp_adv_method,"particle")==0)  {
Convection.c:37:      E->next_buoyancy_field = PG_timestep_particle;
Convection.c:40:      E->next_buoyancy_field = PG_timestep;
Convection.c:44:    E->special_process_new_buoyancy = twiddle_thumbs; 
Convection.c:45:    E->problem_settings = read_convection_settings;
Convection.c:46:    E->problem_derived_values = convection_derived_values;
Convection.c:47:    E->problem_allocate_vars = convection_allocate_memory;
Convection.c:48:    E->problem_boundary_conds = convection_boundary_conditions;
Convection.c:49:    E->problem_initial_fields = convection_initial_fields;
Convection.c:50:    E->problem_node_positions = node_locations;
Convection.c:51:    E->problem_update_node_positions = twiddle_thumbs;
Convection.c:52:    E->problem_update_bcs = twiddle_thumbs;
Convection.c:54:    sprintf(E->control.which_data_files,"Temp,Strf,Pres");
Convection.c:55:    sprintf(E->control.which_horiz_averages,"Temp,Visc,Vrms");
Convection.c:56:    sprintf(E->control.which_running_data,"Step,Time,");
Convection.c:57:    sprintf(E->control.which_observable_data,"Shfl");
Convection.c:71:    input_double("rayleigh",&(E->control.Ra_temp),"essential");
Convection.c:73:    E->data.ref_viscosity = E->data.grav_acc*E->data.density*E->data.therm_exp
Convection.c:74:                  *E->data.ref_temperature*E->sphere.ro_dim*E->sphere.ro_dim*E->sphere.ro_dim
Convection.c:75:                  /(E->control.Ra_temp*E->data.therm_diff);
Convection.c:77:    E->data.ref_viscosity /= (1.0 + E->data.surf_temp);
Convection.c:79:    input_double("rayleigh_comp",&(E->control.Ra_comp),"essential");
Convection.c:81:    density_diff=E->control.Ra_comp*E->data.ref_viscosity*E->data.therm_diff/(E->data.grav_acc*E->sphere.ro_dim*E->sphere.ro_dim*E->sphere.ro_dim);
Convection.c:83:    fprintf(E->fp,"Ra_temp=%.5e Ra_comp=%.5e ref_visc=%.5e density_diff=%.5e\n",E->control.Ra_temp,E->control.Ra_comp,E->data.ref_viscosity,density_diff);
Convection.c:85:    input_boolean("halfspace",&(E->convection.half_space_cooling),"off");
Convection.c:86:    input_float("halfspage",&(E->convection.half_space_age),"nodefault");
Convection.c:88:    input_int("temperature_blobs",&(E->convection.temp_blobs),"0");
Convection.c:89:    input_float_vector("temperature_blobx",E->convection.temp_blobs,E->convection.temp_blob_x);
Convection.c:90:    input_float_vector("temperature_bloby",E->convection.temp_blobs,E->convection.temp_blob_y);
Convection.c:91:    input_float_vector("temperature_blobz",E->convection.temp_blobs,E->convection.temp_blob_z);
Convection.c:92:    input_float_vector("temperature_blobsize",E->convection.temp_blobs,E->convection.temp_blob_radius);
Convection.c:93:    input_float_vector("temperature_blobDT",E->convection.temp_blobs,E->convection.temp_blob_T);
Convection.c:94:    input_float_vector("temperature_blobbg",E->convection.temp_blobs,E->convection.temp_blob_bg);
Convection.c:95:    input_int_vector("temperature_blobsticky",E->convection.temp_blobs,E->convection.temp_blob_sticky);
Convection.c:97:    input_int("temperature_zones",&(E->convection.temp_zones),"0");
Convection.c:98:    input_float_vector("temperature_zonex1",E->convection.temp_zones,E->convection.temp_zonex1);
Convection.c:99:    input_float_vector("temperature_zonex2",E->convection.temp_zones,E->convection.temp_zonex2);
Convection.c:100:    input_float_vector("temperature_zonez1",E->convection.temp_zones,E->convection.temp_zonez1);
Convection.c:101:    input_float_vector("temperature_zonez2",E->convection.temp_zones,E->convection.temp_zonez2);
Convection.c:102:    input_float_vector("temperature_zoney1",E->convection.temp_zones,E->convection.temp_zoney1);
Convection.c:103:    input_float_vector("temperature_zoney2",E->convection.temp_zones,E->convection.temp_zoney2);
Convection.c:104:    input_float_vector("temperature_zoney2",E->convection.temp_zones,E->convection.temp_zoney2);
Convection.c:105:    input_float_vector("temperature_zoney2",E->convection.temp_zones,E->convection.temp_zoney2);
Convection.c:106:    input_float_vector("temperature_zonehw",E->convection.temp_zones,E->convection.temp_zonehw);
Convection.c:107:    input_float_vector("temperature_zonemag",E->convection.temp_zones,E->convection.temp_zonemag);
Convection.c:108:    input_int_vector("temperature_zonesticky",E->convection.temp_zones,E->convection.temp_zone_sticky);
Convection.c:110:    input_int("num_perturbations",&(E->convection.number_of_perturbations),"0,0,32");
Convection.c:111:    input_float_vector("perturbmag",E->convection.number_of_perturbations,E->convection.perturb_mag);
Convection.c:112:    input_float_vector("ll",E->convection.number_of_perturbations,E->convection.perturb_ll);
Convection.c:113:    input_float_vector("mm",E->convection.number_of_perturbations,E->convection.perturb_mm);
Convection.c:115:    input_string("prevT",E->convection.old_T_file,"initialize");
Convection.c:118:		fprintf(stderr,"add %d %d\n",E->advection.markers_per_ele,E->mesh.dof);
Convection.c:120:    if (E->control.restart)    {
Convection.c:121:      input_int("restart_timesteps",&(E->monitor.solution_cycles),"0");
Convection.c:122:      input_string("oldfile",E->convection.old_T_file,"initialize");
Convection.c:124:			E->control.restart_frame = E->monitor.solution_cycles;
Convection.c:127:			E->control.restart_frame = 0;
Convection.c:171:    if(E->control.tidal_heating) {
Convection.c:176:    if(E->control.despin) {
Convection.c:181:		if(E->impacts.number > 0) {
Convection.c:183:			read_impacts(E,E->impacts.number);
Convection.c:245:    const int dims=E->mesh.nsd;
Convection.c:248:/*    sprintf(output_file,"%s/radialtemp",E->control.data_file);
Convection.c:253:    for(i=1;i<=E->mesh.noz;i++) {
Convection.c:265:    tbl = E->viscosity.zlith;
Convection.c:267:    tbl = E->sphere.rcomp;
Convection.c:268://    bbl = E->sphere.rcomp;
Convection.c:269:    bbl = E->sphere.ri + 0.0223;
Convection.c:270://    bbl = E->sphere.ri + 0.14;
Convection.c:273:    adtemp = inttemp + adgrad*(E->sphere.ro - E->sphere.ri)/E->sphere.ro;
Convection.c:276:    noy=E->mesh.noy;  
Convection.c:277:    noz=E->mesh.noz;  
Convection.c:278:    nox=E->mesh.nox;  
Convection.c:280:    para1 = E->data.surf_temp*E->data.ref_temperature + 0.4*E->data.ref_temperature; 
Convection.c:282:    tbase = (para1 - E->data.surf_temp*E->data.ref_temperature)/E->data.ref_temperature;
Convection.c:283:    tbase1 = (para1 + 200 - E->data.surf_temp*E->data.ref_temperature)/E->data.ref_temperature;
Convection.c:287:        mm = E->convection.perturb_mm[0];
Convection.c:288:        ll = E->convection.perturb_ll[0];
Convection.c:292:        con = (noz-1)/(E->sphere.ro-E->sphere.ri);
Convection.c:294:        con = E->convection.perturb_mag[0];
Convection.c:296:    if (E->control.restart==0 )    { 
Convection.c:302:                t1=E->X[1][node];
Convection.c:303:                r1=E->X[2][node];
Convection.c:305:                E->T[node] = 0.0;
Convection.c:306:                E->C[node] = 0.0;
Convection.c:310:                  E->T[node] = con*modified_plgndr_a(ll,mm,t1);
Convection.c:313:                E->T[node] = E->sphere.ri/(-E->sphere.ro+E->sphere.ri)*
Convection.c:315:                   sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:318:              E->T[node] = tbase
Convection.c:320:                   sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:325:              if (r1>=E->viscosity.zlith)
Convection.c:326:                E->T[node] = (r1-E->viscosity.zlith)/(E->sphere.ro-E->viscosity.zlith)*(0.0-tbase)+ tbase
Convection.c:327:               + con*modified_plgndr_a(ll,mm,t1)*sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:328:	      else  if (r1<=(E->sphere.ri+0.03))
Convection.c:329:                E->T[node] = (r1-E->sphere.ri)/(0.03)*(tbase-1.0)+ 1.0 +con*modified_plgndr_a(ll,mm,t1)*sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:331:                E->T[node] = tbase
Convection.c:333:                   sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:337:		  T0 = E->TB[2][((node-1)/E->mesh.noz)*E->mesh.noz];
Convection.c:338:                  E->T[node] = T0 + (E->sphere.ro-r1)/(E->sphere.ro-tbl) * (inttemp-T0) + con*modified_plgndr_a(ll,mm,t1)*sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:342:                  E->T[node] = inttemp + adgrad*(E->sphere.ro-r1)/E->sphere.ro + con*modified_plgndr_a(ll,mm,t1)*sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:345:                  E->T[node] = adtemp + (1.0-adtemp) * (bbl-r1)/(bbl-E->sphere.ri) + con*modified_plgndr_a(ll,mm,t1)*sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:347://		E->T[node] = radial_temp[k] + con*modified_plgndr_a(ll,mm,t1)*sin(M_PI*((r1-E->sphere.ri)/(E->sphere.ro-E->sphere.ri)));
Convection.c:350:              E->node[node] = E->node[node] | (INTX | INTZ | INTY);
Convection.c:354:      if (E->control.composition) {
Convection.c:355:         if (!(strcmp(E->control.comp_adv_method,"field")==0))
Convection.c:357:         else if ((strcmp(E->control.comp_adv_method,"field")==0))  {
Convection.c:358:            for(node=1;node<=E->mesh.nno;node++)  {
Convection.c:359:                  t1=E->X[1][node];
Convection.c:360:                  r1=E->X[2][node];
Convection.c:361:                  if (r1<=E->sphere.rcomp)
Convection.c:362:                     E->C[node] = 1.0;
Convection.c:364:                     E->C[node] = 0.0;
Convection.c:371:   else if (E->control.restart==1)  {
Convection.c:372:      process_restart_tc(E,E->mesh.levmax);
Convection.c:374:      if (E->control.composition && !(strcmp(E->control.comp_adv_method,"field")==0)) {
Convection.c:402:    E->advection.element[0] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:403:    E->advection.element[1] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:404:    E->advection.element_prev[0] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:405:    E->advection.element_prev[1] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:408:    p = pow((double)E->advection.markers_per_ele,(double)(1.0/E->mesh.dof));
Convection.c:409:    for (el=1;el<=E->mesh.nel;el++)  {
Convection.c:410:      dx = (E->X[1][E->ien[el].node[3]] - E->X[1][E->ien[el].node[1]])/p;
Convection.c:411:      dr = (E->X[2][E->ien[el].node[3]] - E->X[2][E->ien[el].node[1]])/p;
Convection.c:415:        E->XMC[1][node] = E->X[1][E->ien[el].node[1]] + dx*(i-0.5);
Convection.c:416:        E->XMC[2][node] = E->X[2][E->ien[el].node[1]] + dr*(j-0.5);
Convection.c:417:        E->CElement[node] = el;
Convection.c:418:        if (E->XMC[2][node]>E->sphere.rcomp){
Convection.c:419:              E->C12[node] = 0;
Convection.c:420:              E->C12f[node] = 0.0;
Convection.c:423:              E->C12[node] = 1;
Convection.c:424:              E->C12f[node] = 1.0;
Convection.c:429:    E->advection.markers = node;
Convection.c:431:    get_C_from_markers(E,E->C,E->CElement);
Convection.c:448:  sprintf(output_file,"%s/temp_comp.%d",E->convection.old_T_file,E->monitor.solution_cycles);
Convection.c:455:  //sscanf(input_s,"%d %d %g",&i,&E->advection.timesteps,&E->monitor.elapsed_time);
Convection.c:456:  sscanf(input_s,"%d %d %g %g",&i,&E->advection.timesteps,&E->monitor.elapsed_time,&E->monitor.deltah);
Convection.c:458:  if (E->control.composition)   {
Convection.c:460:    for (i=1;i<=E->mesh.NNO[lev];i++)   {
Convection.c:462:      sscanf(input_s,"%g %g %g %g",&E->T[i],&E->C[i],&t1,&t2);
Convection.c:463:      E->U[E->id[i].doff[1]]=t1;
Convection.c:464:      E->U[E->id[i].doff[2]]=t2;
Convection.c:467:    for (i=1;i<=E->mesh.NEL[lev];i++)   {
Convection.c:470:      E->P[i] = t1;
Convection.c:474:    for (i=1;i<=E->mesh.NNO[lev];i++)   {
Convection.c:476:      sscanf(input_s,"%g %g %g",&E->T[i],&t1,&t2);
Convection.c:477:      E->U[E->id[i].doff[1]]=t1;
Convection.c:478:      E->U[E->id[i].doff[2]]=t2;
Convection.c:479:      E->C[i]=0;
Convection.c:481:    for (i=1;i<=E->mesh.NEL[lev];i++)   {
Convection.c:484:      E->P[i] = t1;
Convection.c:489:  E->advection.timesteps = E->monitor.solution_cycles;
Convection.c:494:  sprintf(output_file,"%s/ave.%d",E->convection.old_T_file,
Convection.c:495:					E->monitor.solution_cycles);
Convection.c:501:	sscanf(input_s,"%d %d %g %g %g %g %g %g %g %g %g\n",&t0,&t1,&t2,&t3,&t4,&t4,&t5,&t6,&t7,&E->Total.melt_prod,&E->Total.bulk_comp);
Convection.c:506:  sprintf(output_file,"%s/esurf.%d",E->convection.old_T_file,
Convection.c:507:					E->monitor.solution_cycles);
Convection.c:511:  for (i=1;i<=E->mesh.elx;i++)  {
Convection.c:513:     sscanf(input_s,"%g %g %g",&t0,&E->slice.melt[i],&t1);
Convection.c:549:  ends = enodes[E->mesh.nsd];
Convection.c:559:  tidal_node = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Convection.c:560:  tidal_elem = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Convection.c:564:  sprintf(in_file,"%s/h2D.dat",E->control.data_file);
Convection.c:573:    tidal_reg[i] *= E->sphere.ro_dim*E->sphere.ro_dim
Convection.c:574:								/(E->data.density*E->data.Cp*E->data.DeltaT*E->data.therm_diff);
Convection.c:585:  for (e=1;e<=E->mesh.nel;e++) {  /* For each Citcom node */
Convection.c:592://	fprintf(stderr,"e %d %g %g\n",e,E->eco[e].centre[1],E->eco[e].centre[2]);
Convection.c:595:      if((theta[i] <= E->eco[e].centre[1]) && (theta[i+numr] >= E->eco[e].centre[1])) {
Convection.c:596://	fprintf(stderr,"Theta %d %g %g %g\n",i,theta[i],r[i],E->eco[e].centre[2]);
Convection.c:598:        if((r[i] <= E->eco[e].centre[2]) && (r[i+1] >= E->eco[e].centre[2])) {
Convection.c:622:    A_ll = (theta[ll] - E->eco[e].centre[1]) * (r[ll] - E->eco[e].centre[2]);
Convection.c:623:    A_ul = (theta[ul] - E->eco[e].centre[1]) * -(r[ul] - E->eco[e].centre[2]);
Convection.c:624:    A_lr = -(theta[lr] - E->eco[e].centre[1]) * (r[lr] - E->eco[e].centre[2]);
Convection.c:625:    A_ur = -(theta[ur] - E->eco[e].centre[1]) * -(r[ur] - E->eco[e].centre[2]);
Convection.c:640:fprintf(stderr,"%d %g %g %g\n\n",e,tidal_elem[e],E->eco[e].centre[1],E->eco[e].centre[2]);
Convection.c:649:  for (e=1;e<=E->mesh.nel;e++)  {
Convection.c:651:    E->heating_tidal[e] = tidal_elem[e];
Convection.c:653:    totaltidal += E->heating_tidal[e]*E->eco[e].area;
Convection.c:654:    totalvol += E->eco[e].area;
Convection.c:660:  if(E->control.shear_heating) {
Convection.c:668:    c_h *= E->sphere.ro_dim*E->sphere.ro_dim
Convection.c:669:						/ (E->data.density*E->data.Cp*E->data.DeltaT*E->data.therm_diff);
Convection.c:671:    for (e=1;e<=E->mesh.nel;e++) {
Convection.c:672:      ee = e + (e-1) / (E->mesh.elz); 
Convection.c:673:      if ((E->X[1][ee] >= theta_n) 
Convection.c:674:			&& (E->X[2][ee] >= (1.0 - d/E->sphere.ro_dim))) {
Convection.c:676:	/*E->heating_shear[e] = (2.0/(a*a)) 
Convection.c:677:		* exp(-(M_PI-E->X[1][ee])*(M_PI-E->X[1][ee]) / a*a);
Convection.c:680:	E->heating_shear[e] = c_h 
Convection.c:681:		* cos(M_PI/2.0 * (M_PI-E->X[1][ee]) / (M_PI-theta_n)) 
Convection.c:682:		* cos(M_PI/2.0 * (M_PI-E->X[1][ee]) / (M_PI-theta_n));
Convection.c:684:      else E->heating_shear[e] = 0.0;
Convection.c:693:  sprintf(output_file,"%s/heating_t.%d",E->control.data_file,E->monitor.solution_cycles);
Convection.c:696:  for (e=1;e<=E->mesh.nel;e++){
Convection.c:697:    fprintf(fp11,"%g %g %g %g\n",E->eco[e].centre[1],E->eco[e].centre[2],
Convection.c:698:	E->heating_tidal[e],E->heating_shear[e]);
Convection.c:741:  E->impacts.H_t     = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Convection.c:744:	fprintf(E->fp,"Read Impacts\n");
Convection.c:746:  input_int("impact_heating_from_file",&(E->impacts.heat_from_file),"0");
Convection.c:747:  if(E->impacts.heat_from_file)
Convection.c:748:      input_string("impact_heating_file",E->impacts.heating_file);
Convection.c:751:	sprintf(impact_file,"%s/impact_file",E->control.data_file);
Convection.c:753:  fprintf(E->fp,"%s\n",impact_file);
Convection.c:756:  fprintf(E->fp,"Starting age %f My\n",E->control.restart_age);
Convection.c:759:  input_float("impact_velocity",&(E->impacts.v),"15.0e3");
Convection.c:765:	ksi = C/(S*0.5*E->impacts.v);
Convection.c:766:	E->impacts.dT = (E->impacts.v*E->impacts.v/4.0)/(2.0*E->data.Cp)
Convection.c:775:    sscanf(input_s,"%f %f %f %f",&(E->impacts.t[i]),&(E->impacts.f[i]),
Convection.c:776:				&(E->impacts.th[i]),&(E->impacts.size[i]));
Convection.c:778:    fprintf(E->fp,"%f %f %f %f %f\n",E->impacts.t[i],E->impacts.th[i],
Convection.c:779:			E->impacts.f[i],E->impacts.v,E->impacts.size[i]);
Convection.c:780:    fprintf(stderr,"%f %f %f %f %f\n",E->impacts.t[i],E->impacts.th[i],
Convection.c:781:			E->impacts.f[i],E->impacts.v,E->impacts.size[i]);
Convection.c:787:  E->impacts.dT *= 1.0/E->data.DeltaT;
Convection.c:788:  start = E->control.restart_age/1.0e3;
Convection.c:790:  for(i=0;i<E->impacts.number;i++) {
Convection.c:791:    E->impacts.t[i] = (start - E->impacts.t[i]) * 1.0e9;
Convection.c:792:    E->impacts.t[i] *= (86400.0*365.25) * E->data.therm_diff
Convection.c:793:                        / (E->sphere.ro_dim*E->sphere.ro_dim);
Convection.c:794:    E->impacts.t[i] += E->monitor.elapsed_time;
Convection.c:795:    E->impacts.th[i] = (90.0 - E->impacts.th[i]) / rad;
Convection.c:796:    E->impacts.f[i] *= 1.0/rad; 
Convection.c:797:    E->impacts.flag[i] = 0;
Convection.c:800:    if((E->impacts.t[i] < E->monitor.elapsed_time) || (E->impacts.t[i] < 0.0) ){
Convection.c:801:        E->impacts.size[i] = 0.0;
Convection.c:802:        E->impacts.flag[i] = 1;
Convection.c:805:		fprintf(E->fp,"%e %e %f %f %f %d\n",start,E->impacts.t[i],E->impacts.th[i],E->impacts.f[i],E->impacts.size[i],E->impacts.flag[i]);
Convection.c:827:	fprintf(E->fp,"Solidus: \n");
Convection.c:828:	for(k=1;k<=E->mesh.noz;k++) {
Convection.c:829:    z = (1.0 - E->X[2][k])*E->sphere.ro_dim;
Convection.c:830:    P = E->data.density*E->data.grav_acc*z/1.0e9;
Convection.c:833:      E->solidus[k] = 1374.0 + 130.0*P - 5.6*P*P;
Convection.c:835:      E->solidus[k] = 2017.0 + 10.0*P;
Convection.c:840:    E->solidus[k] = 1358.7 + 132.9*P -5.1*P*P;
Convection.c:841:    E->lherzliq[k] = 1748.0 + 80.0*P -3.2*P*P;
Convection.c:842:    E->liquidus[k] = 2053.0 + 45.0*P -2.0*P*P;
Convection.c:846:    E->solidus[k] = 273.0;  /* P-dep v. small on Enc.*/
Convection.c:847:    E->liquidus[k] = 273.0;  /* P-dep v. small on Enc.*/
Convection.c:850:    E->solidus[k] = E->solidus[k]/E->data.DeltaT - E->data.surf_temp;
Convection.c:851://    E->lherzliq[k] = E->lherzliq[k]/E->data.DeltaT - E->data.surf_temp;
Convection.c:852:    E->liquidus[k] = E->liquidus[k]/E->data.DeltaT - E->data.surf_temp;
Convection.c:854:	/*	fprintf(E->fp,"%d %e %f %f %f %f \n",k,z,P,E->solidus[k],
Convection.c:855:																		E->lherzliq[k],E->liquidus[k]);
Convection.c:857:		fprintf(E->fp,"%d %e %f %f %f\n",k,z,P,E->solidus[k],E->liquidus[k]);
Convection.c:877:  double mu = E->data.rigidity;
Convection.c:878:  double eta = E->data.ref_viscosity;
Convection.c:890:  E->control.despun = 0;	/* Flag for completion of despinning */
Convection.c:892:	E->data.mass = ((E->data.density_core-E->data.density) * pow(E->sphere.ri,3) 
Convection.c:893:		  + E->data.density) * pow(E->sphere.ro_dim,3) * 4.0*(qpi)/3.0;
Convection.c:894:	vol = pow(E->sphere.ro_dim,3) * 4.0*(qpi)/3.0;
Convection.c:897:  E->data.moi *= (E->data.mass*E->sphere.ro_dim*E->sphere.ro_dim); 
Convection.c:901:		E->data.density_core,E->data.density,E->sphere.ro_dim,E->sphere.ri,
Convection.c:902:		E->data.mass,E->data.moi);
Convection.c:914:  semimajor_final = powl((E->data.grav_const * E->data.mass_primary)
Convection.c:915:														/(E->data.rot_final*E->data.rot_final),(1.0/3.0));
Convection.c:917:  Ls1 = E->data.moi*E->data.rot_init;
Convection.c:918:  Ls2 = E->data.moi*E->data.rot_final;
Convection.c:919:	Lo2 = E->data.mass*E->data.rot_final*semimajor_final*semimajor_final;
Convection.c:923:   semimajor_init = powl((Lo1/E->data.mass),2) 
Convection.c:924:		 											/ (E->data.grav_const * E->data.mass_primary);
Convection.c:927:/*  semimajor_init = pow((E->data.moi*(E->data.rot_final - E->data.rot_init)
Convection.c:928:																															/ E->data.mass + 
Convection.c:929:					E->data.semimajor_axis*E->data.semimajor_axis*E->data.rot_final),2) 
Convection.c:930:	  								/ (E->data.grav_const * E->data.mass_primary);
Convection.c:932:	E->data.semimajor_axis = semimajor_init;
Convection.c:937:  E->data.mean_motion = sqrtl((E->data.grav_const * E->data.mass_primary) / 
Convection.c:947:	Es1 =  E->data.moi*E->data.rot_init*E->data.rot_init /2.0;
Convection.c:948:	Es2 =  E->data.moi*E->data.rot_final*E->data.rot_final /2.0;
Convection.c:949:	Eo1 = - E->data.grav_const*E->data.mass_primary*E->data.mass 
Convection.c:951:	Eo2 = - E->data.grav_const*E->data.mass_primary*E->data.mass 
Convection.c:954:  E->data.Ediss_total = ( E->data.moi*(E->data.rot_init*E->data.rot_init 
Convection.c:955:								  					- E->data.rot_final*E->data.rot_final) 
Convection.c:956:	  										- E->data.grav_const*E->data.mass_primary*E->data.mass 
Convection.c:959:	E->data.Ediss = 0.0; /* Initialize running total */
Convection.c:962:		E->data.rot_final,E->data.rot_init,E->data.mass_primary,
Convection.c:963:		semimajor_final,semimajor_init,E->data.mean_motion,E->data.Ediss_total);
Convection.c:967:	fprintf(E->fp,"rot2 %g rot1 %g M %g \n af %.10Lg ai %.7Lg n %Lg E %g\n",
Convection.c:968:		E->data.rot_final,E->data.rot_init,E->data.mass_primary,
Convection.c:969:		semimajor_final,semimajor_init,E->data.mean_motion,E->data.Ediss_total);
Convection.c:970:	fprintf(E->fp,"Es1 %g Es2 %g Eo1 %g Eo2 %g\n",Es1,Es2,Eo1,Eo2);
Convection.c:971:	fprintf(E->fp,"Es1 - Es2 %g Eo1 - Eo2 %g\n",Es1-Es2,Eo1-Eo2);
Convection.c:978:  omega = E->data.rot_init;
Convection.c:983:											/ (2*E->data.grav_acc*E->data.density*E->sphere.ro_dim));
Convection.c:985:  drotdt = (3.0 * -cimag(c_k2) * E->data.grav_const * E->data.mass_primary 
Convection.c:986:							* E->data.mass_primary * pow((E->sphere.ro_dim),5)) 
Convection.c:987:							/ (E->data.moi * pow(E->data.semimajor_axis,6));
Convection.c:991:  E->data.rotation = E->data.rot_init;
Convection.c:992:  E->data.despin_rate = drotdt;
Convection.c:995:	E->data.flattening = 1.25*E->data.rot_init*E->data.rot_init*E->sphere.ro_dim 
Convection.c:996:													/ E->data.grav_acc;
Convection.c:1000:  E->control.despin_timescale = omega / drotdt;
Convection.c:1001:  E->power_despin_global = (E->data.Ediss_total / E->control.despin_timescale);
Convection.c:1004:  E->power_despin_ave = E->power_despin_global / ((4.0*M_PI/3.0)
Convection.c:1005:                    *pow(E->sphere.ro_dim,3) * (1.0 - pow(E->sphere.ri,3)) ); 
Convection.c:1007:							E->data.Ediss_total, E->power_despin_global, E->power_despin_ave);
Convection.c:1009:							E->control.despin_timescale,E->control.despin_timescale/3.15e7);
Convection.c:1012:  E->power_despin_global *= 1.0/(E->data.density*E->data.Cp*E->data.DeltaT
Convection.c:1013:					*E->data.therm_diff*E->sphere.ro_dim);
Convection.c:1014:  E->power_despin_ave *= (3.0/(4.0*M_PI*(1.0 - pow(E->sphere.ri,3))))
Convection.c:1015:		* E->power_despin_global;
Convection.c:1016:  E->control.despin_timescale *= E->data.therm_diff 
Convection.c:1017:				/ (E->sphere.ro_dim*E->sphere.ro_dim);
Convection.c:1035:    E->advection.element[0] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:1036:    E->advection.element[1] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:1037:    E->advection.element_prev[0] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:1038:    E->advection.element_prev[1] =(int *)malloc((E->mesh.nel+1)*sizeof(int));
Convection.c:1039: sprintf(output_file,"%s/traces.%d",E->convection.old_T_file,E->monitor.solution_cycles);
Convection.c:1044:   sscanf(input_s,"%d %d %g",&E->advection.markers,
Convection.c:1045:	 				&E->advection.timesteps,&E->monitor.elapsed_time);
Convection.c:1047:   for (i=1;i<=E->advection.markers;i++)  {
Convection.c:1049:     /*sscanf(input_s,"%g %g %d %d",&E->XMC[1][i],&E->XMC[2][i],
Convection.c:1050:						&E->CElement[i],&E->C12[i]);*/
Convection.c:1051:     sscanf(input_s,"%g %g %d %g",&E->XMC[1][i],&E->XMC[2][i],
Convection.c:1052:						&E->CElement[i],&E->C12f[i]);
Convection.c:1055:   for (i=1;i<=E->mesh.nel;i++)  {
Convection.c:1057:     sscanf(input_s,"%g %d %d",&E->CE[i],&t0,&t1);
Convection.c:1060:  E->advection.timesteps = E->monitor.solution_cycles;
Convection.c:1062:	p_to_centres(E,E->C,E->CE,E->mesh.levmax);
Convection.c:1063:  get_C_from_markers(E,E->C,E->CElement);
Convection.c:1065:  	//			get_markers_from_C(E,E->CE,E->CElement);
Drive_solvers.c:47:    const int nno = E->mesh.nno;
Drive_solvers.c:48:    const int nel = E->mesh.nel;
Drive_solvers.c:49:    const int nnov = E->mesh.nnov;
Drive_solvers.c:50:    const int neq = E->mesh.neq;
Drive_solvers.c:51:    const int vpts = vpoints[E->mesh.nsd];
Drive_solvers.c:52:    const int dims = E->mesh.nsd;
Drive_solvers.c:66:    E->monitor.elapsed_time_vsoln1 =  E->monitor.elapsed_time_vsoln;
Drive_solvers.c:67:    E->monitor.elapsed_time_vsoln = E->monitor.elapsed_time;
Drive_solvers.c:71:    velocities_conform_bcs(E,E->U);
Drive_solvers.c:79:      if(E->viscosity.update_allowed)
Drive_solvers.c:80:          get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:86:      Udot_mag = kineticE(E,E->U,E->mesh.levmax);
Drive_solvers.c:87:      fprintf(E->fp,"%g %.6e \n",E->monitor.elapsed_time,Udot_mag);
Drive_solvers.c:88:      fflush(E->fp);
Drive_solvers.c:90:      fprintf(stderr,"kinetic energy= %.7e at time= %g for step %d\n",Udot_mag,E->monitor.elapsed_time,E->monitor.solution_cycles);
Drive_solvers.c:93:      if (  E->viscosity.SDEPV  )   {
Drive_solvers.c:95:          delta_U[i] = E->U[i] - oldU[i]; 
Drive_solvers.c:96:          oldU[i] = E->U[i];
Drive_solvers.c:98:        Udot_mag  = sqrt(fvdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:99:        dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax); 
Drive_solvers.c:102:          fprintf(E->fp,"Stress dependent viscosity: DUdot = %.4e (%.4e) for iteration %d\n",dUdot_mag,Udot_mag,count);
Drive_solvers.c:103:          fflush(E->fp); 
Drive_solvers.c:107:      } while((count < 50) && (dUdot_mag>E->viscosity.sdepv_misfit) && E->viscosity.SDEPV);
Drive_solvers.c:109:          fflush(E->fp); 
Element_calculations.c:50:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:51:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:52:  const int neq=E->mesh.neq;
Element_calculations.c:53:  const int npno=E->mesh.npno;
Element_calculations.c:54:  const int nel=E->mesh.nel;
Element_calculations.c:55:  const int lev=E->mesh.levmax;
Element_calculations.c:58:    E->F[a] = 0.0;
Element_calculations.c:61:    E->H[a]=0.0;*/
Element_calculations.c:67:	    E->H[e] = elt_h[0];  /* due to single pressure node per element */
Element_calculations.c:70:       a1=E->lm[e].node[a].doff[1];
Element_calculations.c:72:       E->F[a1] += elt_f[p];
Element_calculations.c:73:       a2=E->lm[e].node[a].doff[2];
Element_calculations.c:74:       E->F[a2] += elt_f[p+1];
Element_calculations.c:76:         a3=E->lm[e].node[a].doff[3];
Element_calculations.c:77:         E->F[a3] += elt_f[p+2];
Element_calculations.c:83:   strip_bcs_from_residual(E,E->F,lev);
Element_calculations.c:119:    const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:120:    const int vpts=vpoints[E->mesh.nsd];
Element_calculations.c:121:    const int ppts=ppoints[E->mesh.nsd];
Element_calculations.c:122:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:123:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:133:	W[nint] = g_point[nint].weight[dims-1] * dOmega.vpt[nint] * E->EVI[level][(el-1)*vpts+nint];
Element_calculations.c:148:                            +(GNx.vpt[GNVXINDEX(1,a,k)]-xk[2][k]*E->N.vpt[GNVINDEX(a,k)])*
Element_calculations.c:149:                             (GNx.vpt[GNVXINDEX(1,b,k)]-xk[2][k]*E->N.vpt[GNVINDEX(b,k)]) 
Element_calculations.c:151:                             E->N.vpt[GNVINDEX(a,k)]*E->N.vpt[GNVINDEX(b,k)] );
Element_calculations.c:154:                             2.0*xk[2][k]*GNx.vpt[GNVXINDEX(0,a,k)]*E->N.vpt[GNVINDEX(b,k)]
Element_calculations.c:155:                            +(GNx.vpt[GNVXINDEX(1,a,k)]-xk[2][k]*E->N.vpt[GNVINDEX(a,k)])*
Element_calculations.c:157:                              E->N.vpt[GNVINDEX(a,k)]*E->N.vpt[GNVINDEX(b,k)] );
Element_calculations.c:160:                             2.0*xk[2][k]*E->N.vpt[GNVINDEX(a,k)]*GNx.vpt[GNVXINDEX(0,b,k)]
Element_calculations.c:162:                            (GNx.vpt[GNVXINDEX(1,b,k)]-xk[2][k]*E->N.vpt[GNVINDEX(b,k)]) 
Element_calculations.c:163:                            +2.0*xk[1][k]*xk[2][k]*xk[2][k]*E->N.vpt[GNVINDEX(a,k)]*E->N.vpt[GNVINDEX(b,k)] );
Element_calculations.c:166:                             2.0*xk[2][k]*xk[2][k]*E->N.vpt[GNVINDEX(a,k)]*E->N.vpt[GNVINDEX(b,k)]
Element_calculations.c:169:                            +2.0*xk[2][k]*xk[2][k]*E->N.vpt[GNVINDEX(a,k)]*E->N.vpt[GNVINDEX(b,k)] );
Element_calculations.c:207:  if(E->control.NMULTIGRID||E->control.NASSEMBLE)
Element_calculations.c:237:  const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:238:  const int ends=enodes[E->mesh.nsd]; 
Element_calculations.c:239:  const int dims=E->mesh.nsd,dofs=E->mesh.dof; 
Element_calculations.c:240:  const int nel=E->mesh.NEL[level];
Element_calculations.c:241:  const int neq=E->mesh.NEQ[level];
Element_calculations.c:249:	a1 = E->LMD[level][e].node[a].doff[1];   
Element_calculations.c:250:	a2 = E->LMD[level][e].node[a].doff[2];   
Element_calculations.c:251:	if(dims ==3 ) a3 = E->LMD[level][e].node[a].doff[3];   
Element_calculations.c:257:	                E->elt_k[level][e].k[ii  ] * 
Element_calculations.c:258:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:259:	              + E->elt_k[level][e].k[ii+1] *
Element_calculations.c:260:		        u[E->LMD[level][e].node[b].doff[2]]; 
Element_calculations.c:263:		        E->elt_k[level][e].k[ii+n  ] * 
Element_calculations.c:264:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:265:		      + E->elt_k[level][e].k[ii+n+1] * 
Element_calculations.c:266:			u[E->LMD[level][e].node[b].doff[2]]; 
Element_calculations.c:271:		        E->elt_k[level][e].k[ii] * 
Element_calculations.c:272:			u[E->LMD[level][e].node[b].doff[1]]   
Element_calculations.c:273:		      + E->elt_k[level][e].k[ii+1] * 
Element_calculations.c:274:			u[E->LMD[level][e].node[b].doff[2]]   
Element_calculations.c:275:		      + E->elt_k[level][e].k[ii+2] * 
Element_calculations.c:276:			u[E->LMD[level][e].node[b].doff[3]]; 
Element_calculations.c:279:		        E->elt_k[level][e].k[ii+n] * 
Element_calculations.c:280:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:281:		      + E->elt_k[level][e].k[ii+n+1] * 
Element_calculations.c:282:			u[E->LMD[level][e].node[b].doff[2]]   
Element_calculations.c:283:		      + E->elt_k[level][e].k[ii+n+2] * 
Element_calculations.c:284:			u[E->LMD[level][e].node[b].doff[3]]; 
Element_calculations.c:287:		        E->elt_k[level][e].k[ii+n+n] * 
Element_calculations.c:288:			u[E->LMD[level][e].node[b].doff[1]] 
Element_calculations.c:289:		      + E->elt_k[level][e].k[ii+n+n+1] * 
Element_calculations.c:290:			u[E->LMD[level][e].node[b].doff[2]]   
Element_calculations.c:291:		      + E->elt_k[level][e].k[ii+n+n+2] * 
Element_calculations.c:292:			u[E->LMD[level][e].node[b].doff[3]]; 
Element_calculations.c:327:    const int neq=E->mesh.NEQ[level];
Element_calculations.c:328:    const int nno=E->mesh.NNO[level];
Element_calculations.c:329:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:339:	    if(E->NODE[level][e] & OFFSIDE) 
Element_calculations.c:341:	     eqn1=E->ID[level][e].doff[1];
Element_calculations.c:342:	     eqn2=E->ID[level][e].doff[2];
Element_calculations.c:343:	     eqn3=E->ID[level][e].doff[3];
Element_calculations.c:349:	     max_eqn = E->Node_eqn[level][e+1]-E->Node_eqn[level][e];
Element_calculations.c:351:	     C=E->Node_map[level] + E->Node_eqn[level][e];
Element_calculations.c:352:	     B1=E->Eqn_k[level]+E->Node_k_id[level][e];
Element_calculations.c:353:	     B2=E->Eqn_k[level]+E->Node_k_id[level][e]+max_eqn;
Element_calculations.c:354:	     B3=E->Eqn_k[level]+E->Node_k_id[level][e]+2*max_eqn;
Element_calculations.c:364:	    if(E->NODE[level][e] & OFFSIDE) 
Element_calculations.c:366:	    eqn1=E->ID[level][e].doff[1];
Element_calculations.c:367:	    eqn2=E->ID[level][e].doff[2];
Element_calculations.c:372:	    max_eqn = E->Node_eqn[level][e+1]-E->Node_eqn[level][e];
Element_calculations.c:374:	    C=E->Node_map[level] + E->Node_eqn[level][e];
Element_calculations.c:375:	    B1=E->Eqn_k[level]+E->Node_k_id[level][e];
Element_calculations.c:376:	    B2=E->Eqn_k[level]+E->Node_k_id[level][e]+max_eqn;
Element_calculations.c:402:    const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:403:    const int dims=E->mesh.nsd;
Element_calculations.c:404:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:408:	    a1 = E->LMD[level][el].node[a].doff[1];
Element_calculations.c:410:	    E->BI[level][a1] += elt_k[p*n+p];  
Element_calculations.c:413:	    a2 = E->LMD[level][el].node[a].doff[2];
Element_calculations.c:415:	    E->BI[level][a2] += elt_k[p*n+p];  
Element_calculations.c:419:	        a1 = E->LMD[level][el].node[a].doff[3];
Element_calculations.c:421:	        E->BI[level][a1] += elt_k[p*n+p];  
Element_calculations.c:438:    npno = E->mesh.NPNO[level];
Element_calculations.c:439:    neq=E->mesh.NEQ[level];
Element_calculations.c:442:	E->BPI[level][e]=1.0;
Element_calculations.c:444:    if(!E->control.precondition)
Element_calculations.c:450:	    E->BPI[level][e] = 1.0/BU;
Element_calculations.c:452:	    E->BPI[level][e] = 1.0;
Element_calculations.c:471:    const int nel=E->mesh.NEL[level];
Element_calculations.c:472:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:473:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:474:    const int npno=E->mesh.NPNO[level];
Element_calculations.c:483:	    j1= E->LMD[level][e].node[a].doff[1];
Element_calculations.c:484:	    j2= E->LMD[level][e].node[a].doff[2];
Element_calculations.c:485:	    j3= E->LMD[level][e].node[a].doff[3];
Element_calculations.c:486:	    /* for(b=0;b<ploc_mat_size[E->mesh.nsd];b++) */
Element_calculations.c:487:	    divU[e] += E->elt_del[level][e].g[p  ][0] * U[j1]
Element_calculations.c:488:	             + E->elt_del[level][e].g[p+1][0] * U[j2]
Element_calculations.c:489:	             + E->elt_del[level][e].g[p+2][0] * U[j3];
Element_calculations.c:496:	    j1= E->LMD[level][e].node[a].doff[1];
Element_calculations.c:497:	    j2= E->LMD[level][e].node[a].doff[2];
Element_calculations.c:498:	    /* for(b=0;b<ploc_mat_size[E->mesh.nsd];b++) */
Element_calculations.c:499:	    divU[e] += E->elt_del[level][e].g[p  ][0] * U[j1]
Element_calculations.c:500:	             + E->elt_del[level][e].g[p+1][0] * U[j2];
Element_calculations.c:523:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:524:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:526:  nel=E->mesh.NEL[lev];
Element_calculations.c:527:  neq=E->mesh.NEQ[lev];
Element_calculations.c:539:             j1=E->LMD[lev][e].node[a].doff[1];
Element_calculations.c:540:             j2=E->LMD[lev][e].node[a].doff[2];
Element_calculations.c:541:		        /*for(b=0;b<ploc_mat_size[E->mesh.nsd];b++)  */ 
Element_calculations.c:542:             gradP[j1] += E->elt_del[lev][e].g[p][0] * P[e];
Element_calculations.c:543:             gradP[j2] += E->elt_del[lev][e].g[p+1][0] * P[e];
Element_calculations.c:545:               j1=E->LMD[lev][e].node[a].doff[3];
Element_calculations.c:546:               gradP[j1] += E->elt_del[lev][e].g[p+2][0] * P[e];
Element_calculations.c:569:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:570:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:572:    npno=E->mesh.NPNO[level];
Element_calculations.c:581:      j=E->LMD[level][e].node[a].doff[1];
Element_calculations.c:582:      gradP[p] += E->BI[level][j]*E->elt_del[level][e].g[p][0];
Element_calculations.c:584:      j=E->LMD[level][e].node[a].doff[2];
Element_calculations.c:585:      gradP[p+1] += E->BI[level][j]*E->elt_del[level][e].g[p+1][0];
Element_calculations.c:588:        j=E->LMD[level][e].node[a].doff[3];
Element_calculations.c:589:        gradP[p+2] += E->BI[level][j]*E->elt_del[level][e].g[p+2][0];
Element_calculations.c:603:      divU +=E->elt_del[level][e].g[p][0] * gradP[p];	    
Element_calculations.c:604:      divU +=E->elt_del[level][e].g[p+1][0] * gradP[p+1];
Element_calculations.c:606:        divU +=E->elt_del[level][e].g[p+2][0] * gradP[p+2];
Element_calculations.c:632:   const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:642:       elt_del[p  ][0]=-(GNx.ppt[GNPXINDEX(0,a,1)]+xk[2][1]*xk[1][1]*E->N.ppt[GNPINDEX(a,1)])*aaa;
Element_calculations.c:643:       elt_del[p+1][0]=-(GNx.ppt[GNPXINDEX(1,a,1)]+xk[2][1]*2.0*E->N.ppt[GNPINDEX(a,1)])*aaa;
Element_calculations.c:675:  for(i=1;i<=E->mesh.nsd;i++)
Element_calculations.c:676:    { for(a=1;a<=enodes[E->mesh.nsd];a++)
Element_calculations.c:677:	{ if (E->node[E->ien[el].node[a]] & type)
Element_calculations.c:679:		{  get_elt_g(E,el,elt_g,E->mesh.levmax);
Element_calculations.c:683:	      p=E->mesh.nsd*(a-1) + i - 1;
Element_calculations.c:684:	      for(b=1;b<=pnodes[E->mesh.nsd];b++)
Element_calculations.c:686:		  elt_h[q] -= elt_g[p][q] * E->VB[i][E->ien[el].node[a]];
Element_calculations.c:729:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:734:  get_global_shape_fn(E,el,&GN,&GNx,&dOmega,xk,0,E->mesh.levmax);
Element_calculations.c:746:	    force[p] = E->buoyancy[E->ien[el].node[p]];
Element_calculations.c:749:	  nodea=E->ien[el].node[a];
Element_calculations.c:755:		     force_at_gs[j] += force[k] * E->N.vpt[GNVINDEX(k,j)] ;
Element_calculations.c:759:		 elt_f[p] += force_at_gs[j] * E->N.vpt[GNVINDEX(a,j)]
Element_calculations.c:769:		      nodeb=E->ien[el].node[b];
Element_calculations.c:770:		      if ((E->node[nodeb] & type) && (E->VB[j][nodeb] != 0.0)){
Element_calculations.c:772:			      get_elt_k(E,el,elt_k,E->mesh.levmax,penalty);
Element_calculations.c:777:			      elt_f[p] -= elt_k[p*n+q] * E->VB[j][nodeb];
Element_calculations.c:778:/* printf("el %d: dirn=%d, vbc found at node %d of %g\n",el,j,b,E->VB[j][nodeb]);*/
Element_calculations.c:808:     const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:809:     const int ends=enodes[E->mesh.nsd];
Element_calculations.c:810:     const int vpts=vpoints[E->mesh.nsd];
Element_calculations.c:811:     const int dims=E->mesh.nsd;
Element_calculations.c:816:	  Visc += E->EVI[level][(el-1)*vpts+a];
Element_calculations.c:821:        nodea=E->IEN[level][el].node[a];
Element_calculations.c:823:           nodeb=E->IEN[level][el].node[b];      /* for Kab dims*dims  */
Element_calculations.c:825:	   elt_k[i  ] += Visc*E->control.augmented*
Element_calculations.c:826:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:827:		      E->elt_del[level][el].g[p[b]][0];   /*for 11 */
Element_calculations.c:828:	   elt_k[i+1] += Visc*E->control.augmented*
Element_calculations.c:829:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:830:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 12 */
Element_calculations.c:831:	   elt_k[i+n] += Visc*E->control.augmented*          
Element_calculations.c:832:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:833:		      E->elt_del[level][el].g[p[b]][0];    /* for 21 */
Element_calculations.c:834:	   elt_k[i+n+1] += Visc*E->control.augmented*
Element_calculations.c:835:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:836:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 22 */
Element_calculations.c:839:	       elt_k[i+2] += Visc*E->control.augmented*
Element_calculations.c:840:	              E->elt_del[level][el].g[p[a]][0]*
Element_calculations.c:841:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 13 */
Element_calculations.c:842:	       elt_k[i+n+2] += Visc*E->control.augmented*
Element_calculations.c:843:	              E->elt_del[level][el].g[p[a]+1][0]*
Element_calculations.c:844:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 23 */
Element_calculations.c:845:	       elt_k[i+n+n] += Visc*E->control.augmented*
Element_calculations.c:846:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:847:		      E->elt_del[level][el].g[p[b]][0];    /* for 31 */
Element_calculations.c:848:	       elt_k[i+n+n+1] += Visc*E->control.augmented*
Element_calculations.c:849:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:850:		      E->elt_del[level][el].g[p[b]+1][0];  /* for 32 */
Element_calculations.c:851:	       elt_k[i+n+n+2] += Visc*E->control.augmented*
Element_calculations.c:852:	              E->elt_del[level][el].g[p[a]+2][0]*
Element_calculations.c:853:		      E->elt_del[level][el].g[p[b]+2][0];  /* for 33 */
General_matrix_functions.c:146:    const int n=E->mesh.NPNO[lev];
General_matrix_functions.c:160:    const int n=E->mesh.npno;
General_matrix_functions.c:179:    const int n = E->mesh.NEQ[level];
General_matrix_functions.c:203:    const int n = E->mesh.NEQ[level];
General_matrix_functions.c:225:  n = E->mesh.NEQ[level];
General_matrix_functions.c:245:  n = E->mesh.NEQ[level];
General_matrix_functions.c:290:    for(e=1;e<=E->mesh.nel;e++)
General_matrix_functions.c:291:      for(i=1;i<=vpoints[E->mesh.nsd];i++)
General_matrix_functions.c:292:	{ j=E->ien[e].node[i];
General_matrix_functions.c:293:	  domega =  E->ECO[E->mesh.levmax][e].area;
General_matrix_functions.c:306:    for(e=1;e<=E->mesh.nel;e++)
General_matrix_functions.c:307:      for(i=1;i<=vpoints[E->mesh.nsd];i++)
General_matrix_functions.c:308:	{ j=E->ien[e].node[i];
General_matrix_functions.c:309:	  domega =  E->ECO[E->mesh.levmax][e].area;
General_matrix_functions.c:394:    neq  = E->mesh.NEQ[high_lev];
General_matrix_functions.c:395:    gneq  = E->mesh.NEQ[high_lev];
General_matrix_functions.c:401:	E->control.total_iteration_cycles = 0;
General_matrix_functions.c:402:	E->control.total_v_solver_calls = 0;
General_matrix_functions.c:403:	for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) {
General_matrix_functions.c:417:    acc = max(acc,r0*E->control.accuracy);
General_matrix_functions.c:423:    if (!(E->control.NMULTIGRID || E->control.EMULTIGRID)) {
General_matrix_functions.c:424:	    cycles = E->control.v_steps_low;
General_matrix_functions.c:452:        fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,count,acc);
General_matrix_functions.c:462:/*            fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,count,acc); */
General_matrix_functions.c:463:/*            } while (residual > acc && count<E->control.max_vel_iterations);
General_matrix_functions.c:478:    if(E->control.print_convergence)   {
General_matrix_functions.c:479:	fprintf(E->fp,"%s residual (%03d)(%03d) = %.3e from %.3e to %.3e in %5.2f secs \n",
General_matrix_functions.c:481:		fflush(E->fp);
General_matrix_functions.c:490:    if(E->control.verbose)  {
General_matrix_functions.c:492:	for(i=E->mesh.levmax;i>=E->mesh.levmin;i--) {
General_matrix_functions.c:497:	printf("projection time = %g\n",E->monitor.cpu_time_on_mg_maps);
General_matrix_functions.c:501:    E->control.total_iteration_cycles += count;
General_matrix_functions.c:502:    E->control.total_v_solver_calls += 1;
General_matrix_functions.c:534:    const int levmin = E->mesh.levmin; 
General_matrix_functions.c:535:    const int levmax = E->mesh.levmax; 
General_matrix_functions.c:545:	for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) { 
General_matrix_functions.c:546:	    vel[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:547:	    res[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:548:	    rhs[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:549:	    fl [i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:550:	    del_vel[i]=(double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:551:	    AU[i] = (double *)malloc((E->mesh.NEQ[i] + 2)*sizeof(double));
General_matrix_functions.c:556:    Vnmax = E->control.mg_cycle;
General_matrix_functions.c:558:    for(j=0;j<E->mesh.NEQ[levmax];j++)
General_matrix_functions.c:570:    cycles = E->control.v_steps_low;
General_matrix_functions.c:581:      for(j=0;j<E->mesh.NEQ[lev];j++)
General_matrix_functions.c:589:            cycles=((dlev==levmax)?E->control.v_steps_high:E->control.down_heavy); 
General_matrix_functions.c:593:	    for(i=0;i<E->mesh.NEQ[dlev];i++)
General_matrix_functions.c:603:       cycles = E->control.v_steps_low;
General_matrix_functions.c:608:            cycles=((ulev==levmax)?E->control.v_steps_high:E->control.up_heavy);
General_matrix_functions.c:617:	    for(i=0;i<E->mesh.NEQ[ulev];i++)
General_matrix_functions.c:621:                for(i=0;i<E->mesh.NEQ[ulev];i++)   {
General_matrix_functions.c:630:    for(j=0;j<E->mesh.NEQ[levmax];j++)   {
General_matrix_functions.c:635:    residual = sqrt(vselfdot(E,F,levmax)/E->mesh.NEQ[levmax]);
General_matrix_functions.c:676:    const int mem_lev=E->mesh.levmax;
General_matrix_functions.c:677:    const int high_neq = E->mesh.NEQ[level];
General_matrix_functions.c:682:	r0 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:683:	r1 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:684:	r2 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:685:	z0 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:686:	z1 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:687:	p1 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:688:	p2 = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:689:	Ap = (double *)malloc((1+E->mesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:698:    residual = sqrt(vdot(E,r1,r1,level)/E->mesh.NEQ[level]);
General_matrix_functions.c:706:	    z1[i] = E->BI[level][i] * r1[i];
General_matrix_functions.c:736:	residual = sqrt(vdot(E,r2,r2,level)/E->mesh.NEQ[level]);  
General_matrix_functions.c:779:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:782:	r1 = dvector(0,E->mesh.neq);
General_matrix_functions.c:783:	x1 = dvector(0,E->mesh.neq);
General_matrix_functions.c:802:	    x1[i] = r1[i] * E->BI[level][i];
General_matrix_functions.c:851:    const int dims=E->mesh.nsd;
General_matrix_functions.c:853:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:854:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:855:    const int nel=E->mesh.NEL[level];
General_matrix_functions.c:856:    const int nno=E->mesh.NNO[level];
General_matrix_functions.c:883:	    elt_k = E->elt_k[level][e].k;
General_matrix_functions.c:886:		node=E->IEN[level][e].node[i];
General_matrix_functions.c:891:		if(E->NODE[level][node] & VBX)
General_matrix_functions.c:893:		if(E->NODE[level][node] & VBZ)
General_matrix_functions.c:895:		if((3==dims) && (E->NODE[level][node] & VBY))
General_matrix_functions.c:902:		node=E->IEN[level][e].node[i];
General_matrix_functions.c:906:		eqn1=E->ID[level][node].doff[1];
General_matrix_functions.c:907:		eqn2=E->ID[level][node].doff[2];
General_matrix_functions.c:909:		    eqn3=E->ID[level][node].doff[3];
General_matrix_functions.c:917:		    node1=E->IEN[level][e].node[j];
General_matrix_functions.c:920:			eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:921:			eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:922:		   	eqn13=E->ID[level][node1].doff[3];
General_matrix_functions.c:931:			eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:932:			eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:943:		node=E->IEN[level][e].node[i];
General_matrix_functions.c:947:		eqn1=E->ID[level][node].doff[1];
General_matrix_functions.c:948:		eqn2=E->ID[level][node].doff[2];
General_matrix_functions.c:950:		    eqn3=E->ID[level][node].doff[3];
General_matrix_functions.c:957:		d0[eqn1] += (dd[eqn1] = w[(i-1)*dims]*(F[eqn1]-Ad[eqn1])*E->BI[level][eqn1]); 
General_matrix_functions.c:958:		d0[eqn2] += (dd[eqn2] = w[(i-1)*dims+1]*(F[eqn2]-Ad[eqn2])*E->BI[level][eqn2]); 
General_matrix_functions.c:960:		    d0[eqn3] += (dd[eqn3] = w[(i-1)*dims+2]*(F[eqn3]-Ad[eqn3])*E->BI[level][eqn3]); 
General_matrix_functions.c:967:		   node1=E->IEN[level][e].node[j];
General_matrix_functions.c:970:		       eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:971:		       eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:972:		       eqn13=E->ID[level][node1].doff[3];
General_matrix_functions.c:982:		       eqn11=E->ID[level][node1].doff[1];
General_matrix_functions.c:983:		       eqn12=E->ID[level][node1].doff[2];
General_matrix_functions.c:1032:    const int dims=E->mesh.nsd;
General_matrix_functions.c:1034:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:1035:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:1036:    const int num_nodes=E->mesh.NNO[level];
General_matrix_functions.c:1037:    const int nox=E->mesh.NOX[level];
General_matrix_functions.c:1038:    const int noz=E->mesh.NOY[level];
General_matrix_functions.c:1039:    const int noy=E->mesh.NOZ[level];
General_matrix_functions.c:1054: /* fprintf(E->fp,"in g_s level=%d\n",level);
General_matrix_functions.c:1056:    fprintf(E->fp,"%d %g %g\n",i,F[i],E->BI[level][i]);
General_matrix_functions.c:1065:	    if(E->NODE[level][i] & OFFSIDE) 
General_matrix_functions.c:1068:  	    max_eqn = E->Node_eqn[level][i+1]-E->Node_eqn[level][i];
General_matrix_functions.c:1069:            C=E->Node_map[level]+E->Node_eqn[level][i];
General_matrix_functions.c:1070:	    B1=E->Eqn_k[level]+E->Node_k_id[level][i];
General_matrix_functions.c:1071:	    B2=E->Eqn_k[level]+E->Node_k_id[level][i]+max_eqn;
General_matrix_functions.c:1074:		eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:1075:		eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:1076:		U1 = (F[eqn1] - Ad[eqn1])*E->BI[level][eqn1]; 
General_matrix_functions.c:1077:		U2 = (F[eqn2] - Ad[eqn2])*E->BI[level][eqn2];
General_matrix_functions.c:1080:/*    fprintf(E->fp,"%d %d %d %g %g %g %g\n",max_eqn,eqn1,eqn2,U1,U2,Ad[eqn1],Ad[eqn2]);
General_matrix_functions.c:1084:/*    fprintf(E->fp,"%d %d %g %g \n",j,C[j],B1[j],B2[j]);  */
General_matrix_functions.c:1088:		eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:1089:		eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:1090:		eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:1091:		B3=E->Eqn_k[level]+E->Node_k_id[level][i]+2*max_eqn;
General_matrix_functions.c:1092:		U1 = (F[eqn1] - Ad[eqn1])*E->BI[level][eqn1]; 
General_matrix_functions.c:1093:		U2 = (F[eqn2] - Ad[eqn2])*E->BI[level][eqn2];
General_matrix_functions.c:1094:		U3 = (F[eqn3] - Ad[eqn3])*E->BI[level][eqn3];
General_matrix_functions.c:1150:    const int dims=E->mesh.nsd;
General_matrix_functions.c:1152:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:1153:    const int neq=E->mesh.NEQ[level];
General_matrix_functions.c:1154:    const int num_nodes=E->mesh.NNO[level];
General_matrix_functions.c:1159:	r1=(double *)malloc((E->mesh.neq+2)*sizeof(double));
General_matrix_functions.c:1184:		if(E->NODE[level][i] & OFFSIDE) 
General_matrix_functions.c:1187:		eqn1=E->ID[level][i].doff[1];
General_matrix_functions.c:1188:		eqn2=E->ID[level][i].doff[2];
General_matrix_functions.c:1190:  	        max_eqn = E->Node_eqn[level][i+1]-E->Node_eqn[level][i];
General_matrix_functions.c:1191:                C=E->Node_map[level]+E->Node_eqn[level][i];
General_matrix_functions.c:1192:	        B1=E->Eqn_k[level]+E->Node_k_id[level][i];
General_matrix_functions.c:1193:	        B2=E->Eqn_k[level]+E->Node_k_id[level][i]+max_eqn;
General_matrix_functions.c:1199:		    eqn3=E->ID[level][i].doff[3];
General_matrix_functions.c:1200:	            B3=E->Eqn_k[level]+E->Node_k_id[level][i]+2*max_eqn;
General_matrix_functions.c:1206:		U1 = (F[eqn1] - Ad[eqn1]) * E->BI[level][eqn1];
General_matrix_functions.c:1213:		U2 = (F[eqn2] - Ad[eqn2]) * E->BI[level][eqn2];
General_matrix_functions.c:1221:		    U3 = (F[eqn3] - Ad[eqn3]) * E->BI[level][eqn3];
General_matrix_functions.c:1252:  n = loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:1367:  for(i=1;i<=E->mesh.nno;i++)
General_matrix_functions.c:1381: const int dims = E->mesh.nsd;
General_matrix_functions.c:1383: const int nel=E->mesh.nel;
General_matrix_functions.c:1388:   if (E->mat[e]==1)
General_matrix_functions.c:1391:         dtemp += dU[ E->LMD[lev][e].node[a].doff[i] ]*
General_matrix_functions.c:1392:                  dU[ E->LMD[lev][e].node[a].doff[i] ];
General_matrix_functions.c:1393:         temp +=  U[ E->LMD[lev][e].node[a].doff[i] ]*
General_matrix_functions.c:1394:                  U[ E->LMD[lev][e].node[a].doff[i] ];
General_matrix_functions.c:1417:    const int dims = E->mesh.nsd;
General_matrix_functions.c:1419:    noy = E->mesh.noy;
General_matrix_functions.c:1420:    noz = E->mesh.noz;
General_matrix_functions.c:1421:    nox = E->mesh.nox;
General_matrix_functions.c:1426:        for(j=1;j<=E->mesh.nox;j++)     {
General_matrix_functions.c:1438:  const int dims = E->mesh.nsd;
General_matrix_functions.c:1443:  sizeofH = (2*E->mesh.noz+2)*sizeof(float);
General_matrix_functions.c:1447:  noz = E->mesh.noz;
General_matrix_functions.c:1448:  noy = E->mesh.noy;
General_matrix_functions.c:1449:  elz = E->mesh.elz;
General_matrix_functions.c:1450:  ely = E->mesh.ely;
General_matrix_functions.c:1451:  elx = E->mesh.elx;
General_matrix_functions.c:1460:            lnode[1] = E->ien[el].node[1];
General_matrix_functions.c:1461:            lnode[2] = E->ien[el].node[4];
General_matrix_functions.c:1462:            temp[i] += 0.5*(X[lnode[1]]+X[lnode[2]])*sin((E->X[1][lnode[2]]+E->X[1][lnode[1]])*0.5)*(E->X[1][lnode[2]]-E->X[1][lnode[1]]);
General_matrix_functions.c:1463:            temp[i+noz] += sin((E->X[1][lnode[2]]+E->X[1][lnode[1]])*0.5)*(E->X[1][lnode[2]]-E->X[1][lnode[1]]);
General_matrix_functions.c:1466:              lnode[1] = E->ien[el].node[2];
General_matrix_functions.c:1467:              lnode[2] = E->ien[el].node[3];
General_matrix_functions.c:1469:              temp[i+1] += 0.5*(X[lnode[1]]+X[lnode[2]])*sin((E->X[1][lnode[2]]+E->X[1][lnode[1]])*0.5)*(E->X[1][lnode[2]]-E->X[1][lnode[1]]);
General_matrix_functions.c:1470:              temp[i+1+noz] += sin((E->X[1][lnode[2]]+E->X[1][lnode[1]])*0.5)*(E->X[1][lnode[2]]-E->X[1][lnode[1]]);
General_matrix_functions.c:1495:  const int dims = E->mesh.nsd;
General_matrix_functions.c:1503:  sizeofH = (2*E->mesh.noz+2)*sizeof(float);
General_matrix_functions.c:1508:  noz = E->mesh.noz;
General_matrix_functions.c:1509:  noy = E->mesh.noy;
General_matrix_functions.c:1510:  elz = E->mesh.elz;
General_matrix_functions.c:1511:  ely = E->mesh.ely;
General_matrix_functions.c:1512:  elx = E->mesh.elx;
General_matrix_functions.c:1523:            lnode[1] = E->ien[el].node[1];
General_matrix_functions.c:1524:            lnode[2] = E->ien[el].node[4];
General_matrix_functions.c:1525:            lnode[4] = E->ien[el].node[5];
General_matrix_functions.c:1526:            lnode[3] = E->ien[el].node[8];
General_matrix_functions.c:1528:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
General_matrix_functions.c:1529:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
General_matrix_functions.c:1530:              temp[i] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:1532:              temp[i+noz] += E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:1537:              lnode[1] = E->ien[el].node[2];
General_matrix_functions.c:1538:              lnode[2] = E->ien[el].node[3];
General_matrix_functions.c:1539:              lnode[4] = E->ien[el].node[6];
General_matrix_functions.c:1540:              lnode[3] = E->ien[el].node[7];
General_matrix_functions.c:1542:          for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
General_matrix_functions.c:1543:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
General_matrix_functions.c:1544:              temp[i+1] += X[lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:1546:              temp[i+1+noz] += E->M.vpt[GMVINDEX(d,nint)]
General_matrix_functions.c:1584:    const int vpts = vpoints[E->mesh.nsd];
General_matrix_functions.c:1585:    const int ends = enodes[E->mesh.nsd];
General_matrix_functions.c:1589:    for (el=1;el<=E->mesh.nel;el++)  {
General_matrix_functions.c:1591:          get_global_shape_fn(E,el,&GN,&GNx,&dOmega,xk,0,E->mesh.levmax);
General_matrix_functions.c:1595:                n = E->ien[el].node[i];
General_matrix_functions.c:1596:                volume += E->N.vpt[GNVINDEX(i,j)] * dOmega.vpt[j];
General_matrix_functions.c:1597:                integral += Z[n] * E->N.vpt[GNVINDEX(i,j)] * dOmega.vpt[j];
General_matrix_functions.c:1620:    neq=E->mesh.NEQ[lev];
General_matrix_functions.c:1675:						fprintf(E->fp,"gaussj: Singular Matrix-1\n");
General_matrix_functions.c:1702:			fprintf(E->fp,"gaussj: Singular Matrix-2\n");
Geometry_cartesian.c:10:  E->mesh.nsd = 2;
Geometry_cartesian.c:11:  E->mesh.dof = 2;
Geometry_cartesian.c:20:  E->mesh.nsd = 2;
Geometry_cartesian.c:21:  E->mesh.dof = 3;
Geometry_cartesian.c:29:  E->mesh.nsd = 3;
Geometry_cartesian.c:30:  E->mesh.dof = 3;
Instructions.c:61:    E->control.PID=get_process_identifier(); 
Instructions.c:73:    (E->problem_derived_values)(E);   /* call this before global_derived_  */
Instructions.c:77:    (E->problem_allocate_vars)(E);
Instructions.c:78:    (E->solver_allocate_vars)(E);
Instructions.c:87:    (E->problem_boundary_conds)(E);
Instructions.c:99:    (E->problem_initial_fields)(E);   /* temperature/chemistry/melting etc */
Instructions.c:125:    E->P = (double *) malloc ((E->mesh.npno+1)*sizeof(double));
Instructions.c:126:    E->S = (double *) malloc ((E->mesh.npno+1)*sizeof(double));
Instructions.c:128:    E->C        = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:129:    E->C_prev   = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:130:    E->CE        = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:131:    E->CE_prev   = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:132:    E->CE_temp   = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:133:    E->Fm        = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:134:    E->FmE        = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:136:    E->T        = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:137:    E->TE        = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:138:    E->buoyancy = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:139:    E->NP       = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:140:    E->edot     = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:141:    E->heatflux     = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:142:    E->heating_visc    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:143:    E->heating_latent    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:144:    E->heating_adi    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:145:    E->heating_tidal    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:146:    E->tidal_visc    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:147:    E->heating_shear    = (float *) malloc((E->mesh.nel+1)*sizeof(float));
Instructions.c:148:    E->heating_despin    = (double *) malloc((E->mesh.nel+1)*sizeof(double));
Instructions.c:150:		E->c_Ri = (complex double *) malloc((E->mesh.nno+1)*sizeof(complex double));
Instructions.c:151:		E->c_ERi = (complex double *) malloc((E->mesh.nel+1)*sizeof(complex double));
Instructions.c:153:    E->Fas670    = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:154:    E->Fas670_b  = (float *) malloc((E->mesh.nox+1)*sizeof(float));
Instructions.c:155:    E->Fas410    = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:156:    E->Fas410_b  = (float *) malloc((E->mesh.nox+1)*sizeof(float));
Instructions.c:158:  for(i=1;i<=E->mesh.nsd;i++)  {
Instructions.c:159:    E->TB[i] = (float *)  malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:160:    E->CB[i] = (float *)  malloc((E->mesh.nno+1)*sizeof(float));
Instructions.c:163:    E->Have.T    = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:164:    E->Have.Vi   = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:165:    E->Have.i_Ri   = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:166:    E->Have.r_Ri   = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:167:    E->Have.Rho  = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:168:    E->Have.vrms = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:169:    E->Have.f = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:170:    E->Have.F = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:171:    E->Have.Tadi = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:172:    E->Have.Tprev = (float *) malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:174:    E->stress    = (float *)malloc((2*6*E->mesh.nsf+12)*sizeof(float));
Instructions.c:175:    E->slice.tpg      = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:176:    E->slice.tpgb     = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:177:    E->slice.vline     = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:178:    E->slice.vlinek    = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:179:    E->slice.shflux    = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:180:    E->slice.bhflux    = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:181:    E->slice.cen_mflux = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:182:    E->slice.vxsurf[1] = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:183:    E->slice.vxsurf[2] = (float *)malloc((E->mesh.nsf+2)*sizeof(float));
Instructions.c:184:    E->slice.melt      = (float *)malloc((E->mesh.esf+2)*sizeof(float));
Instructions.c:185:    E->slice.new_melt  = (float *)malloc((E->mesh.esf+2)*sizeof(float));
Instructions.c:186:    E->slice.impact_melt = (float *)malloc((E->mesh.esf+2)*sizeof(float));
Instructions.c:188:		for(i=1;i<=E->mesh.esf;i++)
Instructions.c:189:			E->slice.melt[i] = 0.0;
Instructions.c:191:		E->Total.melt_prod = 0.0;
Instructions.c:193:    E->mat = (int *) malloc((E->mesh.nel+2)*sizeof(int));
Instructions.c:195:  E->diffusivity = (float *)  malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:196:  E->expansivity = (float *)  malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:197:  E->solidus = (float *)  malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:198:  E->lherzliq = (float *)  malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:199:  E->liquidus = (float *)  malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:201:  E->XP[1] = (float *)  malloc((E->mesh.nox+1)*sizeof(float));
Instructions.c:202:  E->XP[2] = (float *)  malloc((E->mesh.noz+1)*sizeof(float));
Instructions.c:204:  for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)   {
Instructions.c:205:    for(j=1;j<=E->mesh.nsd;j++)   {
Instructions.c:206:      E->XX[i][j] = (float *)  malloc((E->mesh.NNO[i]+1)*sizeof(float));
Instructions.c:207:      E->Interp[i][j] = (float *)  malloc((E->mesh.NNO[i]+1)*sizeof(float));
Instructions.c:209:    E->MASS[i]     = (float *) malloc((E->mesh.NNO[i]+1)*sizeof(float));
Instructions.c:211:    E->ECO[i] = (struct COORD *) malloc((E->mesh.NNO[i]+2)*sizeof(struct COORD));
Instructions.c:212:    E->ID[i]  = (struct ID *)    malloc((E->mesh.NNO[i]+2)*sizeof(struct ID));
Instructions.c:213:    E->IEN[i] = (struct IEN *)   malloc((E->mesh.NEL[i]+2)*sizeof(struct IEN));
Instructions.c:214:    E->EL[i]  = (struct SUBEL *) malloc((E->mesh.NEL[i]+2)*sizeof(struct SUBEL));
Instructions.c:215:    E->LMD[i] = (struct LM *)    malloc((E->mesh.NEL[i]+2)*sizeof(struct LM));
Instructions.c:216:    E->elt_del[i]=(struct EG *)  malloc((E->mesh.NEL[i]+1)*sizeof(struct EG));
Instructions.c:217:    E->BPI[i]    = (double *)    malloc((E->mesh.NPNO[i]+1)*sizeof(double));
Instructions.c:219:    E->EVI[i] = (float *) malloc((E->mesh.NEL[i]+2)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:221:    E->TW[i]  = (float  *)       malloc((E->mesh.NNO[i]+2)*sizeof(float));
Instructions.c:222:    E->VI[i]  = (float *)        malloc((E->mesh.NNO[i]+2)*sizeof(float));
Instructions.c:223:    E->NODE[i] = (unsigned int *)malloc((E->mesh.NNO[i]+2)*sizeof(unsigned int));
Instructions.c:224:      E->TWW[i] =(struct FNODE *) malloc((E->mesh.NEL[i]+2)*sizeof(struct FNODE));
Instructions.c:226:    E->NEI[i].nels     = (int *) malloc((E->mesh.NNO[i]+2)*sizeof(int));
Instructions.c:227:    E->NEI[i].lnode    = (int *) malloc((E->mesh.NNO[i]+2)*enodes[E->mesh.nsd]*sizeof(int));
Instructions.c:228:    E->NEI[i].element  = (int *) malloc((E->mesh.NNO[i]+2)*enodes[E->mesh.nsd]*sizeof(int));   
Instructions.c:231:  for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)  {
Instructions.c:232:    if (E->mesh.nsd==2)  {
Instructions.c:233:        nxyz = max(E->mesh.nox,E->mesh.noz);
Instructions.c:235:    else if (E->mesh.nsd==3)  {
Instructions.c:236:        nxyz = max(E->mesh.nox*E->mesh.noz,E->mesh.nox*E->mesh.noy);
Instructions.c:237:        nxyz = 2*max(nxyz,E->mesh.noz*E->mesh.noy);
Instructions.c:240:    E->sien         = (struct SIEN *) malloc((nxyz+2)*sizeof(struct SIEN));
Instructions.c:241:    E->surf_element = (int *) malloc((nxyz+2)*sizeof(int));
Instructions.c:242:    E->surf_node    = (int *)malloc((E->mesh.nsf+2)*sizeof(int));
Instructions.c:245:  for(i=1;i<=E->mesh.nno;i++)     {
Instructions.c:246:    E->T[i] = E->buoyancy[i] = 0.0;
Instructions.c:247:    for(j=1;j<=E->mesh.nsd;j++)
Instructions.c:248:      E->TB[j][i] = 0.0;
Instructions.c:251:  for(l=E->mesh.levmin;l<=E->mesh.levmax;l++)
Instructions.c:252:    for(i=1;i<=E->mesh.NNO[l];i++)  {
Instructions.c:253:      E->NODE[l][i] = (INTX | INTY | INTZ);  /* and any others ... */
Instructions.c:254:      E->VI[l][i] = 1.0;
Instructions.c:255:      E->TW[l][i] = 0.0;
Instructions.c:256:      for(j=1;j<=E->mesh.nsd;j++)
Instructions.c:257:         E->XX[l][j][i] = 0.0;
Instructions.c:260:  for(i=1;i<E->mesh.nel;i++)   {
Instructions.c:261:     E->mat[i]=1;
Instructions.c:262:     E->heating_visc[i] =  E->heating_latent[i] = E->heating_adi[i] = 0.0;
Instructions.c:263:     E->heating_tidal[i] = 0.0;
Instructions.c:266:  for(i=1;i<E->mesh.noz;i++)   {
Instructions.c:267:     E->diffusivity[i] =  E->expansivity[i] = 1.0;
Instructions.c:270:  for(i=1;i<=E->mesh.npno;i++)
Instructions.c:271:      E->P[i] = 0.0;
Instructions.c:286:  E->mesh.nnov = E->mesh.nno;
Instructions.c:287:  E->mesh.NEQ[E->mesh.levmax] = E->mesh.nnov * E->mesh.nsd;
Instructions.c:289:  E->F = (double *) malloc((E->mesh.nsd*E->mesh.nnov+1)*sizeof(double));
Instructions.c:290:  E->U = (double *) malloc((E->mesh.nsd*E->mesh.nnov+1)*sizeof(double));
Instructions.c:292:  for(i=1;i<=E->mesh.nsd;i++)  {
Instructions.c:293:      E->V[i]  = (float *)  malloc((E->mesh.nnov+1)*sizeof(float));
Instructions.c:294:      E->VB[i] = (float *)  malloc((E->mesh.nnov+1)*sizeof(float));
Instructions.c:297:  for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)  {
Instructions.c:298:    E->BI[i] = (double *) malloc((E->mesh.NEQ[i]+2)*sizeof(double)); 
Instructions.c:299:    E->EQN[i] = (unsigned int *) malloc((E->mesh.NEQ[i]+2)*sizeof(unsigned int)); 
Instructions.c:303:  for(l=E->mesh.levmin;l<=E->mesh.levmax;l++)
Instructions.c:304:    for(i=0;i<E->mesh.NEQ[l];i++) {
Instructions.c:305:      E->BI[l][i]=0.0;
Instructions.c:306:      E->EQN[l][i]=0;
Instructions.c:309:  for(i=0;i<E->mesh.NEQ[E->mesh.levmax];i++)
Instructions.c:310:    E->U[i]=0.0;
Instructions.c:312:  for(i=1;i<=E->mesh.nnov;i++)
Instructions.c:313:    for(j=1;j<=E->mesh.nsd;j++)
Instructions.c:314:       E->V[j][i] =
Instructions.c:315:         E->VB[j][i] = 0.0;
Instructions.c:338:  E->control.v_steps_low = 10;
Instructions.c:339:  E->control.v_steps_upper = 1;
Instructions.c:340:  E->control.max_res_red_each_p_mg = 1.0e-3;
Instructions.c:341:  E->control.accuracy = 1.0e-6;
Instructions.c:342:  E->control.vaccuracy = 1.0e-8;
Instructions.c:343:  E->control.true_vcycle=0;
Instructions.c:344:  E->control.depth_dominated=0;
Instructions.c:345:  E->control.eqn_zigzag=0;
Instructions.c:346:  E->control.verbose=0; /* debugging/profiles */
Instructions.c:350:  E->control.ORTHO = 1; /* for orthogonal meshes by default */
Instructions.c:351:  E->control.ORTHOZ = 1; /* for orthogonal meshes by default */
Instructions.c:354:    E->control.KERNEL = 0;
Instructions.c:355:    E->control.stokes=0;
Instructions.c:356:    E->control.CONVECTION = 0;
Instructions.c:357:    E->control.SLAB = 0;
Instructions.c:358:    E->control.CART2D = 0;
Instructions.c:359:    E->control.CART3D = 0;
Instructions.c:360:    E->control.CART2pt5D = 0;
Instructions.c:361:    E->control.AXI = 0;
Instructions.c:362:    E->control.CONJ_GRAD = 0;
Instructions.c:363:    E->control.NMULTIGRID = 0;
Instructions.c:364:    E->control.EMULTIGRID = 0;
Instructions.c:365:    E->control.COMPRESS = 1;
Instructions.c:366:    E->control.augmented_Lagr = 0;
Instructions.c:367:    E->control.augmented = 0.0;
Instructions.c:370:    E->control.MELTING_MODULE = 0;
Instructions.c:371:    E->control.CHEMISTRY_MODULE = 0;
Instructions.c:373:    E->control.composition = 0;
Instructions.c:374:    E->control.comp_diff = 0.0;
Instructions.c:376:    E->control.GRID_TYPE=1;
Instructions.c:377:    E->mesh.hwidth[1]=E->mesh.hwidth[2]=E->mesh.hwidth[3]=1.0; /* divide by this one ! */
Instructions.c:378:    E->mesh.magnitude[1]=E->mesh.magnitude[2]=E->mesh.magnitude[3]=0.0;
Instructions.c:379:    E->mesh.offset[1]=E->mesh.offset[2]=E->mesh.offset[3]=0.0;
Instructions.c:381:  E->mesh.levmax=0;
Instructions.c:382:  E->mesh.levmin=0;
Instructions.c:383:  E->mesh.noz = 1;    E->mesh.noz = 1;
Instructions.c:384:  E->mesh.noy = 1;    E->mesh.noy = 1;  
Instructions.c:386:  E->monitor.T_interior=1.0;
Instructions.c:388:  E->viscosity.guess = 0;
Instructions.c:389:  sprintf(E->viscosity.old_file,"initialize");
Instructions.c:391:  E->control.precondition = 0;	/* for larger visc contrasts turn this back on  */
Instructions.c:392:  E->control.vprecondition = 1;	
Instructions.c:394:  E->mesh.toptbc = 1; /* fixed t */
Instructions.c:395:  E->mesh.bottbc = 1;
Instructions.c:396:  E->mesh.topvbc = 0; /* stress */
Instructions.c:397:  E->mesh.botvbc = 0;
Instructions.c:398:  E->mesh.sidevbc=0;
Instructions.c:399:  E->mesh.periodic_x=0; /* reflection is default*/
Instructions.c:400:  E->mesh.periodic_y=0;
Instructions.c:401:  E->control.VBXtopval=0.0;
Instructions.c:402:  E->control.VBYtopval=0.0;
Instructions.c:403:  E->control.VBXbotval=0.0;
Instructions.c:404:  E->control.VBYbotval=0.0;
Instructions.c:406:  E->data.layer_km = 2800.0; /* Earth, whole mantle defaults */
Instructions.c:407:  E->data.grav_acc = 9.81;
Instructions.c:408:  E->data.therm_exp = 3.28e-5;
Instructions.c:409:  E->data.Cp = 1200.0;
Instructions.c:410:  E->data.therm_diff = 8.0e-7;
Instructions.c:411:  E->data.therm_cond = 3.168;
Instructions.c:412:  E->data.density = 3340.0;
Instructions.c:413:  E->data.res_density = 3295.0;  /* density when X = ... */
Instructions.c:414:  E->data.res_density_X = 0.3;
Instructions.c:415:  E->data.melt_density = 2800.0;
Instructions.c:416:  E->data.permeability = 3.0e-10;
Instructions.c:417:  E->data.density_above = 1030.0;    /* sea water */
Instructions.c:418:  E->data.density_core = 3500.0;	/* silicate rock */
Instructions.c:419:  E->data.gas_const = 8.3;
Instructions.c:420:  E->data.surf_heat_flux = 4.4e-2;
Instructions.c:421:  E->data.grav_const = 6.673e-11;
Instructions.c:422:  E->data.surf_temp = 0.0;
Instructions.c:423:  E->data.disptn_number = 0.0;
Instructions.c:424:  E->data.youngs_mod = 1.0e11;
Instructions.c:425:  E->data.Te = 0.0;
Instructions.c:426:  E->data.T_sol0 = 1373.0;	/* Dave's values 1991 (for the earth) */
Instructions.c:427:  E->data.Tsurf = 273.0;
Instructions.c:428:  E->data.dTsol_dz = 3.4e-3 ;
Instructions.c:429:  E->data.dTsol_dF = 440.0;
Instructions.c:430:  E->data.dT_dz = 0.48e-3;
Instructions.c:431:  E->data.delta_S = 250.0;
Instructions.c:432:  E->data.ref_temperature = 2 * 1350.0; /* fixed temperature ... delta T */
Instructions.c:436:    sprintf(E->control.data_file,"citcom.tmp.%d",getpid());
Instructions.c:438:    E->control.NASSEMBLE = 0;
Instructions.c:440:    E->mesh.layer[1] =  E->mesh.layer[2] =  E->mesh.layer[3] = 1.0;
Instructions.c:441:    E->monitor.elapsed_time=0.0;
Instructions.c:442:    E->monitor.deltah=0.0;
Instructions.c:453: if (E->control.NMULTIGRID||E->control.EMULTIGRID)
Instructions.c:454:    { E->mesh.levmax=E->mesh.levels-1;
Instructions.c:455:      E->mesh.nox = E->mesh.mgunitx * (int) pow(2.0,((double)E->mesh.levmax)) + 1;
Instructions.c:456:      E->mesh.noz = E->mesh.mgunitz *(int) pow(2.0,((double)E->mesh.levmax)) + 1; 
Instructions.c:457:      if(E->mesh.nsd == 3 ) 
Instructions.c:458:	  E->mesh.noy = E->mesh.mgunity * (int) pow(2.0,((double)E->mesh.levmax)) + 1; 
Instructions.c:461: if(E->mesh.nsd != 3) 
Instructions.c:462:   E->mesh.noy = 1;
Instructions.c:464:  E->mesh.nnx[1] = E->mesh.nox;	
Instructions.c:465:  E->mesh.nnx[2] = E->mesh.noz;	
Instructions.c:466:  E->mesh.nnx[3] = E->mesh.noy;	
Instructions.c:467:  E->mesh.elx = E->mesh.nox-1;	
Instructions.c:468:  E->mesh.elz = E->mesh.noz-1;
Instructions.c:469:  E->mesh.ely = max(E->mesh.noy-1,1);
Instructions.c:471:  E->mesh.nel = E->mesh.elx*E->mesh.ely*E->mesh.elz;
Instructions.c:472:  E->mesh.nno = E->mesh.nox*E->mesh.noy*E->mesh.noz;
Instructions.c:473:  E->mesh.nnov = E->mesh.nno;
Instructions.c:474:  E->mesh.neq = E->mesh.nnov*E->mesh.nsd;
Instructions.c:476:  E->mesh.npno = E->mesh.nel;
Instructions.c:477:  E->mesh.nsf = E->mesh.nox*E->mesh.noy;
Instructions.c:478:  E->mesh.esf = E->mesh.elx*E->mesh.ely;
Instructions.c:479:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)  /* set up dimensions for different grids  */
Instructions.c:480:    { if (E->control.NMULTIGRID||E->control.EMULTIGRID)
Instructions.c:481:	{ nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Instructions.c:482:	  noz = E->mesh.mgunitz * (int) pow(2.0,(double)i) + 1;
Instructions.c:483:	  if(E->mesh.nsd==3)
Instructions.c:484:	    noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Instructions.c:489:	{ nox = E->mesh.nox;
Instructions.c:490:	  noz = E->mesh.noz;
Instructions.c:491:	  noy = E->mesh.noy;
Instructions.c:494:      E->mesh.ELX[i] = nox-1;
Instructions.c:495:      E->mesh.ELZ[i] = noz-1;
Instructions.c:496:      E->mesh.ELY[i] = max(noy-1,1);
Instructions.c:497:      E->mesh.NNO[i] = nox * noz * noy;
Instructions.c:498:      E->mesh.NEL[i] = (nox-1) * (noz-1) * max((noy-1),1);;
Instructions.c:499:      E->mesh.NPNO[i] = E->mesh.NEL[i] ;
Instructions.c:500:      E->mesh.NOX[i] = nox;
Instructions.c:501:      E->mesh.NOZ[i] = noz;
Instructions.c:502:      E->mesh.NOY[i] = noy;
Instructions.c:503:      E->mesh.NNX[i][1] = nox;	
Instructions.c:504:      E->mesh.NNX[i][2] = noz;	
Instructions.c:505:      E->mesh.NNX[i][3] = noy;	
Instructions.c:507:      E->mesh.NNOV[i] = E->mesh.NNO[i];
Instructions.c:508:      E->mesh.NEQ[i] = E->mesh.nsd * E->mesh.NNOV[i] ;  
Instructions.c:512:    if(E->control.print_convergence)
Instructions.c:513:	fprintf(stderr,"Problem has %d x %d x %d nodes\n",E->mesh.nox,E->mesh.noz,E->mesh.noy);
Instructions.c:536:    input_string("Problem",E->control.PROBLEM_TYPE,NULL);
Instructions.c:537:    if ( strcmp(E->control.PROBLEM_TYPE,"convection") == 0)  {
Instructions.c:538:	E->control.CONVECTION = 1; 
Instructions.c:542:    else if ( strcmp(E->control.PROBLEM_TYPE,"convection-chemical") == 0) {
Instructions.c:543:	E->control.CONVECTION = 1;
Instructions.c:544:	E->control.CHEMISTRY_MODULE=1;
Instructions.c:549:	fprintf(E->fp,"Unable to determine problem type, assuming convection ... \n");
Instructions.c:550:	E->control.CONVECTION = 1;
Instructions.c:554:  input_string("Geometry",E->control.GEOMETRY,NULL); 
Instructions.c:555:  if ( strcmp(E->control.GEOMETRY,"cart2d") == 0)
Instructions.c:556:    { E->control.CART2D = 1; 
Instructions.c:558:  else if ( strcmp(E->control.GEOMETRY,"saxi") == 0)
Instructions.c:559:    { E->control.AXI = 1; 
Instructions.c:562:  else if ( strcmp(E->control.GEOMETRY,"cart2pt5d") == 0)
Instructions.c:563:    { E->control.CART2pt5D = 1; 
Instructions.c:565:  else if ( strcmp(E->control.GEOMETRY,"cart3d") == 0)
Instructions.c:566:    { E->control.CART3D = 1;
Instructions.c:569:    { fprintf(E->fp,"Unable to determine geometry, assuming cartesian 2d ... \n");
Instructions.c:570:      E->control.CART2D = 1; 
Instructions.c:573:  input_string("Solver",E->control.SOLVER_TYPE,NULL);
Instructions.c:574:  if ( strcmp(E->control.SOLVER_TYPE,"cgrad") == 0)
Instructions.c:575:    { E->control.CONJ_GRAD = 1;
Instructions.c:577:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid") == 0)
Instructions.c:578:    { E->control.NMULTIGRID = 1;
Instructions.c:580:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid-el") == 0)
Instructions.c:581:    { E->control.EMULTIGRID = 1;
Instructions.c:591:  input_string("Spacing",E->control.NODE_SPACING,"regular");
Instructions.c:592:  if ( strcmp(E->control.NODE_SPACING,"regular") == 0)
Instructions.c:593:    E->control.GRID_TYPE = 1; 
Instructions.c:594:  else if ( strcmp(E->control.NODE_SPACING,"bound_lyr") == 0)
Instructions.c:595:    E->control.GRID_TYPE = 2;
Instructions.c:596:  else if ( strcmp(E->control.NODE_SPACING,"region") == 0)
Instructions.c:597:    E->control.GRID_TYPE = 3;
Instructions.c:598:  else if ( strcmp(E->control.NODE_SPACING,"ortho_files") == 0)
Instructions.c:599:    E->control.GRID_TYPE = 4;
Instructions.c:601:    {  E->control.GRID_TYPE = 1; }
Instructions.c:607:    input_string("datatypes",E->control.which_data_files,"");
Instructions.c:608:    input_string("averages",E->control.which_horiz_averages,"");
Instructions.c:609:    input_string("timelog",E->control.which_running_data,"");
Instructions.c:610:    input_string("observables",E->control.which_observable_data,"");
Instructions.c:612:    input_string("datafile",E->control.data_file,"initialize");
Instructions.c:613:    input_string("restart_datafile",E->control.data_file1,"initialize");
Instructions.c:614:    input_string("process_command",E->control.output_written_external_command,"");
Instructions.c:615:    input_boolean("IBM_DX",&(E->control.DX),"off");
Instructions.c:616:    input_boolean("CONMAN",&(E->control.CONMAN),"off");
Instructions.c:623:    sprintf(logfile,"%s.log",E->control.data_file);
Instructions.c:624:    sprintf(debugfile,"%s.debug",E->control.data_file);
Instructions.c:627:	E->fp = stdout;
Instructions.c:629:	E->fp = fp;
Instructions.c:632:	E->fpdebug = stdout;
Instructions.c:634:	E->fpdebug = fpdebug;
Instructions.c:636:    if (E->control.NMULTIGRID||E->control.EMULTIGRID) {
Instructions.c:637:	input_int("mgunitx",&(E->mesh.mgunitx),"1");
Instructions.c:638:	input_int("mgunitz",&(E->mesh.mgunitz),"1");
Instructions.c:639:	input_int("mgunity",&(E->mesh.mgunity),"1");
Instructions.c:640:	input_int("levels",&(E->mesh.levels),"0");
Instructions.c:643:    input_boolean("node_assemble",&(E->control.NASSEMBLE),"off");
Instructions.c:646:    input_boolean("verbose",&(E->control.verbose),"off");
Instructions.c:647:    input_boolean("see_convergence",&(E->control.print_convergence),"off");
Instructions.c:648:    input_boolean("COMPRESS",&(E->control.COMPRESS),"on");
Instructions.c:649:    input_float("sobtol",&(E->control.sob_tolerance),"0.0001");
Instructions.c:651:    input_int("obs_maxlongk",&(E->slice.maxlong),"100,1");
Instructions.c:652:    input_int("obs_minlongk",&(E->slice.minlong),"1,1");
Instructions.c:654:    input_int("stokes_flow_only",&(E->control.stokes),"0");
Instructions.c:657:    input_float("Ra_670",&(E->control.Ra_670),"0.0");
Instructions.c:658:    input_float("clapeyron670",&(E->control.clapeyron670),"0.0");
Instructions.c:659:    input_float("transT670",&(E->control.transT670),"0.0");
Instructions.c:660:    input_float("width670",&(E->control.width670),"0.0");
Instructions.c:662:    input_float("Ra_410",&(E->control.Ra_410),"0.0");
Instructions.c:663:    input_float("clapeyron410",&(E->control.clapeyron410),"0.0");
Instructions.c:664:    input_float("transT410",&(E->control.transT410),"0.0");
Instructions.c:665:    input_float("width410",&(E->control.width410),"0.0");
Instructions.c:668:    input_int("restart",&(E->control.restart),"0");
Instructions.c:669:    input_float("restart_age",&(E->control.restart_age),"0.0");
Instructions.c:671:    input_int("topvbc",&(E->mesh.topvbc),"0");
Instructions.c:672:    input_int("botvbc",&(E->mesh.botvbc),"0");
Instructions.c:673:    input_int("sidevbc",&(E->mesh.sidevbc),"0");
Instructions.c:675:    input_boolean("periodicx",&(E->mesh.periodic_x),"off");
Instructions.c:676:    input_boolean("periodicy",&(E->mesh.periodic_y),"off");
Instructions.c:677:    input_boolean("depthdominated",&(E->control.depth_dominated),"off");
Instructions.c:678:    input_boolean("eqnzigzag",&(E->control.eqn_zigzag),"off");
Instructions.c:679:    input_boolean("eqnviscosity",&(E->control.eqn_viscosity),"off");
Instructions.c:681:    input_float("topvbxval",&(E->control.VBXtopval),"0.0");
Instructions.c:682:    input_float("botvbxval",&(E->control.VBXbotval),"0.0");
Instructions.c:683:    input_float("topvbyval",&(E->control.VBYtopval),"0.0");
Instructions.c:684:    input_float("botvbyval",&(E->control.VBYbotval),"0.0");
Instructions.c:686:    input_int("toptbc",&(E->mesh.toptbc),"1");
Instructions.c:687:    input_int("bottbc",&(E->mesh.bottbc),"1");
Instructions.c:688:    input_float("toptbcval",&(E->control.TBCtopval),"0.0");
Instructions.c:689:    input_float("bottbcval",&(E->control.TBCbotval),"1.0");
Instructions.c:691:    input_int("surf_temp_var",&(E->control.surf_temp_var),"0");
Instructions.c:692:    input_int("secular",&(E->control.secular),"0");
Instructions.c:694:    input_float("blyr_hwx1",&(E->mesh.bl1width[1]),"nodefault");
Instructions.c:695:    input_float("blyr_hwz1",&(E->mesh.bl1width[2]),"nodefault");
Instructions.c:696:    input_float("blyr_hwy1",&(E->mesh.bl1width[3]),"nodefault");
Instructions.c:697:    input_float("blyr_hwx2",&(E->mesh.bl2width[1]),"nodefault");
Instructions.c:698:    input_float("blyr_hwz2",&(E->mesh.bl2width[2]),"nodefault");
Instructions.c:699:    input_float("blyr_hwy2",&(E->mesh.bl2width[3]),"nodefault");
Instructions.c:700:    input_float("blyr_mgx1",&(E->mesh.bl1mag[1]),"nodefault");
Instructions.c:701:    input_float("blyr_mgz1",&(E->mesh.bl1mag[2]),"nodefault");
Instructions.c:702:    input_float("blyr_mgy1",&(E->mesh.bl1mag[3]),"nodefault");
Instructions.c:703:    input_float("blyr_mgx2",&(E->mesh.bl2mag[1]),"nodefault");
Instructions.c:704:    input_float("blyr_mgz2",&(E->mesh.bl2mag[2]),"nodefault");
Instructions.c:705:    input_float("blyr_mgy2",&(E->mesh.bl2mag[3]),"nodefault");
Instructions.c:708:    input_float("region_wdx",&(E->mesh.width[1]),"nodefault");
Instructions.c:709:    input_float("region_wdz",&(E->mesh.width[2]),"nodefault");
Instructions.c:710:    input_float("region_wdy",&(E->mesh.width[3]),"nodefault");
Instructions.c:711:    input_float("region_hwx",&(E->mesh.hwidth[1]),"nodefault");
Instructions.c:712:    input_float("region_hwz",&(E->mesh.hwidth[2]),"nodefault");
Instructions.c:713:    input_float("region_hwy",&(E->mesh.hwidth[3]),"nodefault");
Instructions.c:714:    input_float("region_mgx",&(E->mesh.magnitude[1]),"nodefault");
Instructions.c:715:    input_float("region_mgz",&(E->mesh.magnitude[2]),"nodefault");
Instructions.c:716:    input_float("region_mgy",&(E->mesh.magnitude[3]),"nodefault");
Instructions.c:717:    input_float("region_ofx",&(E->mesh.offset[1]),"nodefault");
Instructions.c:718:    input_float("region_ofz",&(E->mesh.offset[2]),"nodefault");
Instructions.c:719:    input_float("region_ofy",&(E->mesh.offset[3]),"nodefault");
Instructions.c:721:    input_string("gridxfile",E->mesh.gridfile[1]," ");
Instructions.c:722:    input_string("gridzfile",E->mesh.gridfile[2]," ");
Instructions.c:723:    input_string("gridyfile",E->mesh.gridfile[3]," ");
Instructions.c:725:    input_float("outer_radius",&(E->sphere.ro),"nodefault");
Instructions.c:726:    input_float("inner_radius",&(E->sphere.ri),"nodefault");
Instructions.c:727:    input_float("comp_radius",&(E->sphere.rcomp),"nodefault");
Instructions.c:728:    input_float("core_radius",&(E->sphere.rcore),"nodefault");
Instructions.c:730:    E->sphere.ro_dim = E->sphere.ro;
Instructions.c:731:    E->sphere.ri = E->sphere.ri/E->sphere.ro;
Instructions.c:732:    E->sphere.rcomp = E->sphere.rcomp/E->sphere.ro;
Instructions.c:733:    E->sphere.rcore= E->sphere.rcore/E->sphere.ro;
Instructions.c:734:    E->sphere.ro = 1.0;
Instructions.c:736:    E->viscosity.zlm = 1.0;
Instructions.c:737:    E->viscosity.zlith = 0.0;
Instructions.c:738:    input_int("nz_dd",&(E->viscosity.ndd),"1");
Instructions.c:739:    input_int("nz_lmantle",&(E->viscosity.nlm),"1");
Instructions.c:740:    input_int("nz_410",&(E->viscosity.n410),"1");
Instructions.c:741:    input_int("nz_lith",&(E->viscosity.nlith),"1");
Instructions.c:742:    input_int("nz_moho",&(E->viscosity.ncrust1),"1");
Instructions.c:743:    input_int("nz_mid_moho",&(E->viscosity.ncrust2),"1");
Instructions.c:744:    input_float("z_dd",&(E->viscosity.zdd),"1.0");
Instructions.c:745:    input_float("z_lmantle",&(E->viscosity.zlm),"1.0");
Instructions.c:746:    input_float("z_410",&(E->viscosity.z410),"1.0");
Instructions.c:747:    input_float("z_lith",&(E->viscosity.zlith),"0.0");
Instructions.c:748:    input_float("z_moho",&(E->viscosity.zcrust1),"0.0");
Instructions.c:749:    input_float("z_mid_moho",&(E->viscosity.zcrust2),"0.0");
Instructions.c:751:    E->viscosity.zcrust1 = 1.0 - E->viscosity.zcrust1/E->sphere.ro_dim;
Instructions.c:752:    E->viscosity.zcrust2 = 1.0 - E->viscosity.zcrust2/E->sphere.ro_dim;
Instructions.c:753:    E->viscosity.zlith = 1.0 - E->viscosity.zlith/E->sphere.ro_dim;
Instructions.c:754:    E->viscosity.z410 = 1.0 - E->viscosity.z410/E->sphere.ro_dim;
Instructions.c:755:    E->viscosity.zlm = 1.0 - E->viscosity.zlm/E->sphere.ro_dim;
Instructions.c:756:    E->viscosity.zdd = 1.0 - E->viscosity.zdd/E->sphere.ro_dim;
Instructions.c:759:    input_float("dimenx",&(E->mesh.layer[1]),"nodefault");
Instructions.c:760:    E->mesh.layer[1] = E->mesh.layer[1]*M_PI;
Instructions.c:762:    input_int("nodex",&(E->mesh.nox),"nodefault,1,nomax");
Instructions.c:763:    input_int("nodez",&(E->mesh.noz),"nodefault,1,nomax");
Instructions.c:764:    input_int("nodey",&(E->mesh.noy),"1,1,nomax");
Instructions.c:765:    input_boolean("aug_lagr",&(E->control.augmented_Lagr),"off");
Instructions.c:766:    input_double("aug_number",&(E->control.augmented),"0.0");
Instructions.c:768:    input_float("tole_compressibility",&(E->control.tole_comp),"0.0");
Instructions.c:769:    input_boolean("orthogonal",&(E->control.ORTHO),"on");
Instructions.c:771:    input_int("storage_spacing",&(E->control.record_every),"10");
Instructions.c:772:    input_int("storage_always_before",&(E->control.record_all_until),"5");
Instructions.c:774:    input_boolean("precond",&(E->control.precondition),"off");
Instructions.c:775:    input_boolean("vprecond",&(E->control.vprecondition),"on");
Instructions.c:776:    input_int("mg_cycle",&(E->control.mg_cycle),"2,0,nomax");
Instructions.c:777:    input_int("down_heavy",&(E->control.down_heavy),"1,0,nomax");
Instructions.c:778:    input_int("up_heavy",&(E->control.up_heavy),"1,0,nomax");
Instructions.c:779:    input_double("accuracy",&(E->control.accuracy),"1.0e-4,0.0,1.0");
Instructions.c:780:    input_int("viterations",&(E->control.max_vel_iterations),"250,0,nomax");
Instructions.c:783:    input_int("vhighstep",&(E->control.v_steps_high),"1,0,nomax");
Instructions.c:784:    input_int("vlowstep",&(E->control.v_steps_low),"250,0,nomax");
Instructions.c:785:    input_int("vupperstep",&(E->control.v_steps_upper),"1,0,nomax");
Instructions.c:786:    input_int("piterations",&(E->control.p_iterations),"100,0,nomax");
Instructions.c:787:    input_int("maxsamevisc",&(E->control.max_same_visc),"25,0,nomax");
Instructions.c:791:  input_float("ReferenceT",&(E->data.ref_temperature),"2600.0");
Instructions.c:793:  E->rad_heat.num = 0;
Instructions.c:795:  input_int("int_heating_control",&(E->rad_heat.num),"0");
Instructions.c:796:  fprintf(E->fp,"n_rad %d\n",E->rad_heat.num);
Instructions.c:798:  if (E->rad_heat.num>=2)  {
Instructions.c:799:     input_double("concen_u",&(E->rad_heat.concen_u),"0.0");
Instructions.c:800:     input_double_vector("percent",E->rad_heat.num,(E->rad_heat.percent));
Instructions.c:801:     input_double_vector("heat_g",E->rad_heat.num,(E->rad_heat.heat_g));
Instructions.c:802:     input_double_vector("decay_time",E->rad_heat.num,(E->rad_heat.decay_t));
Instructions.c:803:     E->rad_heat.concen[0]=E->rad_heat.concen_u;
Instructions.c:804:     E->rad_heat.concen[1]=E->rad_heat.concen_u;
Instructions.c:805:     E->rad_heat.concen[2]=E->rad_heat.concen_u*4;
Instructions.c:806:     E->rad_heat.concen[3]=E->rad_heat.concen_u*10000;
Instructions.c:807:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[0],E->rad_heat.heat_g[0],E->rad_heat.decay_t[0],E->rad_heat.concen[0]);
Instructions.c:808:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[1],E->rad_heat.heat_g[1],E->rad_heat.decay_t[1],E->rad_heat.concen[1]);
Instructions.c:809:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[2],E->rad_heat.heat_g[2],E->rad_heat.decay_t[2],E->rad_heat.concen[2]);
Instructions.c:810:     fprintf(E->fp,"Rad_heat %.4e %.4e %.4e %.4e\n",E->rad_heat.percent[3],E->rad_heat.heat_g[3],E->rad_heat.decay_t[3],E->rad_heat.concen[3]);
Instructions.c:811:     fflush(E->fp);
Instructions.c:814:     input_float("Q0",&(E->control.Q0),"0.0");
Instructions.c:816:  input_float("Qc",&(E->control.Qc),"0.0"); /* Heat produced in core */
Instructions.c:817:  input_int("tidal_heating",&(E->control.tidal_heating),"0");
Instructions.c:818:  input_int("shear_heating",&(E->control.shear_heating),"0");
Instructions.c:819:  input_int("despin",&(E->control.despin),"0");
Instructions.c:820:  input_int("freezing",&(E->control.freezing),"0");
Instructions.c:821:  E->sphere.deltarb = 0.0;
Instructions.c:824:  input_int("impacts",&(E->impacts.number),"0");
Instructions.c:825:  E->impacts.now = -1;  /* Negative is default, no impact occuring */
Instructions.c:827:  E->data.visc_factor = 1.0;
Instructions.c:828:  E->data.therm_exp_factor = 1.0;
Instructions.c:829:  E->data.therm_diff_factor = 1.0;
Instructions.c:831:  input_float("layerd",&(E->data.layer_km),"2800.0");
Instructions.c:832:  input_float("gravacc",&(E->data.grav_acc),"9.81");
Instructions.c:833:  input_float("thermexp",&(E->data.therm_exp),"3.28e-5");
Instructions.c:834:  input_float("thermexp_factor",&(E->data.therm_exp_factor),"3.28e-5");
Instructions.c:835:  input_float("visc_factor",&(E->data.visc_factor),"3.28e-5");
Instructions.c:836:  input_float("cp",&(E->data.Cp),"1200.0");
Instructions.c:837:  input_float("latent",&(E->data.Hf),"3.3355e5");
Instructions.c:838:  input_float("thermdiff",&(E->data.therm_diff),"8.0e-7");
Instructions.c:839:  input_float("thermdiff_factor",&(E->data.therm_diff_factor),"8.0e-7");
Instructions.c:840:  input_float("thermcond",&(E->data.therm_cond),"3.168");
Instructions.c:841:  input_float("density",&(E->data.density),"3340.0");
Instructions.c:842:  input_float("lmdensity",&(E->data.density_lm),"3340.0");
Instructions.c:843:  input_float("mdensity",&(E->data.melt_density),"2800.0");
Instructions.c:844:  input_float("wdensity",&(E->data.density_above),"1030.0");
Instructions.c:845:  input_float("rdensity",&(E->data.res_density),"3295.0");
Instructions.c:846:  input_float("coredensity",&(E->data.density_core),"3500.0");
Instructions.c:847:  input_float("heatflux",&(E->data.surf_heat_flux),"4.4e-2");
Instructions.c:848:  input_float("refvisc",&(E->data.ref_viscosity),"nodefault");
Instructions.c:849:  input_float("meltvisc",&(E->data.melt_viscosity),"nodefault");
Instructions.c:850:  input_float("surftemp",&(E->data.surf_temp),"0.0");
Instructions.c:851:  input_float("dispation_number",&(E->data.disptn_number),"0.0");
Instructions.c:853:  input_float("youngs",&(E->data.youngs_mod),"1.0e11");
Instructions.c:854:  input_float("Te",&(E->data.Te),"0.0");
Instructions.c:855:  input_float("Tsol0",&(E->data.T_sol0),"1373.0");
Instructions.c:856:  input_float("dTsoldz",&(E->data.dTsol_dz),"3.4e-3");
Instructions.c:857:  input_float("dTsoldF",&(E->data.dTsol_dF),"440.0");
Instructions.c:858:  input_float("dTdz",&(E->data.dT_dz),"0.48e-3");
Instructions.c:859:  input_float("deltaS",&(E->data.delta_S),"250.0");
Instructions.c:860:  input_float("gasconst",&(E->data.gas_const),"8.3");     /* not much cause to change these ! */
Instructions.c:861:  input_float("gravconst",&(E->data.grav_const),"6.673e-11");
Instructions.c:862:  input_float("permeability",&(E->data.permeability),"3.0e-10");
Instructions.c:865:  input_double("frequency",&(E->data.frequency),"7.3e-5");
Instructions.c:866:  input_double("rot_init",&(E->data.rot_init),"7.3e-5");
Instructions.c:867:  input_double("rot_final",&(E->data.rot_final),"7.3e-5");
Instructions.c:868:  input_double("semimajor_axis",&(E->data.semimajor_axis),"1.5e11");
Instructions.c:869:  input_double("mass_primary",&(E->data.mass_primary),"2.0e30");
Instructions.c:870:  input_double("moi",&(E->data.moi),"0.4");
Instructions.c:872:  input_double("rigidity",&(E->data.rigidity),"4.0e9");
Instructions.c:874:	E->data.DeltaT = E->data.ref_temperature /  (1.0 + E->data.surf_temp);
Instructions.c:875:  E->monitor.time_scale = E->sphere.ro_dim*E->sphere.ro_dim/(E->data.therm_diff*3600.0*24.0*365.25);   /* years*/
Instructions.c:877: (E->problem_settings)(E);
Instructions.c:880: sprintf(qfile,"%s.q%d.dat",E->control.data_file,E->control.restart_frame);
Instructions.c:882:	  E->fpq = stdout;
Instructions.c:884:	  E->fpq = fpq;
Instructions.c:893:  for(i=1;i<=E->mesh.nno;i++)
Instructions.c:894:    { if ((E->node[i] & VBX) && (E->node[i] & SBX))
Instructions.c:896:      if ((E->node[i] & VBZ) && (E->node[i] & SBZ))
Instructions.c:898:      if ((E->node[i] & VBY) && (E->node[i] & SBY))
Instructions.c:900:      if ((E->node[i] & TBX) && (E->node[i] & FBX))
Instructions.c:902:      if ((E->node[i] & TBZ) && (E->node[i] & FBZ))
Instructions.c:904:      if ((E->node[i] & TBY) && (E->node[i] & FBY))
Instructions.c:907:  for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Instructions.c:908:    for(i=1;i<=E->mesh.NNO[lev];i++)
Instructions.c:909:      { if ((E->NODE[lev][i] & VBX) && (E->NODE[lev][i]  & SBX))
Instructions.c:911:	if ((E->NODE[lev][i]  & VBZ) && (E->NODE[lev][i]  & SBZ))
Instructions.c:913:	if ((E->NODE[lev][i]  & VBY) && (E->NODE[lev][i]  & SBY))
Instructions.c:927:  E->eco = E->ECO[E->mesh.levmax]; 
Instructions.c:928:  E->ien = E->IEN[E->mesh.levmax];
Instructions.c:929:  E->id = E->ID[E->mesh.levmax];
Instructions.c:930:  E->lm = E->LMD[E->mesh.levmax];
Instructions.c:931:  E->Vi = E->VI[E->mesh.levmax];
Instructions.c:932:  E->EVi = E->EVI[E->mesh.levmax];
Instructions.c:933:  E->node = E->NODE[E->mesh.levmax];
Instructions.c:934:  E->tw = E->TW[E->mesh.levmax];
Instructions.c:935:  E->Mass = E->MASS[E->mesh.levmax];
Instructions.c:936:  for (i=1;i<=E->mesh.nsd;i++)
Instructions.c:937:    E->X[i] = E->XX[E->mesh.levmax][i];
Instructions.c:944:{ if(E->control.verbose)
Instructions.c:954:{ if(E->control.verbose)
Instructions.c:955:    { fprintf(E->fp,"%s\n",string);
Instructions.c:956:      fflush(E->fp);
Instructions.c:996:    for(i=1;i<=E->mesh.npno;i++)
Instructions.c:997:	    E->P[i]=0.0;
Instructions.c:1007:    for(i=1;i<=E->mesh.nnov;i++)   {
Instructions.c:1008:	E->V[1][i]=0.0;
Instructions.c:1009:	E->V[2][i]=0.0;
Instructions.c:1012:    if(E->mesh.dof==3)   {
Instructions.c:1013: 	for(i=1;i<=E->mesh.nnov;i++)
Instructions.c:1014:	    E->V[3][i]=0.0;
Nodal_mesh.c:24:  const int dims = E->mesh.nsd;
Nodal_mesh.c:26:  input_int("r_grid_layers",&(E->segment.zlayers),"1");
Nodal_mesh.c:27:  input_float_vector("rr",E->segment.zlayers,(E->segment.zzlayer));
Nodal_mesh.c:28:  input_int_vector("nr",E->segment.zlayers,(E->segment.nzlayer));
Nodal_mesh.c:30:  input_int("theta_grid_layers",&(E->segment.xlayers),"1");
Nodal_mesh.c:31:  input_float_vector("theta",E->segment.xlayers,(E->segment.xxlayer));
Nodal_mesh.c:32:  input_int_vector("ntheta",E->segment.xlayers,(E->segment.nxlayer));
Nodal_mesh.c:35:     for(d=1;d<=E->mesh.nsd;d++) {
Nodal_mesh.c:36:       XX[d] = (float *)malloc((2+E->mesh.nnx[d])*sizeof(float)); 
Nodal_mesh.c:40:     dx[1] = E->mesh.layer[1]/(E->mesh.nnx[1]-1);
Nodal_mesh.c:42:     for(i=2;i<=E->mesh.nnx[1];i++)
Nodal_mesh.c:45:     dx[2] = (E->sphere.ro-E->sphere.ri)/(E->mesh.nnx[2]-1);
Nodal_mesh.c:46:     XX[2][1] = E->sphere.ri;
Nodal_mesh.c:47:     for(i=2;i<=E->mesh.nnx[2];i++)
Nodal_mesh.c:50:  for (j=1;j<E->segment.xlayers;j++)
Nodal_mesh.c:51:    dxx[j] = (E->segment.xxlayer[j]-E->segment.xxlayer[j-1])*M_PI
Nodal_mesh.c:52:            /(E->segment.nxlayer[j]-E->segment.nxlayer[j-1]);
Nodal_mesh.c:54:  for(i=2;i<E->mesh.nnx[1];i++)   {
Nodal_mesh.c:55:    if (i<=E->segment.nxlayer[j])
Nodal_mesh.c:57:    if (i==E->segment.nxlayer[j])
Nodal_mesh.c:61:  for (j=1;j<E->segment.zlayers;j++)
Nodal_mesh.c:62:    dxx[j] = (E->segment.zzlayer[j]-E->segment.zzlayer[j-1])
Nodal_mesh.c:63:            /(E->segment.nzlayer[j]-E->segment.nzlayer[j-1]);
Nodal_mesh.c:65:  for(i=2;i<E->mesh.nnx[2];i++)   {
Nodal_mesh.c:66:    if (i<=E->segment.nzlayer[j])
Nodal_mesh.c:68:    if (i==E->segment.nzlayer[j])
Nodal_mesh.c:72:   for(d=1;d<=E->mesh.nsd;d++)
Nodal_mesh.c:73:     for(i=1;i<=E->mesh.nnx[d];i++)
Nodal_mesh.c:74:       E->XP[d][i] = XX[d][i]; 
Nodal_mesh.c:76:   for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Nodal_mesh.c:78:     nox=E->mesh.NOX[lev]; 
Nodal_mesh.c:79:     noy=E->mesh.NOY[lev];
Nodal_mesh.c:80:     noz=E->mesh.NOZ[lev];
Nodal_mesh.c:82:    if (E->control.NMULTIGRID||E->control.EMULTIGRID)
Nodal_mesh.c:83:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Nodal_mesh.c:91:           for(d=1;d<=E->mesh.nsd;d++)
Nodal_mesh.c:92:             E->XX[lev][d][node] = XX[d][(ijk[d]-1)*step+1]; 
Nodal_mesh.c:96:     for(d=1;d<=E->mesh.nsd;d++) {
Nodal_mesh.c:101:  if (E->control.verbose) 
Nodal_mesh.c:102:    for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Nodal_mesh.c:103:      fprintf(E->fp,"output_coordinates %d\n",lev);
Nodal_mesh.c:105:         for (i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:106:             fprintf(E->fp,"%d %g %g\n",i,E->XX[lev][1][i],E->XX[lev][2][i]);
Nodal_mesh.c:109:         for (i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:110:             fprintf(E->fp,"%d %g %g %g\n",i,E->XX[lev][1][i],E->XX[lev][2][i],E->XX[lev][3][i]);
Nodal_mesh.c:137:  for(node=1;node<=E->mesh.NNO[lev];node++)
Nodal_mesh.c:140:  for(element=1;element<=E->mesh.NEL[lev];element++) {
Nodal_mesh.c:142:      for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Nodal_mesh.c:143:     	  node = E->IEN[lev][element].node[j];
Nodal_mesh.c:144:    	  PN[node] += P[element] * E->TW[lev][node] ; 
Nodal_mesh.c:158:  for(node=1;node<=E->mesh.NNO[lev];node++)
Nodal_mesh.c:161:  for(element=1;element<=E->mesh.NEL[lev];element++) {
Nodal_mesh.c:163:      for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Nodal_mesh.c:164:     	  node = E->IEN[lev][element].node[j];
Nodal_mesh.c:165:    	  PN[node] += P[element] * E->TW[lev][node] ; 
Nodal_mesh.c:181:   for(p=1;p<=E->mesh.NEL[lev];p++)
Nodal_mesh.c:184:   weight=1.0/((double)enodes[E->mesh.nsd]) ;
Nodal_mesh.c:186:   for(p=1;p<=E->mesh.NEL[lev];p++)
Nodal_mesh.c:187:     for(j=1;j<=enodes[E->mesh.nsd];j++)
Nodal_mesh.c:188:       P[p] +=  PN[E->IEN[lev][p].node[j]] * weight;
Nodal_mesh.c:201:   const int nsd=E->mesh.nsd;
Nodal_mesh.c:205:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:209:          VE[(e-1)*vpts + i] += VN[E->IEN[lev][e].node[j]] *  E->N.vpt[GNVINDEX(j,i)];
Nodal_mesh.c:221:    const int nsd=E->mesh.nsd;
Nodal_mesh.c:225:    for(i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:228:    for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:230:        n = E->IEN[lev][e].node[j];
Nodal_mesh.c:232:          VN[n] += E->N.vpt[GNVINDEX(j,i)] * E->TW[lev][n] * VE[(e-1)*vpts + i];
Nodal_mesh.c:245:   const int nsd=E->mesh.nsd;
Nodal_mesh.c:249:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:253:          VE[(e-1)*vpts + i] += log(VN[E->IEN[lev][e].node[j]]) *  E->N.vpt[GNVINDEX(j,i)];
Nodal_mesh.c:266:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:271:  for(i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:274:  for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:276:      n = E->IEN[lev][e].node[j];
Nodal_mesh.c:279:	temp_visc += E->TW[lev][n] * log(E->N.vpt[GNVINDEX(j,i)] * VE[(e-1)*vpts + i]);
Nodal_mesh.c:291:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:296:   for(i=1;i<=E->mesh.NNO[lev];i++)
Nodal_mesh.c:299:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:301:       n = E->IEN[lev][e].node[j];
Nodal_mesh.c:304:         temp_visc += E->TW[lev][n] * E->N.vpt[GNVINDEX(j,i)] * VE[(e-1)*vpts + i];
Nodal_mesh.c:319:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:323:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:327:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:331:         temp_visc += E->N.vpt[GNVINDEX(j,i)]*VN[E->IEN[lev][e].node[j]];
Nodal_mesh.c:345:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:350:   for(i=1;i<=E->mesh.NEL[lev];i++)
Nodal_mesh.c:353:   for(e=1;e<=E->mesh.NEL[lev];e++)   {
Nodal_mesh.c:373:  const int nsd=E->mesh.nsd;
Nodal_mesh.c:378:   for(e=1;e<=E->mesh.NEL[lev];e++)
Nodal_mesh.c:382:   for(e=1;e<=E->mesh.NEL[lev];e++)
Output.c:38:  const int nno = E->mesh.nno;
Output.c:45:  if (been_here==0 && E->control.restart==0) {
Output.c:48:    sprintf(output_file,"%s/coord.%d",E->control.data_file,file_number);
Output.c:50:    fprintf(fp0,"%6d %6d %.5e\n",E->mesh.nno,E->advection.timesteps,E->monitor.elapsed_time);
Output.c:51:    for (i=1;i<=E->mesh.nno;i++)
Output.c:52:      fprintf(fp0,"%6d %.3e %.3e %.5e %.5e %.5e %.5e %.4e\n",i,E->X[1][i],E->X[2][i],E->V[1][i],E->V[2][i],E->T[i],E->C[i],E->Vi[i]);
Output.c:55:    sprintf(output_file,"%s/coord_elem.%d",E->control.data_file,file_number);
Output.c:57:    fprintf(fp0,"%6d %6d %.5e\n",E->mesh.nel,E->advection.timesteps,E->monitor.elapsed_time);
Output.c:58:    for (i=1;i<=E->mesh.nel;i++)
Output.c:59:      fprintf(fp0,"%6d %.3e %.3e\n",i,E->eco[i].centre[1],E->eco[i].centre[2]);
Output.c:65:  if ((E->advection.timesteps%(E->control.record_every)) == 0)   {
Output.c:68:    sprintf(output_file,"%s/temp_comp.%d",E->control.data_file,file_number);
Output.c:71:    fprintf(fp0,"%6d %6d %.5e %.5e %.5e\n",E->mesh.nno,E->advection.timesteps,E->monitor.elapsed_time,E->monitor.deltah);
Output.c:73:    if (E->control.composition) {
Output.c:74:      if ((E->advection.timesteps%(20*E->control.record_every)) == 0)  {
Output.c:75:        for (i=1;i<=E->mesh.nno;i++) {
Output.c:76:					k = ((i-1) % E->mesh.noz) + 1;
Output.c:78:										E->T[i],E->C[i],E->Fm[i],E->C_prev[i],
Output.c:79:										(E->T[i]-E->solidus[k]),E->V[1][i],E->V[2][i]);
Output.c:81:        for (i=1;i<=E->mesh.nel;i++)
Output.c:82:          fprintf(fp0,"%.4e\n",E->P[i]);
Output.c:85:        for (i=1;i<=E->mesh.nno;i++) {
Output.c:86:					k = ((i-1) % E->mesh.noz) + 1;
Output.c:87:          fprintf(fp0,"%.4e %.4e %.4e %.4e %.4e\n",E->T[i],E->C[i],E->Fm[i],
Output.c:88:										E->C_prev[i],(E->T[i]-E->solidus[k]));
Output.c:92:      if ((E->advection.timesteps%(20*E->control.record_every)) == 0)  {
Output.c:93:        for (i=1;i<=E->mesh.nno;i++)
Output.c:94:          fprintf(fp0,"%.5e %.4e %.4e %.4e\n",E->T[i],E->heatflux[i],E->V[1][i],E->V[2][i]);
Output.c:95:        for (i=1;i<=E->mesh.nel;i++)
Output.c:96:          fprintf(fp0,"%.4e\n",E->P[i]);
Output.c:99:        for (i=1;i<=E->mesh.nno;i++)
Output.c:100:          fprintf(fp0,"%.5e %.4e\n",E->T[i],E->heatflux[i]);
Output.c:107: if (E->control.composition && strcmp(E->control.comp_adv_method,"particle")==0 && (E->advection.timesteps%(1*E->control.record_every) == 0) && (E->advection.timesteps >= 0) ){
Output.c:109:    sprintf(output_file,"%s/traces.%d",E->control.data_file,file_number);
Output.c:111:    fprintf(fp0,"%6d %6d %.5e\n",E->advection.markers,
Output.c:112:						E->advection.timesteps,E->monitor.elapsed_time);
Output.c:113:    for (i=1;i<=E->advection.markers;i++)
Output.c:114:      /*fprintf(fp0,"%.5e %.5e %d %d\n",E->XMC[1][i],E->XMC[2][i],
Output.c:115:							E->CElement[i],E->C12[i]);*/
Output.c:116:      fprintf(fp0,"%.5e %.5e %d %g\n",E->XMC[1][i],E->XMC[2][i],
Output.c:117:							E->CElement[i],E->C12f[i]);
Output.c:118:		/*if(E->advection.timesteps > 0)
Output.c:119:    for (i=1;i<=E->mesh.nel;i++)
Output.c:120:      fprintf(fp0,"%d %g %d %d\n",i,E->CE[i],E->advection.element[0][i],
Output.c:121:							E->advection.element[1][i]);*/
Output.c:125:if (E->control.composition && (strcmp(E->control.comp_adv_method,"particle")==0) && (E->advection.timesteps%(E->control.record_every)) == 0)  {
Output.c:126:		if(E->advection.timesteps >= (0)) {
Output.c:127:      sprintf(output_file,"%s/etraces.%d",E->control.data_file,
Output.c:131:							E->advection.timesteps,E->monitor.elapsed_time,
Output.c:132:							E->advection.markers,E->advection.marker_type[0],
Output.c:133:							E->advection.marker_type[1],E->advection.marker_type_prev[0],
Output.c:134:							E->advection.marker_type_prev[1]);
Output.c:135:      for (i=1;i<=E->mesh.nel;i++)
Output.c:136:        fprintf(fp0,"%d %g %g %g %g %d %d | %d %d\n",i,E->eco[i].area,
Output.c:137:					E->CE[i],E->FmE[i],E->CE_prev[i],E->advection.element[0][i],
Output.c:138:					E->advection.element[1][i],E->advection.element_prev[0][i],
Output.c:139:					E->advection.element_prev[1][i]);
Output.c:146:  if ((E->advection.timesteps%(E->control.record_every)) == 0)   {
Output.c:150:    for (i=1;i<=E->mesh.nox;i++)  {
Output.c:151:      j=i*E->mesh.noz;
Output.c:153:        surf += (E->slice.shflux[i]+E->slice.shflux[i-1])*0.5*
Output.c:154:           sin(0.5*(E->X[1][j]+E->X[1][j-E->mesh.noz]))*
Output.c:155:           (E->X[1][j]-E->X[1][j-E->mesh.noz]);
Output.c:156:        botm += (E->slice.bhflux[i]+E->slice.bhflux[i-1])*0.5*
Output.c:157:           sin(0.5*(E->X[1][j]+E->X[1][j-E->mesh.noz]))*
Output.c:158:           (E->X[1][j]-E->X[1][j-E->mesh.noz]);
Output.c:161:    surf = surf/(1.0-cos(E->X[1][E->mesh.nno]));
Output.c:162:    botm = botm/(1.0-cos(E->X[1][E->mesh.nno]));
Output.c:166:    if(E->control.secular)
Output.c:170:    for (i=1;i<=E->mesh.nno;i++){
Output.c:171:      SV[i] = sqrt(E->V[1][i]*E->V[1][i] + E->V[2][i]*E->V[2][i]);
Output.c:172:      logVi[i] = log(E->Vi[i]);
Output.c:175:    return_horiz_ave(E,SV,E->Have.vrms);
Output.c:176:    return_horiz_ave(E,logVi,E->Have.Vi);
Output.c:177:    for (i=1;i<=E->mesh.noz;i++)
Output.c:178:			E->Have.Vi[i] = exp(E->Have.Vi[i]);
Output.c:179:    return_horiz_ave(E,E->T,E->Have.T);
Output.c:180:    return_horiz_ave(E,E->C,E->Have.Rho);
Output.c:181:/*    E->Total.melt_prod = 0.0;
Output.c:182:    for (i=1;i<=E->mesh.elx;i++)
Output.c:183:			E->Total.melt_prod += E->slice.melt[i];
Output.c:185:    sprintf(output_file,"%s/ave.%d",E->control.data_file,file_number);
Output.c:189:						E->mesh.nno,E->advection.timesteps,E->monitor.elapsed_time,
Output.c:190:						surf,botm,E->rad_heat.total,E->data.T_adi0,E->data.T_adi1,
Output.c:191:						E->Total.melt_prod,E->Total.bulk_comp,E->Total.bulk_comp_prev,
Output.c:192:            E->sphere.deltarb);
Output.c:193:    for (i=1;i<=E->mesh.noz;i++)
Output.c:194:      fprintf(fp1,"%.4e %.5e %.5e %.5e %.5e %.5e %.4e %.4e\n",E->X[2][i],E->Have.T[i],E->Have.vrms[i],E->Have.f[i],E->Have.F[i],E->Have.Rho[i],E->Have.Vi[i],E->Have.Tadi[i]);
Output.c:198:    sprintf(output_file,"%s/surf.%d",E->control.data_file,file_number);
Output.c:200:    for (i=1;i<=E->mesh.nox;i++)  {
Output.c:201:      j=i*E->mesh.noz;
Output.c:202:      fprintf(fp1,"%.4e %.5e %.5e %.5e %.5e\n",E->X[1][j],E->slice.tpg[i],E->slice.tpgb[i],E->slice.shflux[i],E->slice.bhflux[i]);
Output.c:206:    sprintf(output_file,"%s/esurf.%d",E->control.data_file,file_number);
Output.c:208:    for (i=1;i<=E->mesh.elx;i++)  {
Output.c:209:      j=i*E->mesh.elz;
Output.c:210:      fprintf(fp1,"%.4e %.5e %.5e\n",E->eco[j].centre[1],E->slice.melt[i],E->slice.new_melt[i]);
Output.c:227:  E->ibm_dx.x1 = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Output.c:228:  E->ibm_dx.x2 = (float *) malloc((E->mesh.nno+1)*sizeof(float));
Output.c:230:  E->ibm_dx.nox = E->mesh.nox;
Output.c:231:  E->ibm_dx.noz = E->mesh.noz;
Output.c:233:   for (i=1;i<=E->mesh.nno;i++)   {
Output.c:234:      E->ibm_dx.x1[i] = E->X[2][i] * sin(E->X[1][i]);
Output.c:235:      E->ibm_dx.x2[i] = E->X[2][i] * cos(E->X[1][i]);
Output.c:256:   sprintf(output_file,"%s/mv.%03d.dx",E->control.data_file,nframe);
Output.c:258:   for (i=1;i<=E->mesh.nno;i++)
Output.c:259:     fprintf(fp,"%g %g %g\n",E->ibm_dx.x1[i]+offset1,E->ibm_dx.x2[i],E->T[i]);
Output.c:262:   sprintf(output_file,"%s/nv.%03d.dx",E->control.data_file,nframe);
Output.c:264:   for (i=1;i<=E->mesh.nno;i++)
Output.c:265:     fprintf(fp,"%g %g %g\n",E->ibm_dx.x1[i]+offset2,E->ibm_dx.x2[i],E->C[i]);
Output.c:268:   sprintf(output_file,"%s/mv.%03d.general",E->control.data_file,nframe);
Output.c:271:   fprintf(fp,"grid = %2d x %2d\n",E->ibm_dx.nox,E->ibm_dx.noz);
Output.c:282:   sprintf(output_file,"%s/nv.%03d.general",E->control.data_file,nframe);
Output.c:285:   fprintf(fp,"grid = %2d x %2d\n",E->ibm_dx.nox,E->ibm_dx.noz);
Output.c:313:  const int nno = E->mesh.nno;
Output.c:315:  if (been_here==0 && E->control.restart==0) {
Output.c:316:    sprintf(output_file,"%s.velo",E->control.data_file);
Output.c:317:    E->filed[10]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:318:    sprintf(output_file,"%s.topo_t",E->control.data_file);
Output.c:319:    E->filed[11]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:320:    sprintf(output_file,"%s.topo_b",E->control.data_file);
Output.c:321:    E->filed[12]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:322:    sprintf(output_file,"%s.visc",E->control.data_file);
Output.c:323:    E->filed[13]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:324:    sprintf(output_file,"%s.fas670",E->control.data_file);
Output.c:325:    E->filed[14]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:326:    sprintf(output_file,"%s.stress",E->control.data_file);
Output.c:327:    E->filed[9]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:331:    ii = E->mesh.nsf;
Output.c:334:    size2 = (E->mesh.nel+1)*sizeof(float);
Output.c:339:  ii = E->mesh.nsf;
Output.c:342:  write(E->filed[10],SV,size2);
Output.c:344:  size2 = (E->mesh.nsf+1)*sizeof(float);
Output.c:345:  write(E->filed[11],E->slice.tpg,size2);
Output.c:346:  write(E->filed[12],E->slice.tpgb,size2);
Output.c:348:  size2 = (E->mesh.nel+1)*sizeof(float);
Output.c:350:  write(E->filed[13],EV,size2);
Output.c:352:  size2 = (E->mesh.nsf+1)*sizeof(float);
Output.c:353:  write(E->filed[14],E->Fas670_b,size2);
Output.c:355:  size2 = (2*E->mesh.nsf+1)*sizeof(float);
Output.c:356:  write(E->filed[9],E->stress,size2);
Output.c:373:  if (been_here==0 && E->control.restart==0) {
Output.c:374:    sprintf(output_file,"%s.temp",E->control.data_file);
Output.c:375:    E->filed[5]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:379:    temp1 = (int *) malloc ((E->mesh.noy*6)*sizeof(int));
Output.c:381:    sprintf(output_file,"%s.mesh",E->control.data_file);
Output.c:382:    E->filed[1]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:383:    sprintf(output_file,"%s.x",E->control.data_file);
Output.c:384:    E->filed[2]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:385:    sprintf(output_file,"%s.z",E->control.data_file);
Output.c:386:    E->filed[3]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:387:    sprintf(output_file,"%s.y",E->control.data_file);
Output.c:388:    E->filed[4]=open(output_file,O_RDWR | O_CREAT, 0644);
Output.c:390:    size1 = (E->mesh.noy*6)*sizeof(int);
Output.c:391:    size2= (E->mesh.nno+1)*sizeof(float);
Output.c:393:    temp1[1] = E->mesh.nno;
Output.c:395:    temp1[5] = E->mesh.nsf;
Output.c:396:    temp1[6] = E->mesh.nel;
Output.c:398:        write(E->filed[1],temp1,size1);
Output.c:399:        write(E->filed[2],E->X[1],size2);
Output.c:400:        write(E->filed[3],E->X[2],size2);
Output.c:401:        write(E->filed[4],E->X[3],size2);
Output.c:403:    close(E->filed[1]);
Output.c:404:    close(E->filed[2]);
Output.c:405:    close(E->filed[3]);
Output.c:406:    close(E->filed[4]);
Output.c:412:    write(E->filed[5],E->T,size2);
Pan_problem_misc_functions.c:39:    sprintf(unique_name,"%06d.%s-%s",E->control.PID,comment,name);
Pan_problem_misc_functions.c:57:    H = (float *)malloc( (E->mesh.noz+1)*sizeof(float));
Pan_problem_misc_functions.c:59:    buoyancy_enhancement = E->data.density_lm/E->data.density;
Pan_problem_misc_functions.c:61:    if (abs(E->control.Ra_670)>0.0 || abs(E->control.Ra_410)>0.0)   {
Pan_problem_misc_functions.c:63:      phase_change(E,E->Fas670,E->Fas670_b,E->Fas410,E->Fas410_b);
Pan_problem_misc_functions.c:65:      for(i=1;i<=E->mesh.nno;i++)
Pan_problem_misc_functions.c:66:        E->buoyancy[i] = -E->control.Ra_670 * E->Fas670[i] - E->control.Ra_410 * E->Fas410[i];
Pan_problem_misc_functions.c:69:      for(i=1;i<=E->mesh.nno;i++)
Pan_problem_misc_functions.c:70:        E->buoyancy[i] = 0.0;
Pan_problem_misc_functions.c:72:   for(i=1;i<=E->mesh.nno;i++)   {
Pan_problem_misc_functions.c:75:/*        E->buoyancy[i] = E->control.Ra_temp * E->T[i] * E->X[2][i]
Pan_problem_misc_functions.c:76:                       + E->control.Ra_comp * E->C[i] * E->X[2][i];
Pan_problem_misc_functions.c:81:       j = (i-1)%(E->mesh.noz)+1;
Pan_problem_misc_functions.c:82:       E->buoyancy[i] += E->control.Ra_temp * E->T[i] 
Pan_problem_misc_functions.c:83:                      * E->expansivity[j]
Pan_problem_misc_functions.c:84:                      - E->control.Ra_comp * E->C[i]; 
Pan_problem_misc_functions.c:88: *  This may not be the best way to do this. Better to use E->C ?
Pan_problem_misc_functions.c:91:	if(E->X[2][i] <= E->viscosity.nlm)
Pan_problem_misc_functions.c:92:		E->buoyancy[i] *= buoyancy_enhancement;
Pan_problem_misc_functions.c:96:       j = (i-1)%(E->mesh.noz)+1;
Pan_problem_misc_functions.c:97:	Ddens = E->data.density_core/E->data.density - 1.0;
Pan_problem_misc_functions.c:98:	Rc = E->sphere.ri;
Pan_problem_misc_functions.c:99:	r = E->X[2][i];
Pan_problem_misc_functions.c:101:	E->buoyancy[i] += (E->control.Ra_temp * E->T[i] * E->expansivity[j]
Pan_problem_misc_functions.c:102:                      - E->control.Ra_comp * E->C[i]) * g;
Pan_problem_misc_functions.c:104:	if(i<=E->mesh.noz && E->monitor.solution_cycles==0)
Pan_problem_misc_functions.c:110:  if (E->impacts.now >= 0) {
Pan_problem_misc_functions.c:111:    E->buoyancy[i] += 1.0*E->control.Ra_temp * (E->impacts.H_t[i]/E->sphere.ro_dim) / (E->sphere.ro - E->sphere.ri);
Pan_problem_misc_functions.c:114:      fprintf(E->fp,"Isostatic rebound!!!\n");
Pan_problem_misc_functions.c:120:    remove_horiz_ave(E,E->buoyancy,H,0);
Pan_problem_misc_functions.c:213:	fprintf(E->fp,"No previous %s information found in input file\n",name);fflush(E->fp);
Pan_problem_misc_functions.c:218:    fprintf(E->fp,"Previous %s information is in file %s\n",name,filename);fflush(E->fp);
Pan_problem_misc_functions.c:223:	fprintf(E->fp,"Unable to open the required file `%s' (this is fatal)",filename);fflush(E->fp);
Pan_problem_misc_functions.c:224:	if(E->control.verbose)
Pan_problem_misc_functions.c:236:	fprintf(E->fp,"File %s is not in the correct format\n",filename);fflush(E->fp);
Pan_problem_misc_functions.c:247:	fprintf(E->fp,"Unable to deciphre the columns in the input file");fflush(E->fp);
Pan_problem_misc_functions.c:261:	fprintf(E->fp,"\t%s (%s) found in column %d\n",name,abbr,column);fflush(E->fp);
Pan_problem_misc_functions.c:264:	fprintf(E->fp,"\t%s (%s) not found in file: %s\n",name,abbr,filename);fflush(E->fp);
Pan_problem_misc_functions.c:271:    if(((3!= E->mesh.nsd) && (fnodesy !=1)) || ((3==E->mesh.nsd) && (1==fnodesy))) {
Pan_problem_misc_functions.c:272:	fprintf(E->fp,"Input data for file `%s'  is of inappropriate dimension (not %dD)\n",filename,E->mesh.nsd);fflush(E->fp);
Pan_problem_misc_functions.c:297:    if(fnodesx != E->mesh.nox || fnodesz != E->mesh.noz || fnodesy != E->mesh.noy)
Pan_problem_misc_functions.c:301:	if( fabs(X[i]-E->X[1][i]) > 0.01*fabs(X[i]) ||
Pan_problem_misc_functions.c:302:	    fabs(Z[i]-E->X[2][i]) > 0.01*fabs(Z[i]) ||
Pan_problem_misc_functions.c:303:	    ((3==E->mesh.nsd) && fabs(Y[i]-E->X[3][i]) > 0.01*fabs(Y[i]))) {
Pan_problem_misc_functions.c:309:	fprintf(E->fp,"\t%s requires interpolation from previous value\n",name,interpolate);fflush(E->fp);
Pan_problem_misc_functions.c:310:	fprintf(E->fp,"\tOld nodes = %d/%d/%d and new nodes = %d/%d/%d\n",fnodesx,fnodesz,fnodesy,E->mesh.nox,E->mesh.noz,E->mesh.noy);fflush(E->fp);
Pan_problem_misc_functions.c:314:	fprintf(E->fp,"\t%s requires no interpolation from previous value\n",name);fflush(E->fp);
Pan_problem_misc_functions.c:315:	vcopy(field,T,1,E->mesh.nno);
Pan_problem_misc_functions.c:362:    const int dims=E->mesh.nsd;
Pan_problem_misc_functions.c:364:    P=(float *)malloc((E->mesh.nno+1)*sizeof(float));
Pan_problem_misc_functions.c:383:     if(E->control.print_convergence) {   
Pan_problem_misc_functions.c:391:	for(i=1;i<=E->mesh.nno;i++) {
Pan_problem_misc_functions.c:400:		    if ((inside1 = cross2d(X[node1]-E->X[1][i],Z[node1]-E->X[2][i],X[node2]-E->X[1][i],Z[node2]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:401:			(inside4 = cross2d(X[node4]-E->X[1][i],Z[node4]-E->X[2][i],X[node1]-E->X[1][i],Z[node1]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:402:			(inside2 = cross2d(X[node2]-E->X[1][i],Z[node2]-E->X[2][i],X[node3]-E->X[1][i],Z[node3]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:403:			(inside3 = cross2d(X[node3]-E->X[1][i],Z[node3]-E->X[2][i],X[node4]-E->X[1][i],Z[node4]-E->X[2][i],3)) <= 0.0) {
Pan_problem_misc_functions.c:418:		    if ((inside1 = cross2d(X[node1]-E->X[1][i],Z[node1]-E->X[2][i],X[node2]-E->X[1][i],Z[node2]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:419:			(inside4 = cross2d(X[node4]-E->X[1][i],Z[node4]-E->X[2][i],X[node1]-E->X[1][i],Z[node1]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:420:			(inside2 = cross2d(X[node2]-E->X[1][i],Z[node2]-E->X[2][i],X[node3]-E->X[1][i],Z[node3]-E->X[2][i],3)) <= 0.0 &&
Pan_problem_misc_functions.c:421:			(inside3 = cross2d(X[node3]-E->X[1][i],Z[node3]-E->X[2][i],X[node4]-E->X[1][i],Z[node4]-E->X[2][i],3)) <= 0.0) {
Pan_problem_misc_functions.c:432:		distance1 = ((X[node1]-E->X[1][i])*(X[node1]-E->X[1][i])+(Z[node1]-E->X[2][i])*(Z[node1]-E->X[2][i]));
Pan_problem_misc_functions.c:433:		distance2 = ((X[node2]-E->X[1][i])*(X[node2]-E->X[1][i])+(Z[node2]-E->X[2][i])*(Z[node2]-E->X[2][i]));
Pan_problem_misc_functions.c:434:		distance3 = ((X[node3]-E->X[1][i])*(X[node3]-E->X[1][i])+(Z[node3]-E->X[2][i])*(Z[node3]-E->X[2][i]));
Pan_problem_misc_functions.c:435:		distance4 = ((X[node4]-E->X[1][i])*(X[node4]-E->X[1][i])+(Z[node4]-E->X[2][i])*(Z[node4]-E->X[2][i]));
Pan_problem_misc_functions.c:450:   	vcopy(TT,T,1,E->mesh.nno); }
Pan_problem_misc_functions.c:452:    if(E->control.print_convergence)
Pan_problem_misc_functions.c:456:	fprintf(E->fp,"Warning: unable to interpolate old  data to %d nodes in the new mesh\n",not_found);
Pan_problem_misc_functions.c:458:	p_to_centres(E,TT,P,E->mesh.levmax); /* if interpolated, apply slight smoothing */
Pan_problem_misc_functions.c:459:	p_to_nodes(E,P,TT,E->mesh.levmax);
Pan_problem_misc_functions.c:550:    for(node=1;node<=E->mesh.nno;node++) {
Pan_problem_misc_functions.c:551:	x1=E->X[1][node];
Pan_problem_misc_functions.c:552:	z1=E->X[2][node];
Pan_problem_misc_functions.c:553:	y1=(E->mesh.nsd!=3) ? 0.0 : E->X[3][node];
Pan_problem_misc_functions.c:569:	    in3=(3!=E->mesh.nsd || y1 >= RECT->y1[number] && y1 <= RECT->y2[number]);
Pan_problem_misc_functions.c:602:		fprintf(E->fp,"RECTANGLE: %d can't work out how to combine new/old fields\n",number);
Pan_problem_misc_functions.c:678:    for(node=1;node<=E->mesh.nno;node++) {
Pan_problem_misc_functions.c:679:	x1=E->X[1][node];
Pan_problem_misc_functions.c:680:	z1=E->X[2][node];
Pan_problem_misc_functions.c:681:	y1=(E->mesh.nsd!=3) ? 0.0 : E->X[3][node];
Pan_problem_misc_functions.c:697:		((E->mesh.nsd != 3) ? 0.0 : (y1-CIRC->y[number])*(y1-CIRC->y[number]));
Pan_problem_misc_functions.c:724:		fprintf(E->fp,"CIRCLE: %d can't work out how to combine new/old fields\n",number);
Pan_problem_misc_functions.c:815:    for(node=1;node<=E->mesh.nno;node++) {
Pan_problem_misc_functions.c:816:	x1=E->X[1][node];
Pan_problem_misc_functions.c:817:	z1=E->X[2][node];
Pan_problem_misc_functions.c:818:	y1=(E->mesh.nsd!=3) ? 0.0 : E->X[3][node];
Pan_problem_misc_functions.c:834:	    in3=(3!=E->mesh.nsd || y1 >= HARM->y1[number] && y1 <= HARM->y2[number]);
Pan_problem_misc_functions.c:857:		    fprintf(E->fp,"POLYNOMIAL: %d can't work out how to combine new/old fields\n",number);
Phase_change.c:26:      E->control.Ra_670 = E->control.Ra_670*E->control.Ra_temp
Phase_change.c:27:              /(E->data.density*E->data.therm_exp*E->data.ref_temperature);
Phase_change.c:28:      E->control.Ra_410 = E->control.Ra_410*E->control.Ra_temp
Phase_change.c:29:              /(E->data.density*E->data.therm_exp*E->data.ref_temperature);
Phase_change.c:31:      E->control.clapeyron670 = E->control.clapeyron670*E->data.ref_temperature/
Phase_change.c:32:                          (E->data.density*E->data.grav_acc*E->sphere.ro_dim);
Phase_change.c:33:      E->control.clapeyron410 = E->control.clapeyron410*E->data.ref_temperature/
Phase_change.c:34:                          (E->data.density*E->data.grav_acc*E->sphere.ro_dim);
Phase_change.c:36:      E->control.width670 = E->sphere.ro_dim/E->control.width670;
Phase_change.c:37:      E->control.width410 = E->sphere.ro_dim/E->control.width410;
Phase_change.c:39:      E->control.transT670 = E->control.transT670/E->data.ref_temperature;
Phase_change.c:40:      E->control.transT410 = E->control.transT410/E->data.ref_temperature;
Phase_change.c:42:fprintf(E->fp,"Rab410 670=%g %g Clap410 670=%g %g %g %g %g %g\n",E->control.Ra_410,E->control.Ra_670,E->control.clapeyron410,E->control.clapeyron670,E->control.width670,E->control.width410,E->control.transT670, E->control.transT410);
Phase_change.c:43:fflush (E->fp);
Phase_change.c:46:  return_horiz_ave(E,E->T,E->Have.T);
Phase_change.c:49:  for(i=1;i<E->mesh.noz;i++)  {
Phase_change.c:50:     if (E->viscosity.zlm<=E->X[2][i+1]&&E->viscosity.zlm>=E->X[2][i])  {
Phase_change.c:51:         temp1 = E->Have.T[i] + (E->Have.T[i+1]-E->Have.T[i])*(E->viscosity.zlm-E->X[2][i])/(E->X[2][i+1]-E->X[2][i]);
Phase_change.c:55:  E->control.transT670 = temp1;
Phase_change.c:57:  for(i=1;i<E->mesh.noz;i++)  {
Phase_change.c:58:     if (E->viscosity.z410<=E->X[2][i+1]&&E->viscosity.z410>=E->X[2][i])  {
Phase_change.c:59:         temp1 = E->Have.T[i] + (E->Have.T[i+1]-E->Have.T[i])*(E->viscosity.z410-E->X[2][i])/(E->X[2][i+1]-E->X[2][i]);
Phase_change.c:63:  E->control.transT410 = temp1;
Phase_change.c:66:  for(i=1;i<=E->mesh.nno;i++)  {
Phase_change.c:67:    e_pressure = E->viscosity.zlm - E->X[2][i] -
Phase_change.c:68:            E->control.clapeyron670*(E->T[i]-E->control.transT670);
Phase_change.c:69:    Bb[i] = pt5*(one+tanh(E->control.width670*e_pressure));
Phase_change.c:72:  for(i=1;i<=E->mesh.nno;i++)  {
Phase_change.c:73:    e_pressure = E->viscosity.z410 - E->X[2][i] -
Phase_change.c:74:            E->control.clapeyron410*(E->T[i]-E->control.transT410);
Phase_change.c:75:    Bt[i] = pt5*(one+tanh(E->control.width410*e_pressure));
Phase_change.c:79:if (E->advection.timesteps%E->control.record_every == 0)   {
Phase_change.c:81:    for (j=1;j<=E->mesh.nox;j++)  {
Phase_change.c:83:      for (i=1;i<=E->mesh.noz;i++)   {
Phase_change.c:84:        n = (j-1)*E->mesh.noz + i;
Phase_change.c:86:          Bb_b[j]=(E->X[2][n+1]-E->X[2][n])*(pt5-Bb[n])/(Bb[n+1]-Bb[n])+E->X[2][n];
Phase_change.c:92:   for (j=1;j<=E->mesh.nox;j++)  {
Phase_change.c:94:      for (i=1;i<=E->mesh.noz;i++)   {
Phase_change.c:95:        n = (j-1)*E->mesh.noz + i;
Phase_change.c:97:          Bt_b[j]=(E->X[2][n+1]-E->X[2][n])*(pt5-Bt[n])/(Bt[n+1]-Bt[n])+E->X[2][n];
Phase_change.c:105:  sprintf(output_file,"%s/fas.%d",E->control.data_file,E->advection.timesteps);
Phase_change.c:107:  for (j=1;j<=E->mesh.nox;j++)
Phase_change.c:108:    fprintf(fp1,"%.4e %.5e %.5e\n",E->X[1][j*E->mesh.noz],Bt_b[j],Bb_b[j]);
Phase_change.c:113:if (E->monitor.solution_cycles%E->control.record_every == 0)   {
Phase_change.c:114:    fprintf(E->fp,"fas=%g %g %g %g %g %g %g %g\n", E->control.clapeyron410,E->control.clapeyron670 ,E->control.Ra_410,E->control.Ra_670,E->control.transT410,E->control.transT670,E->control.width410,E->control.width670);fflush(E->fp);
Phase_change.c:167:  Tsl = E->liquidus[k] - E->solidus[k];
Phase_change.c:170:	Ed = E->data.Cp*dT;
Phase_change.c:171:	dTsol = E->T[n] + dT - E->solidus[k];
Phase_change.c:172://	fprintf(E->fp,"%d %f ",n,dTsol);
Phase_change.c:175:	Hf /= E->data.DeltaT;
Phase_change.c:176:	Tboil = Tboil/E->data.DeltaT - E->data.surf_temp;
Phase_change.c:177:	beta *= E->data.DeltaT;
Phase_change.c:189:			E->T[n] += dT;
Phase_change.c:193:		//else if ( (E->T[n]+dT-(Hf/E->data.Cp)) > E->lherzliq[k] ) {
Phase_change.c:194:		//else if ( dTsol > (1.0/beta + Hf/E->data.Cp) ) { /* WRONG */
Phase_change.c:195:		else if ( dTsol > (Tsl + Hf/E->data.Cp) ) { /* Above Liquidus */
Phase_change.c:196:			E->T[n] += dT - Hf/E->data.Cp;
Phase_change.c:197:			F = 1.0 - E->C[n];
Phase_change.c:201://			if(E->T[n] > Tboil)
Phase_change.c:202://				E->T[n] = Tboil;
Phase_change.c:203:			if(E->T[n] > E->liquidus[k])
Phase_change.c:204:				E->T[n] = E->liquidus[k];
Phase_change.c:208:			E->T[n] += ( Ed*(E->lherzliq[k]-E->solidus[k]) 
Phase_change.c:209:																			- latent*(E->T[n]-E->solidus[k]) ) 
Phase_change.c:210:									/ ( latent + E->data.Cp*(E->lherzliq[k]-E->solidus[k]) );
Phase_change.c:211:			F = (E->T[n] - E->solidus[k]) / (E->lherzliq[k] - E->solidus[k]);*/
Phase_change.c:214:		/*	dF = dTsol / (Hf/E->data.Cp + 1.0/beta);*/		/* ratio of energy to latent heat */
Phase_change.c:216:     dF = (dTsol + E->C[n]*Hf/E->data.Cp) / (Tsl + Hf/E->data.Cp);  /* Frac of melt */
Phase_change.c:219:		 if (dF > E->C[n])
Phase_change.c:220:				F = (dF - E->C[n]);   /* New melt created */
Phase_change.c:221:				/*F = (dF - E->C[n]) / (1 - E->C[n]); */
Phase_change.c:227:/*			E->T[n] += dT - dTsol + F/beta;*/
Phase_change.c:228:      E->T[n] += dT - F*Hf/E->data.Cp;
Phase_change.c:232:  if(E->C[n]+F > 1.0)
Phase_change.c:233:		fprintf(E->fp,"meltcase %d %d %f %f\n",n,meltcase,F,E->C[n]);
Phase_change.c:234://		E->Fm[n] = F;  /* This is returned, don't do it here!
Phase_change.c:238:/*		if (F > E->C[n])  *//* unnecessary? */
Phase_change.c:239:			E->C[n] += F;  /* effectively, C = dF */
Phase_change.c:241://		fprintf(E->fp,"\n");
Phase_change.c:292:  elemsol = (E->solidus[k] + E->solidus[k+1]) / 2.0;
Phase_change.c:293:  elemliq = (E->liquidus[k] + E->liquidus[k+1]) / 2.0;
Phase_change.c:297:	Ed = E->data.Cp*dT;
Phase_change.c:298:	dTsol = E->TE[e] + dT - elemsol;
Phase_change.c:299://	fprintf(E->fp,"%d %f ",n,dTsol);
Phase_change.c:302:	Hf /= E->data.DeltaT;
Phase_change.c:303:	Tboil = Tboil/E->data.DeltaT - E->data.surf_temp;
Phase_change.c:304:	beta *= E->data.DeltaT;
Phase_change.c:316:			E->TE[e] += dT;
Phase_change.c:320:		else if ( dTsol > (Tsl + Hf/E->data.Cp) ) { /* Above Liquidus */
Phase_change.c:321:		/*else if ( dTsol > (1.0/beta + Hf/E->data.Cp) ) {*/ /* WRONG */
Phase_change.c:322:			E->TE[e] += dT - Hf/E->data.Cp;
Phase_change.c:323:			F = 1.0 - E->CE[e];
Phase_change.c:327:			if(E->TE[e] > elemliq)
Phase_change.c:328:				E->TE[e] = elemliq;
Phase_change.c:332:/*			dF = dTsol / (Hf/E->data.Cp + 1.0/beta);*/		/* ratio of energy to latent heat */
Phase_change.c:333:/*			if (dF > E->CE[e])
Phase_change.c:334:				F = (dF - E->CE[e]); */ /* New melt created */
Phase_change.c:339:      dF = (dTsol + E->CE[e]*Hf/E->data.Cp) / (Tsl + Hf/E->data.Cp);  /* Frac of melt */
Phase_change.c:342:		 if (dF > E->CE[e])
Phase_change.c:343:				F = (dF - E->CE[e]);   /* New melt created */
Phase_change.c:347:			/*E->TE[e] += dT - dTsol + F/beta;*/
Phase_change.c:348:      E->TE[e] += dT - F*Hf/E->data.Cp;
Phase_change.c:351://		fprintf(E->fp,"%d %f ",meltcase,F);
Phase_change.c:355:/*		if (F > E->C[n])  *//* unnecessary? */
Phase_change.c:356:			E->CE[e] += F;  /* effectively, C = dF */
Phase_change.c:358://		fprintf(E->fp,"\n");
Phase_change.c:389:  dimfactor = (E->data.Cp * E->data.DeltaT) / E->data.Hf;
Phase_change.c:391:  Fc = (E->control.Qc/3.0) * pow(E->sphere.rcore,3.0) / pow(E->sphere.ri,2.0);
Phase_change.c:393:  deltarb = dimfactor * (Fb - Fc) * E->advection.timestep;
Phase_change.c:395:  fprintf(E->fp,"%e Fb %e Fc %e dt %e\n",dimfactor,Fb,Fc,E->advection.timestep);
Phase_change.c:396:  fprintf(E->fp,"Change in shell thickness: %e = %e m\n",deltarb,
Phase_change.c:397:                                    (deltarb*E->sphere.ro_dim));
Process_buoyancy.c:29://    if ( ((ii % E->control.record_every) == 0))    {
Process_buoyancy.c:33:        for (i=1;i<=E->mesh.nox;i++)  {
Process_buoyancy.c:34:          j=i*E->mesh.noz;
Process_buoyancy.c:36:            Fs += (E->slice.shflux[i]+E->slice.shflux[i-1])*0.5*
Process_buoyancy.c:37:                sin(0.5*(E->X[1][j]+E->X[1][j-E->mesh.noz]))*
Process_buoyancy.c:38:                (E->X[1][j]-E->X[1][j-E->mesh.noz]);
Process_buoyancy.c:41:        Fs = Fs/(1.0-cos(E->X[1][E->mesh.nno]));
Process_buoyancy.c:44:        for (i=1;i<=E->mesh.nox;i++)  {
Process_buoyancy.c:45:          j=i*E->mesh.noz;
Process_buoyancy.c:47:            Fb += (E->slice.bhflux[i]+E->slice.bhflux[i-1])*0.5*
Process_buoyancy.c:48:                sin(0.5*(E->X[1][j]+E->X[1][j-E->mesh.noz]))*
Process_buoyancy.c:49:                (E->X[1][j]-E->X[1][j-E->mesh.noz]);
Process_buoyancy.c:52:        Fb = Fb/(1.0-cos(E->X[1][E->mesh.nno]));
Process_buoyancy.c:61:      if(E->control.freezing) {
Process_buoyancy.c:64:        E->sphere.deltarb += deltah; /* Add to running total this restart */
Process_buoyancy.c:65:        E->monitor.deltah += deltah; /* Add to running total */
Process_buoyancy.c:68:                    E->monitor.elapsed_time,Fs,Fb,deltah,E->sphere.deltarb,
Process_buoyancy.c:69:                    E->monitor.deltah);
Process_buoyancy.c:70:        fprintf(E->fpq,"%13.5e %13.5e %13.5e %13.5e %13.5e %13.5e\n",
Process_buoyancy.c:71:                    E->monitor.elapsed_time,Fs,Fb,deltah,E->sphere.deltarb,
Process_buoyancy.c:72:                    E->monitor.deltah);
Process_buoyancy.c:73:        fflush(E->fpq);
Process_buoyancy.c:96:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Process_buoyancy.c:100:    const int nno=E->mesh.nno;
Process_buoyancy.c:101:    const int lev = E->mesh.levmax;
Process_buoyancy.c:106:    return_horiz_ave(E,E->T,E->Have.T);
Process_buoyancy.c:110:      E->heatflux[i] = 0.0;
Process_buoyancy.c:113:    for(e=1;e<=E->mesh.nel;e++) {
Process_buoyancy.c:114:      ee = (e-1)%E->mesh.elz+1;
Process_buoyancy.c:115:      get_global_shape_fn(E,e,&GN,&GNx,&dOmega,xk,2,E->mesh.levmax);
Process_buoyancy.c:118:          VZ[j] = E->V[2][E->ien[e].node[j]];
Process_buoyancy.c:126:          lnode = (E->ien[e].node[j]-1)%E->mesh.noz+1;
Process_buoyancy.c:127:          u[i] += VZ[j]*E->N.ppt[GNPINDEX(j,i)];
Process_buoyancy.c:128:          T[i] += E->T[E->ien[e].node[j]]*E->N.ppt[GNPINDEX(j,i)];
Process_buoyancy.c:129:          T1[i] += (E->T[E->ien[e].node[j]]-E->Have.T[lnode])*E->N.ppt[GNPINDEX(j,i)];
Process_buoyancy.c:130:          dTdz[i] += -E->T[E->ien[e].node[j]]*GNx.ppt[GNPXINDEX(1,j,i)];
Process_buoyancy.c:137:      diff = (E->diffusivity[ee]+E->diffusivity[ee+1])*0.5;
Process_buoyancy.c:147:        flux[E->ien[e].node[j]] += uT*E->TWW[E->mesh.levmax][e].node[j];
Process_buoyancy.c:148:        E->heatflux[E->ien[e].node[j]] += adv*E->TWW[E->mesh.levmax][e].node[j];
Process_buoyancy.c:153:      flux[i] = flux[i]*E->Mass[i];
Process_buoyancy.c:154:      E->heatflux[i] = E->heatflux[i]*E->Mass[i];
Process_buoyancy.c:157:    for(i=1;i<=E->mesh.nsf;i++)   {
Process_buoyancy.c:158:      E->slice.shflux[i] = 2*flux[E->surf_node[i]]
Process_buoyancy.c:159:                           - flux[E->surf_node[i]-1];
Process_buoyancy.c:161:      E->slice.bhflux[i] = 2*flux[E->surf_node[i]-E->mesh.noz+1]
Process_buoyancy.c:162:                           - flux[E->surf_node[i]-E->mesh.noz+2];
Process_buoyancy.c:165:    return_horiz_ave(E,flux,E->Have.f);
Process_buoyancy.c:166:    return_horiz_ave(E,E->heatflux,E->Have.F);
Process_velocity.c:27: 	   E->monitor.length_scale = E->data.layer_km/E->mesh.layer[2]; /* km */
Process_velocity.c:31:    if ( ((ii % E->control.record_every) == 0))     {
Process_velocity.c:33:      get_STD_topo(E,E->slice.tpg,E->slice.tpgb,ii); 
Process_velocity.c:35: /*        get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);   */
Process_velocity.c:69:        mm = E->convection.perturb_mm[0];
Process_velocity.c:70:        ll = E->convection.perturb_ll[0];
Process_velocity.c:78:       for(node=1;node<=E->mesh.nno;node++)   {
Process_velocity.c:79:          t1=E->X[1][node];
Process_velocity.c:81:          if (node%E->mesh.noz==0)  {
Process_velocity.c:85:          else if((node-1)%E->mesh.noz==0)  {
Process_velocity.c:90:        fprintf(fp1,"%5d %.5e %.5e %.6e %.6e %.6e\n",node,E->X[1][i],E->X[2][i],E->V[1][i],vt,E->T[i]); 
Process_velocity.c:92:       for(i=1;i<=E->mesh.nsf;i++)   {
Process_velocity.c:93:          node = E->surf_node[i];
Process_velocity.c:94:          t1 = E->X[1][node];
Process_velocity.c:101:          fprintf(fp1,"%4d %.4e %.4e %.4e %.4e %.4e\n",i,E->X[1][node],vt-vt0,vf-vf0,E->slice.tpg[i]-E->slice.tpg[1],E->slice.tpgb[i]-E->slice.tpgb[1]);
Process_velocity.c:121:  const int dims=E->mesh.nsd;
Process_velocity.c:123:  const int nno=E->mesh.nno;
Process_velocity.c:125:  lev = E->mesh.levmax;
Process_velocity.c:130:    if ((node-1)%E->mesh.noz==0)   {
Process_velocity.c:131:      i = (node-1)/E->mesh.noz + 1;
Process_velocity.c:132:        SV[(i-1)*2+1] = E->V[1][node];
Process_velocity.c:133:        SV[(i-1)*2+2] = E->V[3][node];
Process_velocity.c:148:  const int nel=E->mesh.nel;
Process_velocity.c:149:  const int vpts=vpoints[E->mesh.nsd];
Process_velocity.c:151:  lev = E->mesh.levmax;
Process_velocity.c:156:      EV[el] +=  E->EVI[lev][(el-1)*vpts+j];
Process_velocity.c:171:  stride = E->mesh.nsf*6;
Process_velocity.c:173:  for (node=1;node<=E->mesh.nno;node++)
Process_velocity.c:174:     if ( ((node-1)%E->mesh.noz)==0 )  {
Process_velocity.c:175:        i = (node-1)/E->mesh.noz+1;
Process_velocity.c:176:        E->stress[(i-1)*6+1] = SXX[node];
Process_velocity.c:177:        E->stress[(i-1)*6+2] = SZZ[node];
Process_velocity.c:178:        E->stress[(i-1)*6+3] = SYY[node];
Process_velocity.c:179:        E->stress[(i-1)*6+4] = SXY[node];
Process_velocity.c:180:        E->stress[(i-1)*6+5] = SXZ[node];
Process_velocity.c:181:        E->stress[(i-1)*6+6] = SZY[node];
Process_velocity.c:183:     else if ( ((node-2)%E->mesh.noz)==0 )  {
Process_velocity.c:184:        i = (node-2)/E->mesh.noz+1;
Process_velocity.c:185:        E->stress[stride+(i-1)*6+1] = SXX[node];
Process_velocity.c:186:        E->stress[stride+(i-1)*6+2] = SZZ[node];
Process_velocity.c:187:        E->stress[stride+(i-1)*6+3] = SYY[node];
Process_velocity.c:188:        E->stress[stride+(i-1)*6+4] = SXY[node];
Process_velocity.c:189:        E->stress[stride+(i-1)*6+5] = SXZ[node];
Process_velocity.c:190:        E->stress[stride+(i-1)*6+6] = SZY[node];
Shape_functions.c:27:    { E->N.vpt[i] = 0.0; 
Shape_functions.c:28:      E->Nx.vpt[i] = 0.0;
Shape_functions.c:29:      E->Nx.vpt[GNVI+i] = 0.0;
Shape_functions.c:30:      E->Nx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:34:    { E->N.ppt[i] = 0.0; 
Shape_functions.c:35:      E->Nx.ppt[i] = 0.0;
Shape_functions.c:36:      E->Nx.ppt[GNPI+i] = 0.0;
Shape_functions.c:37:      E->Nx.ppt[2*GNPI+i] = 0.0; 
Shape_functions.c:41:    { E->M.vpt[i] = 0.0; 
Shape_functions.c:42:      E->Mx.vpt[i] = 0.0;
Shape_functions.c:43:      E->Mx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:47:    { E->M.ppt[i] = 0.0; 
Shape_functions.c:48:      E->Mx.ppt[i] = 0.0;
Shape_functions.c:49:      E->Mx.ppt[GN1PI+i] = 0.0;
Shape_functions.c:53:    { E->L.vpt[i] = 0.0; 
Shape_functions.c:54:      E->Lx.vpt[i] = 0.0;
Shape_functions.c:55:      E->Lx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:58:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:61:      for(j=1;j<=vpoints[E->mesh.nsd];j++)  { 
Shape_functions.c:64:	  E->N.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:65:	  for(d=1;d<=E->mesh.nsd;d++)  {
Shape_functions.c:66:	      E->N.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:69:	  for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:70:	      E->Nx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],g_point[j].x[dd-1]);
Shape_functions.c:71:	      for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:73:		      E->Nx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],g_point[j].x[d-1]);
Shape_functions.c:78:      for(j=1;j<=ppoints[E->mesh.nsd];j++)  {
Shape_functions.c:80:	  E->N.ppt[GNPINDEX(i,j)] = 1.0;
Shape_functions.c:81:	  for(d=1;d<=E->mesh.nsd;d++){
Shape_functions.c:82:	      E->N.ppt[GNPINDEX(i,j)] *=  
Shape_functions.c:85:	  for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:86:	      E->Nx.ppt[GNPXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],p_point[j].x[dd-1]);
Shape_functions.c:87:	      for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:89:		      E->Nx.ppt[GNPXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],p_point[j].x[d-1]); 
Shape_functions.c:104:  for(j=1;j<=onedvpoints[E->mesh.nsd];j++)
Shape_functions.c:105:    { remapj = ccc[E->mesh.nsd-2][j];
Shape_functions.c:106:      for(k=1;k<=onedvpoints[E->mesh.nsd];k++)     
Shape_functions.c:107:	{ remapk = ccc[E->mesh.nsd-2][k];
Shape_functions.c:108:	  E->M.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:109:	  E->L.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:110:	  for(d=1;d<=E->mesh.nsd-1;d++) {
Shape_functions.c:111:	    E->M.vpt[GMVINDEX(j,k)] *= lpoly(cc[d-1][remapj],g_1d[k].x[d-1]);
Shape_functions.c:112:	    E->L.vpt[GMVINDEX(j,k)] *= lpoly(cc[d-1][remapj],l_1d[k].x[d-1]);
Shape_functions.c:114:	  for(dd=1;dd<=E->mesh.nsd-1;dd++) {
Shape_functions.c:115:	      E->Mx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(cc[dd-1][remapj],g_1d[k].x[dd-1]); 
Shape_functions.c:116:	      E->Lx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(cc[dd-1][remapj],l_1d[k].x[dd-1]); 
Shape_functions.c:117:	      for(d=1;d<=E->mesh.nsd-1;d++)
Shape_functions.c:119:		  E->Mx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(cc[d-1][remapj],g_1d[k].x[d-1]); 
Shape_functions.c:120:		  E->Lx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(cc[d-1][remapj],l_1d[k].x[d-1]); 
Size_does_matter.c:47:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Size_does_matter.c:66:                  x[d][k] += E->XX[lv][d][E->IEN[lv][el].node[i]] * E->N.vpt[GNVINDEX(i,k)];
Size_does_matter.c:71:			dxda[d][e] += E->XX[lv][e][E->IEN[lv][el].node[i]] * E->Nx.vpt[GNVXINDEX(d-1,i,k)];   /* This is Shijie's change (d<->e) */
Size_does_matter.c:73:	      jacobian = determinant(dxda,E->mesh.nsd);  
Size_does_matter.c:84:			GNx->vpt[GNVXINDEX(d-1,j,k)] += E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];   /* switch e and d for cof  -- Shijie's  */
Size_does_matter.c:107:                     x[d][k] += E->XX[lv][d][E->IEN[lv][el].node[i]] * E->N.ppt[GNPINDEX(i,k)];
Size_does_matter.c:112:			    dxda[d][e] += E->XX[lv][e][E->IEN[lv][el].node[i]] * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Size_does_matter.c:114:	          jacobian = determinant(dxda,E->mesh.nsd);     
Size_does_matter.c:119:		        cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd); 
Size_does_matter.c:125:		           GNx->ppt[GNPXINDEX(d-1,j,k)] += E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d]; 
Size_does_matter.c:171:	for(dirn=1;dirn<=E->mesh.nsd;dirn++)     {
Size_does_matter.c:178:	    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)  { /* all of the vpoints*/
Size_does_matter.c:179:	        for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:180:		  for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:184:		   for(i=1;i<=onedvpoints[E->mesh.nsd];i++)      /* nodes */
Size_does_matter.c:185:		     for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:186:		       for(e=1;e<=E->mesh.nsd-1;e++)    {
Size_does_matter.c:187:		          dxda[d][e] += E->X[collapsed_dirn[e-1]][E->ien[el].node[node[i]]]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];      
Size_does_matter.c:190:		   for(i=1;i<=onedvpoints[E->mesh.nsd];i++)      /* nodes */
Size_does_matter.c:191:		     for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:192:		       for(e=1;e<=E->mesh.nsd-1;e++)    {
Size_does_matter.c:193:		          dxda[d][e] += E->X[collapsed_dirn[e-1]][E->ien[el].node[node[i]]]*E->Lx.vpt[GMVXINDEX(d-1,i,k)];      
Size_does_matter.c:196:		jacobian = determinant(dxda,E->mesh.nsd-1); 
Size_does_matter.c:197:		dGammax->vpt[GMVGAMMA(dirn-1+E->mesh.nsd*locn,k)] = jacobian;
Size_does_matter.c:260:  const int ppts=ppoints[E->mesh.nsd];
Size_does_matter.c:261:  const int vpts=vpoints[E->mesh.nsd];
Size_does_matter.c:266:  for (lv=E->mesh.levmin;lv<=E->mesh.levmax;lv++)   {
Size_does_matter.c:267:    for(node=1;node<=E->mesh.NNO[lv];node++)
Size_does_matter.c:268:      E->MASS[lv][node] = 0.0;
Size_does_matter.c:270:    for(e=1;e<=E->mesh.NEL[lv];e++)  {
Size_does_matter.c:272:      for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:273:        n[node] = E->IEN[lv][e].node[node];
Size_does_matter.c:279:      for(i=1;i<=E->mesh.nsd;i++)  {
Size_does_matter.c:280:        for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:281:	      centre[i] += E->XX[lv][i][E->IEN[lv][e].node[node]];
Size_does_matter.c:283:    	E->ECO[lv][e].centre[i] = centre[i]/enodes[E->mesh.nsd];
Size_does_matter.c:286:      if (3==E->mesh.nsd)   {
Size_does_matter.c:287:        dx1 = 0.25*(E->XX[lv][1][n[3]]+E->XX[lv][1][n[4]]
Size_does_matter.c:288:                   +E->XX[lv][1][n[7]]+E->XX[lv][1][n[8]]
Size_does_matter.c:289:                   -E->XX[lv][1][n[1]]-E->XX[lv][1][n[2]]
Size_does_matter.c:290:                   -E->XX[lv][1][n[5]]-E->XX[lv][1][n[6]]);
Size_does_matter.c:291:        dx2 = 0.25*(E->XX[lv][2][n[3]]+E->XX[lv][2][n[4]]
Size_does_matter.c:292:                   +E->XX[lv][2][n[7]]+E->XX[lv][2][n[8]]
Size_does_matter.c:293:                   -E->XX[lv][2][n[1]]-E->XX[lv][2][n[2]]
Size_does_matter.c:294:                   -E->XX[lv][2][n[5]]-E->XX[lv][3][n[6]]);
Size_does_matter.c:295:        dx3 = 0.25*(E->XX[lv][3][n[3]]+E->XX[lv][3][n[4]]
Size_does_matter.c:296:                   +E->XX[lv][3][n[7]]+E->XX[lv][3][n[8]]
Size_does_matter.c:297:                   -E->XX[lv][3][n[1]]-E->XX[lv][3][n[2]]
Size_does_matter.c:298:                   -E->XX[lv][3][n[5]]-E->XX[lv][3][n[6]]);
Size_does_matter.c:299:        E->ECO[lv][e].size[1] = sqrt(dx1*dx1 + dx2*dx2 + dx3*dx3);
Size_does_matter.c:301:        dx1 = 0.25*(E->XX[lv][1][n[2]]+E->XX[lv][1][n[3]]
Size_does_matter.c:302:                   +E->XX[lv][1][n[6]]+E->XX[lv][1][n[7]]
Size_does_matter.c:303:                   -E->XX[lv][1][n[1]]-E->XX[lv][1][n[4]]
Size_does_matter.c:304:                   -E->XX[lv][1][n[5]]-E->XX[lv][1][n[8]]);
Size_does_matter.c:305:        dx2 = 0.25*(E->XX[lv][2][n[2]]+E->XX[lv][2][n[3]]
Size_does_matter.c:306:                   +E->XX[lv][2][n[6]]+E->XX[lv][2][n[7]]
Size_does_matter.c:307:                   -E->XX[lv][2][n[1]]-E->XX[lv][2][n[4]]
Size_does_matter.c:308:                   -E->XX[lv][2][n[5]]-E->XX[lv][3][n[8]]);
Size_does_matter.c:309:        dx3 = 0.25*(E->XX[lv][3][n[2]]+E->XX[lv][3][n[3]]
Size_does_matter.c:310:                   +E->XX[lv][3][n[6]]+E->XX[lv][3][n[7]]
Size_does_matter.c:311:                   -E->XX[lv][3][n[1]]-E->XX[lv][3][n[4]]
Size_does_matter.c:312:                   -E->XX[lv][3][n[5]]-E->XX[lv][3][n[8]]);
Size_does_matter.c:313:        E->ECO[lv][e].size[2] = sqrt(dx1*dx1 + dx2*dx2 + dx3*dx3);
Size_does_matter.c:315:        dx1 = 0.25*(E->XX[lv][1][n[5]]+E->XX[lv][1][n[6]]
Size_does_matter.c:316:                   +E->XX[lv][1][n[7]]+E->XX[lv][1][n[8]]
Size_does_matter.c:317:                   -E->XX[lv][1][n[1]]-E->XX[lv][1][n[2]]
Size_does_matter.c:318:                   -E->XX[lv][1][n[3]]-E->XX[lv][1][n[4]]);
Size_does_matter.c:319:        dx2 = 0.25*(E->XX[lv][2][n[5]]+E->XX[lv][2][n[6]]
Size_does_matter.c:320:                   +E->XX[lv][2][n[7]]+E->XX[lv][2][n[8]]
Size_does_matter.c:321:                   -E->XX[lv][2][n[1]]-E->XX[lv][2][n[2]]
Size_does_matter.c:322:                   -E->XX[lv][2][n[3]]-E->XX[lv][3][n[4]]);
Size_does_matter.c:323:        dx3 = 0.25*(E->XX[lv][3][n[5]]+E->XX[lv][3][n[6]]
Size_does_matter.c:324:                   +E->XX[lv][3][n[7]]+E->XX[lv][3][n[8]]
Size_does_matter.c:325:                   -E->XX[lv][3][n[1]]-E->XX[lv][3][n[2]]
Size_does_matter.c:326:                   -E->XX[lv][3][n[3]]-E->XX[lv][3][n[4]]);
Size_does_matter.c:327:        E->ECO[lv][e].size[3] = sqrt(dx1*dx1 + dx2*dx2 + dx3*dx3);
Size_does_matter.c:330:      else if (2==E->mesh.nsd)   {
Size_does_matter.c:331:        dx1 = 0.5*(E->XX[lv][1][n[3]]+E->XX[lv][1][n[4]]
Size_does_matter.c:332:                  -E->XX[lv][1][n[1]]-E->XX[lv][1][n[2]]);
Size_does_matter.c:333:        dx2 = 0.5*(E->XX[lv][2][n[3]]+E->XX[lv][2][n[4]]
Size_does_matter.c:334:                  -E->XX[lv][2][n[1]]-E->XX[lv][2][n[2]]);
Size_does_matter.c:335:        E->ECO[lv][e].size[1] = sqrt(dx1*dx1 + dx2*dx2);
Size_does_matter.c:337:        dx1 = 0.5*(E->XX[lv][1][n[2]]+E->XX[lv][1][n[3]]
Size_does_matter.c:338:                  -E->XX[lv][1][n[1]]-E->XX[lv][1][n[4]]);
Size_does_matter.c:339:        dx2 = 0.5*(E->XX[lv][2][n[2]]+E->XX[lv][2][n[3]]
Size_does_matter.c:340:                  -E->XX[lv][2][n[1]]-E->XX[lv][2][n[4]]);
Size_does_matter.c:341:        E->ECO[lv][e].size[2] = sqrt(dx1*dx1 + dx2*dx2);
Size_does_matter.c:345:        area += g_point[nint].weight[E->mesh.nsd-1] * dOmega.vpt[nint];
Size_does_matter.c:346:      E->ECO[lv][e].area = area;
Size_does_matter.c:348:      for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Size_does_matter.c:351:          temp[node] += dOmega.vpt[nint]*g_point[nint].weight[E->mesh.nsd-1]
Size_does_matter.c:352:                       *E->N.vpt[GNVINDEX(node,nint)];       /* int Na dV */
Size_does_matter.c:355:      for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:356:         E->MASS[lv][E->IEN[lv][e].node[node]] += temp[node];
Size_does_matter.c:358:        for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Size_does_matter.c:359:           E->TWW[lv][e].node[node] = temp[node];
Size_does_matter.c:363:    for(node=1;node<=E->mesh.NNO[lv];node++)  {
Size_does_matter.c:364:      E->MASS[lv][node] = 1.0/E->MASS[lv][node];
Size_does_matter.c:370:	E->Total.vol = 0.0;
Size_does_matter.c:371:  for(e=1;e<E->mesh.nel;e++)  
Size_does_matter.c:372:    E->Total.vol += E->ECO[E->mesh.levmax][e].area;
Size_does_matter.c:374:  fprintf(E->fp,"Total mantle volume: %.5e\n",E->Total.vol);
Solver_conj_grad.c:10:  E->build_forcing_term = assemble_forces_iterative;
Solver_conj_grad.c:11:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_conj_grad.c:12:  E->solver_allocate_vars = cg_allocate_vars;
Solver_conj_grad.c:38:  strip_bcs_from_residual(E,E->F,E->mesh.levmax);
Solver_multigrid.c:19:  E->solver_allocate_vars = mg_allocate_vars;
Solver_multigrid.c:20:  E->build_forcing_term = assemble_forces_iterative;
Solver_multigrid.c:21:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_multigrid.c:23:  E->control.mg_cycle = 1;
Solver_multigrid.c:49:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:50:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:51:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:52:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:53:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:65:	    e1 = E->EL[sl_minus][el].sub[1];
Solver_multigrid.c:66:            node1=E->IEN[start_lev][e1].node[7];
Solver_multigrid.c:68:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:70:		AD[E->ID[sl_minus][node].doff[1]] += AU[E->ID[start_lev][node1].doff[1]]; 
Solver_multigrid.c:71:		AD[E->ID[sl_minus][node].doff[2]] += AU[E->ID[start_lev][node1].doff[2]]; 
Solver_multigrid.c:72:		AD[E->ID[sl_minus][node].doff[3]] += AU[E->ID[start_lev][node1].doff[3]]; 
Solver_multigrid.c:80:	    e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:83:              node1 = E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:84:              average1 += AU[E->ID[start_lev][node1].doff[1]];
Solver_multigrid.c:85:              average2 += AU[E->ID[start_lev][node1].doff[2]];
Solver_multigrid.c:90:	    node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:92:	    AD[E->ID[sl_minus][node].doff[1]] += average1; 
Solver_multigrid.c:93:	    AD[E->ID[sl_minus][node].doff[2]] += average2; 
Solver_multigrid.c:114:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:115:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:116:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:117:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:118:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:130:	    e1 = E->EL[sl_minus][el].sub[1];
Solver_multigrid.c:131:            node1=E->IEN[start_lev][e1].node[7];
Solver_multigrid.c:133:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:135:		AD[E->ID[sl_minus][node].doff[1]] += AU[E->ID[start_lev][node1].doff[1]]; 
Solver_multigrid.c:136:		AD[E->ID[sl_minus][node].doff[2]] += AU[E->ID[start_lev][node1].doff[2]]; 
Solver_multigrid.c:137:		AD[E->ID[sl_minus][node].doff[3]] += AU[E->ID[start_lev][node1].doff[3]]; 
Solver_multigrid.c:143:	    e1 = E->EL[sl_minus][el].sub[1];
Solver_multigrid.c:144:            node1=E->IEN[start_lev][e1].node[3];
Solver_multigrid.c:146:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:148:		AD[E->ID[sl_minus][node].doff[1]] += AU[E->ID[start_lev][node1].doff[1]]; 
Solver_multigrid.c:149:		AD[E->ID[sl_minus][node].doff[2]] += AU[E->ID[start_lev][node1].doff[2]]; 
Solver_multigrid.c:171:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:172:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:173:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:174:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:175:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:189:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:191:		    node=E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:192:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:193:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:194:		    average3 += AU[E->ID[start_lev][node].doff[3]];
Solver_multigrid.c:197:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:199:		AD[E->ID[sl_minus][node].doff[1]] += E->TWW[sl_minus][el].node[i] * average1; 
Solver_multigrid.c:200:		AD[E->ID[sl_minus][node].doff[2]] += E->TWW[sl_minus][el].node[i] * average2; 
Solver_multigrid.c:201:	 	AD[E->ID[sl_minus][node].doff[3]] += E->TWW[sl_minus][el].node[i] * average3; 
Solver_multigrid.c:208:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:210:		    node =E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:211:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:212:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:214:		node=E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:215:		AD[E->ID[sl_minus][node].doff[1]] += E->TWW[sl_minus][el].node[i] * average1; 
Solver_multigrid.c:216:		AD[E->ID[sl_minus][node].doff[2]] += E->TWW[sl_minus][el].node[i] * average2; 
Solver_multigrid.c:221:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i];
Solver_multigrid.c:222:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i];
Solver_multigrid.c:223:       AD[E->ID[sl_minus][i].doff[3]] = AD[E->ID[sl_minus][i].doff[3]] * E->MASS[sl_minus][i];
Solver_multigrid.c:227:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i];
Solver_multigrid.c:228:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i];
Solver_multigrid.c:250:    const int neq_minus=E->mesh.NEQ[start_lev-1];
Solver_multigrid.c:251:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:252:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:253:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:254:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:268:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:270:		    node=E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:271:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:272:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:273:		    average3 += AU[E->ID[start_lev][node].doff[3]];
Solver_multigrid.c:276:		node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:277:		w=weight * E->TWW[sl_minus][el].node[i]; 
Solver_multigrid.c:279:		AD[E->ID[sl_minus][node].doff[1]] += w * average1; 
Solver_multigrid.c:280:		AD[E->ID[sl_minus][node].doff[2]] += w * average2; 
Solver_multigrid.c:281:	 	AD[E->ID[sl_minus][node].doff[3]] += w * average3; 
Solver_multigrid.c:288:		e1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:290:		    node =E->IEN[start_lev][e1].node[j];
Solver_multigrid.c:291:		    average1 += AU[E->ID[start_lev][node].doff[1]];
Solver_multigrid.c:292:		    average2 += AU[E->ID[start_lev][node].doff[2]];
Solver_multigrid.c:294:		node=E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:295:		w=weight * E->TWW[sl_minus][el].node[i]; 
Solver_multigrid.c:296:		AD[E->ID[sl_minus][node].doff[1]] += w * average1; 
Solver_multigrid.c:297:		AD[E->ID[sl_minus][node].doff[2]] += w * average2; 
Solver_multigrid.c:305:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:306:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:307:       AD[E->ID[sl_minus][i].doff[3]] = AD[E->ID[sl_minus][i].doff[3]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:311:       AD[E->ID[sl_minus][i].doff[1]] = AD[E->ID[sl_minus][i].doff[1]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:312:       AD[E->ID[sl_minus][i].doff[2]] = AD[E->ID[sl_minus][i].doff[2]] * E->MASS[sl_minus][i] * amplifier;
Solver_multigrid.c:336:    const int dims = E->mesh.nsd;
Solver_multigrid.c:339:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:340:	fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:345:    for(el=1;el<=E->mesh.NEL[sl_minus];el++)
Solver_multigrid.c:347:	    node_coarse = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:348:	    node_fine=E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:350:	    eqn_coarse = E->ID[sl_minus][node_coarse].doff[1];
Solver_multigrid.c:351:	    eqn = E->ID[start_lev][node_fine].doff[1];
Solver_multigrid.c:354:	    eqn_coarse = E->ID[sl_minus][node_coarse].doff[2];
Solver_multigrid.c:355:	    eqn = E->ID[start_lev][node_fine].doff[2];
Solver_multigrid.c:359:		eqn_coarse = E->ID[sl_minus][node_coarse].doff[3];
Solver_multigrid.c:360:		eqn = E->ID[start_lev][node_fine].doff[3];
Solver_multigrid.c:386:    const int dims = E->mesh.nsd;
Solver_multigrid.c:389:    const int neq = E->mesh.NEQ[sl_plus];
Solver_multigrid.c:390:    const int nels = E->mesh.NEL[start_lev];
Solver_multigrid.c:392:    assert(start_lev != E->mesh.levmax  /* un_injection */);
Solver_multigrid.c:400:		node = E->IEN[start_lev][el].node[i];
Solver_multigrid.c:401:		node_plus=E->IEN[sl_plus][E->EL[start_lev][el].sub[i]].node[i];
Solver_multigrid.c:403:		eqn1 = E->ID[start_lev][node].doff[1];
Solver_multigrid.c:404:		eqn2 = E->ID[start_lev][node].doff[2];
Solver_multigrid.c:405:		eqn3 = E->ID[start_lev][node].doff[3];
Solver_multigrid.c:406:		eqn_plus1 = E->ID[sl_plus][node_plus].doff[1];
Solver_multigrid.c:407:		eqn_plus2 = E->ID[sl_plus][node_plus].doff[2];
Solver_multigrid.c:408:		eqn_plus3 = E->ID[sl_plus][node_plus].doff[3];
Solver_multigrid.c:417:		node = E->IEN[start_lev][el].node[i];
Solver_multigrid.c:418:		node_plus=E->IEN[sl_plus][E->EL[start_lev][el].sub[i]].node[i];
Solver_multigrid.c:420:		eqn1 = E->ID[start_lev][node].doff[1];
Solver_multigrid.c:421:		eqn2 = E->ID[start_lev][node].doff[2];
Solver_multigrid.c:422:		eqn_plus1 = E->ID[sl_plus][node_plus].doff[1];
Solver_multigrid.c:423:		eqn_plus2 = E->ID[sl_plus][node_plus].doff[2];
Solver_multigrid.c:439:    const int dims = E->mesh.nsd;
Solver_multigrid.c:442:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:443:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:449:      for(el=1;el<=E->mesh.NEL[sl_minus];el++)   {
Solver_multigrid.c:451:          node_coarse = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:452:          node_fine=E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:472:    const int elx=E->mesh.ELX[sl_minus];
Solver_multigrid.c:473:    const int elz=E->mesh.ELZ[sl_minus];
Solver_multigrid.c:474:    const int ely=E->mesh.ELY[sl_minus];
Solver_multigrid.c:475:    const int dims=E->mesh.nsd;
Solver_multigrid.c:477:    assert(start_lev != E->mesh.levmin );
Solver_multigrid.c:484:			node_minus = E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:485:			node = E->IEN[start_lev][E->EL[sl_minus][el].sub[i]].node[i];
Solver_multigrid.c:487:			if(E->mesh.periodic_x && elx==ex && 0==loc[i].plus[0]) {
Solver_multigrid.c:488:			    node_minus += (E->mesh.NOX[sl_minus]-1)*E->mesh.NOZ[sl_minus];
Solver_multigrid.c:489:			    node += (E->mesh.NOX[start_lev]-1)*E->mesh.NOZ[start_lev];
Solver_multigrid.c:521:    const int dims =E->mesh.nsd;
Solver_multigrid.c:524:    const int nox = E->mesh.NOX[level];
Solver_multigrid.c:525:    const int noz = E->mesh.NOZ[level];
Solver_multigrid.c:526:    const int noy = E->mesh.NOY[level];
Solver_multigrid.c:527:    const int high_eqn = E->mesh.NEQ[level];
Solver_multigrid.c:529:    if (start_lev==E->mesh.levmax) return;
Solver_multigrid.c:540:  	      x1=E->Interp[level][1][node1];
Solver_multigrid.c:541:	      x2=E->Interp[level][1][node2];
Solver_multigrid.c:548:	      eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:549:	      eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:550:	      eqn2=E->ID[level][node2].doff[1]; 
Solver_multigrid.c:553:	      eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:554:	      eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:555:	      eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:559:		  eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:560:		  eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:561:		  eqn2=E->ID[level][node2].doff[3];	       
Solver_multigrid.c:575:  	        x1=E->Interp[level][2][node1];
Solver_multigrid.c:576:	        x2=E->Interp[level][2][node2];
Solver_multigrid.c:581:		eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:582:		eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:583:		eqn2=E->ID[level][node2].doff[1];  
Solver_multigrid.c:586:		eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:587:		eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:588:		eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:592:		    eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:593:		    eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:594:		    eqn2=E->ID[level][node2].doff[3];	       
Solver_multigrid.c:608:	            x1=E->Interp[level][3][node1];
Solver_multigrid.c:609:	            x2=E->Interp[level][3][node2];
Solver_multigrid.c:614:		    eqn0=E->ID[level][node0].doff[1];
Solver_multigrid.c:615:		    eqn1=E->ID[level][node1].doff[1];
Solver_multigrid.c:616:		    eqn2=E->ID[level][node2].doff[1];  
Solver_multigrid.c:619:		    eqn0=E->ID[level][node0].doff[2];
Solver_multigrid.c:620:		    eqn1=E->ID[level][node1].doff[2];
Solver_multigrid.c:621:		    eqn2=E->ID[level][node2].doff[2];
Solver_multigrid.c:624:		    eqn0=E->ID[level][node0].doff[3];
Solver_multigrid.c:625:		    eqn1=E->ID[level][node1].doff[3];
Solver_multigrid.c:626:		    eqn2=E->ID[level][node2].doff[3];	       
Solver_multigrid.c:654:    const int nsd=E->mesh.nsd;
Solver_multigrid.c:659:    viscU=(float *)malloc((1+vpts*E->mesh.NEL[E->mesh.levmax  ])*sizeof(float));
Solver_multigrid.c:660:    viscD=(float *)malloc((1+vpts*E->mesh.NEL[E->mesh.levmax-1])*sizeof(float));
Solver_multigrid.c:662:    visc_from_gint_to_nodes(E,E->EVI[E->mesh.levmax],viscU,E->mesh.levmax);
Solver_multigrid.c:663:    visc_from_nodes_to_gint(E,viscU,E->EVI[E->mesh.levmax],E->mesh.levmax);
Solver_multigrid.c:665:  for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--){
Solver_multigrid.c:668:    if (E->viscosity.smooth_cycles==0)  {
Solver_multigrid.c:669:      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:671:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:673:    else if (E->viscosity.smooth_cycles==1)  {
Solver_multigrid.c:674:      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:676:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:678:    else if (E->viscosity.smooth_cycles==2)   {
Solver_multigrid.c:679:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:680:      inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Solver_multigrid.c:682:    else if (E->viscosity.smooth_cycles==3)   {
Solver_multigrid.c:683:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:685:      visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:688:    visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:705:    const int dims =E->mesh.nsd;
Solver_multigrid.c:708:    const int nox = E->mesh.NOX[lev];
Solver_multigrid.c:709:    const int noz = E->mesh.NOZ[lev];
Solver_multigrid.c:710:    const int noy = E->mesh.NOY[lev];
Solver_multigrid.c:721:           x1=E->ECO[lev][E->NEI[lev].element[ends*(node1-1)]].size[1];
Solver_multigrid.c:722:           x2=E->ECO[lev][E->NEI[lev].element[(node2-1)*ends]].size[1];
Solver_multigrid.c:724:           E->Interp[lev][1][node1] = x1;
Solver_multigrid.c:725:           E->Interp[lev][1][node2] = x2;
Solver_multigrid.c:734:           x1=E->ECO[lev][E->NEI[lev].element[ends*(node1-1)]].size[2];
Solver_multigrid.c:735:           x2=E->ECO[lev][E->NEI[lev].element[(node2-1)*ends]].size[2];
Solver_multigrid.c:737:           E->Interp[lev][2][node1] = x1;
Solver_multigrid.c:738:           E->Interp[lev][2][node2] = x2;
Solver_multigrid.c:748:                    x1=E->ECO[lev][E->NEI[lev].element[ends*(node1-1)]].size[3];
Solver_multigrid.c:749:                    x2=E->ECO[lev][E->NEI[lev].element[(node2-1)*ends]].size[3];
Solver_multigrid.c:752:                    E->Interp[lev][3][node1] = x1;
Solver_multigrid.c:753:                    E->Interp[lev][3][node2] = x2;
Solver_multigrid.c:771:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:772:    const int dims=E->mesh.nsd;
Solver_multigrid.c:773:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:774:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:782:            e = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:800:    const int nno_minus=E->mesh.NNO[start_lev-1];
Solver_multigrid.c:801:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:802:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:803:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:812:                node1 = E->EL[sl_minus][el].sub[i];
Solver_multigrid.c:814:                    node=E->IEN[start_lev][node1].node[j];
Solver_multigrid.c:820:                node= E->IEN[sl_minus][el].node[i];
Solver_multigrid.c:822:                AD[node] += w * E->TWW[sl_minus][el].node[i];
Solver_multigrid.c:826:       AD[i] *= E->MASS[sl_minus][i];
Solver_multigrid.c:847:    const int nels_minus=E->mesh.NEL[start_lev-1];
Solver_multigrid.c:848:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:849:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:851:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c:860:                e = E->EL[sl_minus][el].sub[i];
Sphere_harmonics.c:19:  input_int ("llmax",&(E->sphere.llmax),"10");
Sphere_harmonics.c:20:  input_int ("selx",&(E->sphere.elx),"10");
Sphere_harmonics.c:22:    E->sphere.nox = E->sphere.elx + 1;
Sphere_harmonics.c:23:    E->sphere.nsf = E->sphere.nox;
Sphere_harmonics.c:24:    E->sphere.snel = E->sphere.elx;
Sphere_harmonics.c:26:  E->sphere.output_llmax = E->sphere.llmax;
Sphere_harmonics.c:28:  E->sphere.sx[1] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Sphere_harmonics.c:29:  E->sphere.sx[2] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Sphere_harmonics.c:30:  for (i=0;i<=E->sphere.llmax;i++)
Sphere_harmonics.c:31:    E->sphere.hindex[i] = i;
Sphere_harmonics.c:33:  E->sphere.hindice = E->sphere.llmax;
Sphere_harmonics.c:35:  E->sphere.con  = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:36:  E->sphere.sphc = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:38:  E->sphere.field = (double *)malloc((E->sphere.nsf+3)*sizeof(double));
Sphere_harmonics.c:40:  for (i=1;i<=E->sphere.elx*2;i++)
Sphere_harmonics.c:41:    E->sphere.tableplm[i]= (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:43:  for (i=1;i<=E->sphere.nox;i++)
Sphere_harmonics.c:44:    E->sphere.tableplm_n[i]= (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:46:  E->sphere.sien  = (struct SIEN *) malloc((E->sphere.snel+1)*sizeof(struct SIEN));
Sphere_harmonics.c:68:  for (i=1;i<=E->sphere.elx;i++) {
Sphere_harmonics.c:72:        E->sphere.sien[es].node[rr] = node 
Sphere_harmonics.c:76:  for (ll=0;ll<=E->sphere.output_llmax;ll++)   {
Sphere_harmonics.c:77:     E->sphere.con[E->sphere.hindex[ll]] = 
Sphere_harmonics.c:82:  dth = M_PI/E->sphere.elx;
Sphere_harmonics.c:84:  for (i=1;i<=E->sphere.nox;i++) {
Sphere_harmonics.c:85:    E->sphere.sx[1][i] = dth*(i-1);
Sphere_harmonics.c:111:  for (i=1;i<=E->sphere.elx;i++) {
Sphere_harmonics.c:114:      t = shl[1][intp]*E->sphere.sx[1][E->sphere.sien[es].node[1]]
Sphere_harmonics.c:115:        + shl[2][intp]*E->sphere.sx[1][E->sphere.sien[es].node[2]];
Sphere_harmonics.c:117:      E->sphere.tablesint[jj] = sin(t);
Sphere_harmonics.c:118:      for (ll=0;ll<=E->sphere.output_llmax;ll++)   {
Sphere_harmonics.c:120:         p = E->sphere.hindex[ll];
Sphere_harmonics.c:121:         E->sphere.tableplm[jj][p] = modified_plgndr_a(ll,mm,t) ;
Sphere_harmonics.c:126:  for (i=1;i<=E->sphere.nox;i++) {
Sphere_harmonics.c:128:    t=E->sphere.sx[1][node];
Sphere_harmonics.c:129:    E->sphere.tablesint_n[i] = sin(t);
Sphere_harmonics.c:130:    for (ll=0;ll<=E->sphere.output_llmax;ll++)  {
Sphere_harmonics.c:132:         p = E->sphere.hindex[ll];
Sphere_harmonics.c:133:         E->sphere.tableplm_n[i][p] = modified_plgndr_a(ll,mm,t) ;
Sphere_harmonics.c:158:   TG = (double *)malloc((E->sphere.nox+1)*sizeof(double));
Sphere_harmonics.c:159:   sphc= (double *)malloc((E->sphere.llmax+3)*sizeof(double));
Sphere_harmonics.c:161:   for (i=0;i<=E->sphere.hindice;i++)    {
Sphere_harmonics.c:166:   TG[E->sphere.nox] = X2[E->mesh.nox];
Sphere_harmonics.c:168:   for (i=1;i<E->sphere.nox;i++)            {
Sphere_harmonics.c:169:     for (j=i1;j<=E->mesh.elx;j++)  {
Sphere_harmonics.c:170:       if (E->sphere.sx[1][i]>=X1[j] && E->sphere.sx[1][i]<=X1[j+1])    {
Sphere_harmonics.c:171:          TG[i] = (X2[j+1]-X2[j])/(X1[j+1]-X1[j])*(E->sphere.sx[1][i]-X1[j]) + X2[j];
Sphere_harmonics.c:202:     TGAG[intp] = (double *)malloc((E->sphere.elx+1)*sizeof(double));
Sphere_harmonics.c:205:   for (i=0;i<=E->sphere.hindice;i++)    {
Sphere_harmonics.c:209:   for (i=1;i<=E->sphere.elx;i++) {
Sphere_harmonics.c:212:        i1 = E->sphere.sien[es].node[1];
Sphere_harmonics.c:213:        i2 = E->sphere.sien[es].node[2];
Sphere_harmonics.c:220:   area = 0.5*2.0*M_PI*M_PI/(E->sphere.elx);
Sphere_harmonics.c:222:   for (ll=0;ll<=E->sphere.output_llmax;ll++)   {
Sphere_harmonics.c:225:     p = E->sphere.hindex[ll];
Sphere_harmonics.c:227:     for (i=1;i<=E->sphere.elx;i++) {
Sphere_harmonics.c:230:             sphc[p]+=TGAG[intp][es]*E->sphere.tableplm[(i-1)*2+intp][p]*E->sphere.tablesint[(i-1)*2+intp]; 
Sphere_harmonics.c:251:   for (i=1;i<=E->sphere.nox;i++)  
Sphere_harmonics.c:254:   for (ll=0;ll<=E->sphere.output_llmax;ll++)   {
Sphere_harmonics.c:255:     p = E->sphere.hindex[ll];
Sphere_harmonics.c:257:     for (node=1;node<=E->sphere.nox;node++)    
Sphere_harmonics.c:258:       TG[node] += (sphc[p]*E->sphere.tableplm_n[node][p]);
Sphere_harmonics.c:279:   sprintf(filename,"%s.spec.%d",E->control.data_file,ii);
Sphere_harmonics.c:282:   TG1 = (double *)malloc((E->sphere.nox+1)*sizeof(double));
Sphere_harmonics.c:285:     for (node=1;node<E->sphere.nox;node++)
Sphere_harmonics.c:288:     t = 0.5*t/E->sphere.elx;
Sphere_harmonics.c:292:     for (node=1;node<=E->sphere.nox;node++)    {
Sphere_harmonics.c:299:     for (node=1;node<=E->sphere.nox;node++)
Sphere_harmonics.c:302:     for (ll=0;ll<=E->sphere.output_llmax;ll++)   {
Sphere_harmonics.c:303:         i = E->sphere.hindex[ll];
Sphere_harmonics.c:330:   TG = (double *)malloc((E->sphere.nox+1)*sizeof(double));
Sphere_harmonics.c:331:   sphc= (double *)malloc((E->sphere.llmax+3)*sizeof(double));
Sphere_harmonics.c:333:   for (i=0;i<=E->sphere.hindice;i++)    {
Sphere_harmonics.c:337:  ll= E->convection.perturb_ll[0];
Sphere_harmonics.c:338:  sphc[ll] = E->convection.perturb_mag[0];
Sphere_harmonics.c:342:   for (i=1;i<E->sphere.nox;i++)
Sphere_harmonics.c:353:   TG[E->sphere.nox] = X2[E->mesh.nox];
Sphere_harmonics.c:355:   for (i=1;i<E->sphere.nox;i++)            {
Sphere_harmonics.c:356:     for (j=i1;j<=E->mesh.elx;j++)  {
Sphere_harmonics.c:357:       if (E->sphere.sx[1][i]>=X1[j] && E->sphere.sx[1][i]<=X1[j+1])    {
Sphere_harmonics.c:358:          TG[i] = (X2[j+1]-X2[j])/(X1[j+1]-X1[j])*(E->sphere.sx[1][i]-X1[j]) + X2[j];
Sphere_harmonics.c:365:   for (i=1;i<E->sphere.nox;i++)
Stokes_flow_Incomp.c:36:    const int npno = E->mesh.npno;
Stokes_flow_Incomp.c:37:    const int gnpno = E->mesh.npno;
Stokes_flow_Incomp.c:38:    const int nno = E->mesh.nno;
Stokes_flow_Incomp.c:39:    const int dims = E->mesh.nsd;
Stokes_flow_Incomp.c:40:    const int neq = E->mesh.neq;
Stokes_flow_Incomp.c:41:    const int gneq = E->mesh.neq;
Stokes_flow_Incomp.c:45:    cycles=E->control.p_iterations;
Stokes_flow_Incomp.c:49:    residual_ddash=solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Stokes_flow_Incomp.c:53:    v_from_vector(E,E->V,E->U); 
Stokes_flow_Incomp.c:54:    dp_to_nodes(E,E->P,E->NP,E->mesh.levmax);   
Stokes_flow_Incomp.c:93:  const int dims=E->mesh.nsd;
Stokes_flow_Incomp.c:94:  const int n=loc_mat_size[E->mesh.nsd];
Stokes_flow_Incomp.c:96:  npno=E->mesh.npno;
Stokes_flow_Incomp.c:97:  neq=E->mesh.neq;
Stokes_flow_Incomp.c:99:  gnpno=E->mesh.npno;
Stokes_flow_Incomp.c:100:  gneq=E->mesh.neq;
Stokes_flow_Incomp.c:120:  lev=E->mesh.levmax;
Stokes_flow_Incomp.c:134:  valid=solve_del2_u(E,u1,Ah,imp*v_res,E->mesh.levmax);
Stokes_flow_Incomp.c:147:  E->monitor.vdotv = sqrt(vdot(E,V,V,lev)/gneq);
Stokes_flow_Incomp.c:149:  E->monitor.incompressibility = residual/E->monitor.vdotv;
Stokes_flow_Incomp.c:157:   if (E->control.print_convergence)  {
Stokes_flow_Incomp.c:158:         fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles); /**/
Stokes_flow_Incomp.c:159:         fflush(E->fp);
Stokes_flow_Incomp.c:165:  while( count==0 || ((count < *steps_max) && (dvelocity >= imp || dpressure >=imp) && E->monitor.incompressibility >= E->control.tole_comp) )  { 
Stokes_flow_Incomp.c:169:       z1[j] = E->BPI[lev][j]*r1[j];
Stokes_flow_Incomp.c:207:     E->monitor.vdotv = vdot(E,V,V,E->mesh.levmax);
Stokes_flow_Incomp.c:208:     E->monitor.incompressibility = sqrt((gneq/gnpno)*(1.0e-32+pdot(E,Ah,Ah,lev)/(1.0e-32+E->monitor.vdotv)));
Stokes_flow_Incomp.c:211:     dvelocity=alpha*sqrt(vdot(E,u1,u1,lev)/(1.0e-32+E->monitor.vdotv));
Stokes_flow_Incomp.c:214:     if (E->control.print_convergence && count%5==0)  {
Stokes_flow_Incomp.c:215:       fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d dv=%g dp=%g\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles,dvelocity,dpressure); /**/
Stokes_flow_Incomp.c:216:       fflush(E->fp);
Stokes_flow_Incomp.c:226:      fprintf(E->fp,"Convergence of velocity solver may affect continuity\n");
Stokes_flow_Incomp.c:227:      fprintf(E->fp,"Consider running with the `see_convergence=on' option\n");
Stokes_flow_Incomp.c:228:      fprintf(E->fp,"To evaluate the performance of the current relaxation parameters\n");
Stokes_flow_Incomp.c:229:      fflush(E->fp);
Stokes_flow_Incomp.c:265:  const int addi_dof = additional_dof[E->mesh.nsd];
Stokes_flow_Incomp.c:266:  const int nno = E->mesh.nno;
Stokes_flow_Incomp.c:267:  const int dofs = E->mesh.dof;
Stokes_flow_Incomp.c:270:      if(E->node[node] & OFFSIDE) continue;
Stokes_flow_Incomp.c:272:      V[1][node] = F[E->id[node].doff[1]]; 
Stokes_flow_Incomp.c:273:      V[2][node] = F[E->id[node].doff[2]]; 
Stokes_flow_Incomp.c:274:      if(dofs==3) V[3][node] = F[E->id[node].doff[3]];
Stokes_flow_Incomp.c:275:      if (E->node[node] & VBX)
Stokes_flow_Incomp.c:276:             V[1][node] = E->VB[1][node]; 
Stokes_flow_Incomp.c:277:      if (E->node[node] & VBZ)
Stokes_flow_Incomp.c:278:             V[2][node] = E->VB[2][node]; 
Stokes_flow_Incomp.c:279:      if (dofs==3 && E->node[node] & VBY)
Stokes_flow_Incomp.c:280:             V[3][node] = E->VB[3][node]; 
Topo_gravity.c:72:    const int dims=E->mesh.nsd;
Topo_gravity.c:76:    const int noz=E->mesh.noz;
Topo_gravity.c:77:    const int noy=E->mesh.noy;
Topo_gravity.c:78:    const int nno=E->mesh.nno;
Topo_gravity.c:81:    const int elz = E->mesh.elz;
Topo_gravity.c:82:    const int ely = E->mesh.ely;
Topo_gravity.c:83:    const int lev=E->mesh.levmax;
Topo_gravity.c:85:    lnsf=E->mesh.nsf;
Topo_gravity.c:99:    for(els=1;els<=E->mesh.snel;els++) {
Topo_gravity.c:100:	    el = E->surf_element[els];
Topo_gravity.c:104:          nodeb= E->ien[elb].node[m+1];
Topo_gravity.c:105:          eub[m*dims  ] = E->V[1][nodeb];
Topo_gravity.c:106:          eub[m*dims+1] = E->V[2][nodeb];
Topo_gravity.c:108:            eub[m*dims+2] = E->V[3][nodeb]; 
Topo_gravity.c:112:          node = E->ien[el].node[m+1];
Topo_gravity.c:113:          eu [m*dims  ] = E->V[1][node];
Topo_gravity.c:114:          eu [m*dims+1] = E->V[2][node];
Topo_gravity.c:116:            eu [m*dims+2] = E->V[3][node];
Topo_gravity.c:127:          res[m]  = eltf[m]  - E->elt_del[lev][el].g[m][0]  * E->P[el];
Topo_gravity.c:128:          resb[m] = eltfb[m] - E->elt_del[lev][elb].g[m][0]* E->P[elb];
Topo_gravity.c:142:		    RL[E->sien[els].node[1]] += resb[(m-1)*dims+1];  
Topo_gravity.c:145:		    RL[E->sien[els].node[2]] += resb[(m-1)*dims+1];  
Topo_gravity.c:148:		    RL[E->sien[els].node[3]] += resb[(m-1)*dims+1];  
Topo_gravity.c:151:		    RL[E->sien[els].node[4]] += resb[(m-1)*dims+1];  
Topo_gravity.c:160:		    RU[E->sien[els].node[1]] += res[(m-1)*dims+1];  
Topo_gravity.c:163:		    RU[E->sien[els].node[2]] += res[(m-1)*dims+1];  
Topo_gravity.c:166:		    RU[E->sien[els].node[3]] += res[(m-1)*dims+1];  
Topo_gravity.c:169:		    RU[E->sien[els].node[4]] += res[(m-1)*dims+1];  
Topo_gravity.c:177:    for(els=1;els<=E->mesh.snel;els++) {
Topo_gravity.c:178:	    el = E->surf_element[els];
Topo_gravity.c:190:			 * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:193:			 * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:198:	      SL[E->sien[els].node[m]] += eltTL[m-1];
Topo_gravity.c:201:	           SU[E->sien[els].node[m]] += eltTU[m-1];
Topo_gravity.c:205:      for(i=1;i<=E->mesh.nsf;i++)
Topo_gravity.c:208:      for(i=1;i<=E->mesh.nsf;i++)
Topo_gravity.c:231:    Szz=(float *) malloc((1+E->mesh.nno)*sizeof(float));
Topo_gravity.c:233:    get_Szz(E,E->P,Szz,ii);
Topo_gravity.c:235:    for(snode=1;snode<=E->mesh.nsf;snode++)   {
Topo_gravity.c:236:           node = E->surf_node[snode];
Topo_gravity.c:238:	   tpgb[snode] = 2*Szz[node-E->mesh.noz+1]-Szz[node-E->mesh.noz+2]; 
Topo_gravity.c:263:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Topo_gravity.c:267:    const int nno=E->mesh.nno;
Topo_gravity.c:268:    const int lev=E->mesh.levmax;
Topo_gravity.c:271:    SXX = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:272:    SYY = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:273:    SXY = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:274:    SXZ = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:275:    SZY = (float *)malloc((E->mesh.nno+1)*sizeof(float));
Topo_gravity.c:278:    for(i=1;i<=E->mesh.nno;i++) {
Topo_gravity.c:282:    for(e=1;e<=E->mesh.nel;e++)  {
Topo_gravity.c:284:      get_global_shape_fn(E,e,&GN,&GNx,&dOmega,xk,0,E->mesh.levmax);
Topo_gravity.c:287:	  visc[i] =  E->EVI[E->mesh.levmax][(e-1)*vpts+i] * dOmega.vpt[i];
Topo_gravity.c:292:          VZ[j] = E->V[2][E->ien[e].node[j]];
Topo_gravity.c:302:      Szz /= E->eco[e].area;
Topo_gravity.c:307:	    node = E->ien[e].node[j];
Topo_gravity.c:308:	    SZZ[node] += E->TWW[E->mesh.levmax][e].node[j] * Szz;  
Topo_gravity.c:313:   for(node=1;node<=E->mesh.nno;node++)  {
Topo_gravity.c:314:     SZZ[node] = SZZ[node]*E->Mass[node];
Viscosity_structures.c:39:    E->viscosity.update_allowed = 0; 
Viscosity_structures.c:40:    E->viscosity.SDEPV = E->viscosity.TDEPV = E->viscosity.CHEMDEPV = 0;
Viscosity_structures.c:41:    E->viscosity.EXPX=0;
Viscosity_structures.c:43:    input_string("Viscosity",E->viscosity.STRUCTURE,NULL);   /* Which form of viscosity */
Viscosity_structures.c:45:    input_boolean("VISC_EQUIVDD",&(E->viscosity.EQUIVDD),"off");    /* Whether to average it */
Viscosity_structures.c:46:    input_int("equivdd_opt",&(E->viscosity.equivddopt),"1");
Viscosity_structures.c:47:    input_int("equivdd_x",&(E->viscosity.proflocx),"1");
Viscosity_structures.c:48:    input_int("equivdd_y",&(E->viscosity.proflocy),"1");
Viscosity_structures.c:50:    input_boolean("VISC_SMOOTH",&(E->viscosity.SMOOTH),"off");
Viscosity_structures.c:51:    input_int ("visc_smooth_cycles",&(E->viscosity.smooth_cycles),"0");
Viscosity_structures.c:53:    if ( strcmp(E->viscosity.STRUCTURE,"system") == 0) /* Interpret */ {
Viscosity_structures.c:54:      fprintf(E->fp,"Viscosity derived from system state\n");
Viscosity_structures.c:55:      E->viscosity.FROM_SYSTEM = 1;
Viscosity_structures.c:76:       E->viscosity.N0[i]=1.0;
Viscosity_structures.c:77:       E->viscosity.T[i] = 0.0;
Viscosity_structures.c:78:       E->viscosity.Z[i] = 0.0;
Viscosity_structures.c:79:       E->viscosity.E[i] = 0.0;
Viscosity_structures.c:80:       E->viscosity.T0[i] = 0.0;
Viscosity_structures.c:84:    input_int("rheol",&(E->viscosity.RHEOL),"essential");
Viscosity_structures.c:85:    input_int("num_mat",&(E->viscosity.num_mat),"1");
Viscosity_structures.c:87:    input_float_vector("viscT",E->viscosity.num_mat,(E->viscosity.T));  /* redundant */
Viscosity_structures.c:88:    input_float_vector("viscT1",E->viscosity.num_mat,(E->viscosity.T));
Viscosity_structures.c:89:    input_float_vector("viscZ",E->viscosity.num_mat,(E->viscosity.Z));
Viscosity_structures.c:90:    input_float_vector("viscE",E->viscosity.num_mat,(E->viscosity.E));
Viscosity_structures.c:91:    input_float_vector("viscT0",E->viscosity.num_mat,(E->viscosity.T0));
Viscosity_structures.c:92:    input_float_vector("visc0",E->viscosity.num_mat,(E->viscosity.N0)); /* redundant */
Viscosity_structures.c:93:    input_float_vector("viscN0",E->viscosity.num_mat,(E->viscosity.N0));
Viscosity_structures.c:95:    input_boolean("CHEMDEPV",&(E->viscosity.CHEMDEPV),"on");
Viscosity_structures.c:96:    input_boolean("TDEPV",&(E->viscosity.TDEPV),"on");
Viscosity_structures.c:97:    input_boolean("SDEPV",&(E->viscosity.SDEPV),"off");
Viscosity_structures.c:99:    input_float("sdepv_misfit",&(E->viscosity.sdepv_misfit),"0.001");
Viscosity_structures.c:100:    input_float_vector("sdepv_expt",E->viscosity.num_mat,(E->viscosity.sdepv_expt));
Viscosity_structures.c:101:    input_float_vector("sdepv_trns",E->viscosity.num_mat,(E->viscosity.sdepv_trns));
Viscosity_structures.c:103:    input_boolean("TDEPV_AVE",&(E->viscosity.TDEPV_AVE),"off");
Viscosity_structures.c:104:    input_boolean("VFREEZE",&(E->viscosity.FREEZE),"off");
Viscosity_structures.c:105:    input_boolean("VMAX",&(E->viscosity.MAX),"off");
Viscosity_structures.c:106:    input_boolean("VMIN",&(E->viscosity.MIN),"off");
Viscosity_structures.c:107:    input_boolean("VISC_UPDATE",&(E->viscosity.update_allowed),"on");
Viscosity_structures.c:109:    if (E->viscosity.TDEPV || E->viscosity.SDEPV)
Viscosity_structures.c:110:        E->viscosity.update_allowed = 1;
Viscosity_structures.c:112:    input_float("freeze_thresh",&(E->viscosity.freeze_thresh),"0.0");
Viscosity_structures.c:113:    input_float("freeze_value",&(E->viscosity.freeze_value),"1.0");
Viscosity_structures.c:114:    input_float("visc_max",&(E->viscosity.max_value),"nodefault");
Viscosity_structures.c:115:    input_float("visc_min",&(E->viscosity.min_value),"nodefault");
Viscosity_structures.c:117:    input_boolean("VISC_GUESS",&(E->viscosity.guess),"off");
Viscosity_structures.c:118:    input_string("visc_old_file",E->viscosity.old_file," ");
Viscosity_structures.c:120: if (E->rad_heat.num)   {
Viscosity_structures.c:121:    for (l=0;l<E->viscosity.num_mat;l++)  {
Viscosity_structures.c:122:      E->viscosity.Z[l] = E->data.density*E->data.grav_acc*E->sphere.ro_dim*E->viscosity.Z[l]/(E->data.gas_const*E->data.ref_temperature);
Viscosity_structures.c:123:      E->viscosity.E[l] = E->viscosity.E[l]/(E->data.gas_const*E->data.ref_temperature);
Viscosity_structures.c:124:     fprintf(E->fp,"E & Z %g %g\n",E->viscosity.E[l],E->viscosity.Z[l]);
Viscosity_structures.c:128:    if(!E->viscosity.update_allowed)  {
Viscosity_structures.c:129:      get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Viscosity_structures.c:149:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:151:    if(E->viscosity.TDEPV)
Viscosity_structures.c:156:    if(E->viscosity.SDEPV)
Viscosity_structures.c:159:/*    if (E->viscosity.SMOOTH) 
Viscosity_structures.c:162:    if(E->viscosity.MAX) {
Viscosity_structures.c:163:      for(i=1;i<=E->mesh.nel;i++)
Viscosity_structures.c:165:            if(evisc[(i-1)*vpts + j] > E->viscosity.max_value)
Viscosity_structures.c:166:               evisc[(i-1)*vpts + j] = E->viscosity.max_value;
Viscosity_structures.c:170:    if(E->viscosity.MIN) {
Viscosity_structures.c:171:      for(i=1;i<=E->mesh.nel;i++)
Viscosity_structures.c:173:            if(evisc[(i-1)*vpts + j] < E->viscosity.min_value)
Viscosity_structures.c:174:               evisc[(i-1)*vpts + j] = E->viscosity.min_value;
Viscosity_structures.c:177:    v_to_nodes(E,evisc,visc,E->mesh.levmax);
Viscosity_structures.c:194:    ViscCentre = (float *)malloc((E->mesh.nno+10)*sizeof(float));
Viscosity_structures.c:197:    for(i=1;i<=E->viscosity.smooth_cycles;i++)  {
Viscosity_structures.c:198:	p_to_centres(E,visc,ViscCentre,E->mesh.levmax);
Viscosity_structures.c:199:	p_to_nodes(E,ViscCentre,visc,E->mesh.levmax);
Viscosity_structures.c:215:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:216:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:218:    for(i=1;i<=E->mesh.nel;i++)   {
Viscosity_structures.c:219:      for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)  {
Viscosity_structures.c:220:        EEta[ (i-1)*vpoints[E->mesh.nsd]+jj ]=E->viscosity.N0[E->mat[i]-1];
Viscosity_structures.c:238:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:239:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:240:    const int nel = E->mesh.nel;
Viscosity_structures.c:241:    const int noz = E->mesh.noz;
Viscosity_structures.c:246:    slope = (1.0-E->data.visc_factor)/(E->sphere.ro-E->sphere.ri);
Viscosity_structures.c:249:       E->Have.Tadi[i] = 0.0;
Viscosity_structures.c:251:    E->data.T_adi0 = 0;
Viscosity_structures.c:252:    E->data.T_adi1 = 0;
Viscosity_structures.c:254:    switch (E->viscosity.RHEOL)   {
Viscosity_structures.c:257:            fprintf(E->fp,"\tRheological option 1:\n");
Viscosity_structures.c:259:            for(l=1;l<=E->viscosity.num_mat;l++) {
Viscosity_structures.c:260:              fprintf(E->fp,"\tlayer %d/%d: E=%g T1=%g \n",
Viscosity_structures.c:261:                      l,E->viscosity.num_mat,
Viscosity_structures.c:262:                      E->viscosity.E[l-1],E->viscosity.T[l-1]);
Viscosity_structures.c:264:            fflush(E->fp);
Viscosity_structures.c:268:     if (E->control.adi_heating)  {
Viscosity_structures.c:270:	  E->data.T_adi0 = 0;
Viscosity_structures.c:272:            if (E->X[2][i]<(2*E->viscosity.zlith-E->sphere.ro))  {
Viscosity_structures.c:273:               temp3 = E->Have.T[i];
Viscosity_structures.c:277:          E->data.T_adi0 = temp3;
Viscosity_structures.c:278:	  E->Have.Tadi[noz] = temp3;
Viscosity_structures.c:280:            if (E->X[2][i]<(2*E->viscosity.zlith-E->sphere.ro))
Viscosity_structures.c:281:               temp3 = temp3 + E->data.disptn_number*(E->expansivity[i]+E->expansivity[i-1])*(E->Have.T[i]+E->Have.T[i-1]+2*E->data.surf_temp)/4.0*(E->X[2][i]-E->X[2][i-1]);
Viscosity_structures.c:282:            E->Have.Tadi[i-1] = temp3;
Viscosity_structures.c:285:	  E->data.T_adi1 = E->Have.Tadi[1];
Viscosity_structures.c:286:	  temp2 = one-E->data.T_adi1 + E->data.T_adi0;
Viscosity_structures.c:291:            l = E->mat[i];
Viscosity_structures.c:292:	    e = (i-1)%E->mesh.elz+1;
Viscosity_structures.c:294:            tempa = E->viscosity.N0[l-1];
Viscosity_structures.c:295:	    temp1 = (E->Have.Tadi[e] + E->Have.Tadi[e+1])*0.5 -E->data.T_adi0;
Viscosity_structures.c:299:               TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:305:			  temp[jj] += E->T[E->ien[i].node[kk]]*E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:306:                          rii[jj] += E->X[2][E->ien[i].node[kk]]*E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:308:		       EEta[ (i-1)*vpoints[E->mesh.nsd]+jj ]=tempa*exp(E->viscosity.E[l-1]*(temp2-(temp[jj]))/temp2)
Viscosity_structures.c:309:			       *(E->data.visc_factor+slope*(rii[jj]-E->sphere.ri));
Viscosity_structures.c:320:            fprintf(E->fp,"\tRheological option 3:\n");
Viscosity_structures.c:322:            for(l=1;l<=E->viscosity.num_mat;l++) {
Viscosity_structures.c:323:              fprintf(E->fp,"\tlayer %d/%d: E=%g T1=%g \n",
Viscosity_structures.c:324:                      l,E->viscosity.num_mat,
Viscosity_structures.c:325:                      E->viscosity.E[l-1],E->viscosity.T[l-1]);
Viscosity_structures.c:327:            fflush(E->fp);
Viscosity_structures.c:330:	/*fprintf(stderr,"Ts=%g\n",E->data.surf_temp);*/
Viscosity_structures.c:333:            l = E->mat[i];
Viscosity_structures.c:334:            tempa = E->viscosity.N0[l-1];
Viscosity_structures.c:338:               TT[kk] = E->T[E->ien[i].node[kk]];
Viscosity_structures.c:344:                  rii[jj] += E->X[2][E->ien[i].node[kk]]*E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:345:                  temp[jj] += E->T[E->ien[i].node[kk]]*E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:347:               temp1 = (E->viscosity.E[E->mat[i]-1]+ 
Viscosity_structures.c:348:                   E->viscosity.Z[E->mat[i]-1]*(E->sphere.ro-rii[jj]))
Viscosity_structures.c:349:                          /(temp[jj]+E->data.surf_temp)
Viscosity_structures.c:350:                 -(E->viscosity.E[E->mat[i]-1]+
Viscosity_structures.c:351:                   E->viscosity.Z[E->mat[i]-1]*(E->sphere.ro-E->sphere.ri))
Viscosity_structures.c:352:                          /(1.0+E->data.surf_temp);
Viscosity_structures.c:353:               EEta[ (i-1)*vpoints[E->mesh.nsd]+jj ]=E->viscosity.N0[E->mat[i]-1]*exp(temp1);
Viscosity_structures.c:378:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:379:    const int nel = E->mesh.nel;
Viscosity_structures.c:393:        exponent1= one-one/E->viscosity.sdepv_expt[E->mat[e]-1];
Viscosity_structures.c:394:	    scale=pow(two*eedot[e]/E->viscosity.sdepv_trns[E->mat[e]-1],exponent1);
Viscosity_structures.c:423:    const int dims = E->mesh.nsd;
Viscosity_structures.c:425:    const int lev = E->mesh.levmax;
Viscosity_structures.c:426:    const int nno = E->mesh.nno;
Viscosity_structures.c:429:    nel = E->mesh.nel;
Viscosity_structures.c:436:        n=E->ien[e].node[i];
Viscosity_structures.c:437:          VV[1][i] = E->V[1][n];
Viscosity_structures.c:438:          VV[2][i] = E->V[2][n];
Viscosity_structures.c:447:        dudx[1][1] += VV[1][i]*GNx.ppt[GNPXINDEX(0,i,1)] + VV[2][i]*E->N.ppt[GNPINDEX(i,1)]*xk[2][1];
Viscosity_structures.c:449:        dudx[3][3] += ( VV[2][i] + VV[1][i]*xk[1][1] )*E->N.ppt[GNPINDEX(i,1)]*xk[2][1];
Viscosity_structures.c:450:        dudx[1][2] += VV[2][i]*GNx.ppt[GNPXINDEX(0,i,1)] + VV[1][i]*GNx.ppt[GNPXINDEX(1,i,1)]-VV[1][i]*xk[2][1]*E->N.ppt[GNPINDEX(i,1)];
Viscosity_structures.c:480:    if (x2>=E->viscosity.zlith)
Viscosity_structures.c:482:    else if (x2>=E->viscosity.zlm)
